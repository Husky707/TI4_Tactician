--- Shared system (and generic resource/influence cards) helper object.
-- @author GarnetBear added the original influence/resource list.
-- @author Darrell June 2020 more attributes, planet positions.
-- #include <~/TI4-TTS/TI4/Helpers/TI4_SystemHelper>

-- Users should copy this getHelperClient function, and use via:
--
-- local systemHelper = getHelperClient('TI4_SYSTEM_HELPER')
-- local system = systemHelper.systemFromPosition({x,y,z})
-- local cardNameToAttributes = systemHelper.nonPlanetResourceInfluenceCards()
--
-- Where one can call any main function in this file via the helper.
function getHelperClient(helperObjectName)
    local helperObject = Global.call('getHelper', helperObjectName)
    local function getCallWrapper(functionName)
        helperObject = helperObject or getHelperObject()
        if not helperObject.getVar(functionName) then error('missing ' .. helperObjectName .. '.' .. functionName) end
        return function(parameters) return helperObject.call(functionName, parameters) end
    end
    return setmetatable({}, { __index = function(t, k) return getCallWrapper(k) end })
end
local _deckHelper = getHelperClient('TI4_DECK_HELPER')
local _factionHelper = getHelperClient('TI4_FACTION_HELPER')
local _unitHelper = getHelperClient('TI4_UNIT_HELPER')
local _zoneHelper = getHelperClient('TI4_ZONE_HELPER')
local _exploreHelper = getHelperClient('TI4_EXPLORE_HELPER')

local function copyTable(t)
    if t and type(t) == 'table' then
        local copy = {}
        for k, v in pairs(t) do
            copy[k] = type(v) == 'table' and copyTable(v) or v
        end
        t = copy
    end
    return t
end

-- Systems table, from guid to systems.
--
-- System attributes:
-- - source = "stringName"
-- - tile: number, for large system sets,consider choosing a prefix number, then have each system be a decimal increment of that prefix: 8000.00, 8000.01, 8000.02 ...
-- - home: boolean, true if a home system.
-- - faction: "nameOfFactionOrAbility", links the system to a faction or abiltiy
-- - planets: list of planet tables.
-- - wormholes: list of strings.
      --wormholes_faceUp|wormholes_faceDown: lists of strings(Mallice)
-- - anomalies: list of strings.
-- - rotate: override, degrees number.
-- - localY: override tile height (ghosts home system).
-- - hyperlane: boolean, true if a hyperlane.
-- - offMap: boolean, if true not part of the system map (e.g. do not count for slice r/i).
--
-- Planet attributes:
-- - name: string.
-- - resources: number.
-- - influence: number.
-- - trait: string {cultural|industrial|hazardous}.
-- - tech: string {red|green|yellow|blue}.
-- - position: table with {xz}: override, local space.
-- - radius: number: override, local space.
-- - legendary: boolean.
--
-- Also computed:
-- - system.guid: tile GUID.
-- - system.zoneEdgePositions: local edge positions carving per-planet zones.
-- - system.planets[].position: local {xyz} position.
-- - system.planets[].radius: local space.
--
local _systems = {
    ['e06224'] = { tile = 1, home = true, planets = {
        { name = 'Jord', resources = 4, influence = 2 },
    }},
    ['aa880a'] = { tile = 2, home = true, planets = {
        { name = 'Moll Primus', resources = 4, influence = 1 },
    }},
    ['3972ec'] = { tile = 3, home = true, planets = {
        { name = 'Darien', resources = 4, influence = 4 },
    }},
    ['9930d6'] = { tile = 4, home = true, planets = {
        { name = 'Muaat', resources = 4, influence = 1 },
    }},
    ['7e95d2'] = { tile = 5, home = true, planets = {
        { name = 'Nestphar', resources = 3, influence = 2 },
    }},
    ['6a93ea'] = { tile = 6, home = true, planets = {
        { name = '[0.0.0]', resources = 5, influence = 0 },
    }},
    ['aeda64'] = { tile = 7, home = true, planets = {
        { name = 'Winnu', resources = 3, influence = 4 },
    }},
    ['3ec552'] = { tile = 8, home = true, planets = {
        { name = 'Mordai II', resources = 4, influence = 0 },
    }},
    ['f5a2d6'] = { tile = 9, home = true, planets = {
        { name = 'Maaluuk', resources = 0, influence = 2 },
        { name = 'Druaa', resources = 3, influence = 1 },
    }},
    ['ef90b2'] = { tile = 10, home = true, planets = {
        { name = 'Arc Prime', resources = 4, influence = 0 },
        { name = 'Wren Terra', resources = 2, influence = 1 },
    }},
    ['7b343b'] = { tile = 11, home = true, planets = {
        { name = 'Lisis II', resources = 1, influence = 0 },
        { name = 'Ragh', resources = 2, influence = 1 },
    }},
    ['5cb889'] = { tile = 12, home = true, planets = {
        { name = 'Nar', resources = 2, influence = 3 },
        { name = 'Jol', resources = 1, influence = 2 },
    }},
    ['275148'] = { tile = 13, home = true, planets = {
        { name = "Tren'Lak", resources = 1, influence = 0 },
        { name = 'Quinarra', resources = 3, influence = 1 },
    }},
    ['c9db03'] = { tile = 14, home = true, planets = {
        { name = 'Archon Ren', resources = 2, influence = 3 },
        { name = 'Archon Tau', resources = 1, influence = 1 },
    }},
    ['8c72e3'] = { tile = 15, home = true, planets = {
        { name = 'Retillion', resources = 2, influence = 3 },
        { name = 'Shalloq', resources = 1, influence = 2 },
    }},
    ['2fcfd0'] = { tile = 16, home = true, planets = {
        { name = 'Hercant', resources = 1, influence = 1 },
        { name = 'Arretze', resources = 2, influence = 0 },
        { name = 'Kamdorn', resources = 0, influence = 1 },
    }},
    ['98369f'] = { tile = 17, home = true, wormholes = { 'delta' } }, -- not precisely a home, but tied to faction
    ['3442d7'] = { tile = 18, planets = {
        { name = 'Mecatol Rex', resources = 1, influence = 6, radius = 1.7 },
    }},
    ['105fad'] = { tile = 19, planets = {
        { name = 'Wellon', resources = 1, influence = 2, trait = 'industrial', tech = 'yellow' },
    }},
    ['e0b992'] = { tile = 20, planets = {
        { name = 'Vefut II', resources = 2, influence = 2, trait = 'hazardous' },
    }},
    ['b1f9fb'] = { tile = 21, planets = {
        { name = 'Thibah', resources = 1, influence = 1, trait = 'industrial', tech = 'blue' },
    }},
    ['d9bdc7'] = { tile = 22, planets = {
        { name = "Tar'Mann", resources = 1, influence = 1, trait = 'industrial', tech = 'green' },
    }},
    ['387d24'] = { tile = 23, planets = {
        { name = 'Saudor', resources = 2, influence = 2, trait = 'industrial' },
    }},
    ['a59f2c'] = { tile = 24, planets = {
        { name = 'Mehar Xull', resources = 1, influence = 3, trait = 'hazardous', tech = 'red' },
    }},
    ['5b1d07'] = { tile = 25, wormholes = { 'beta' }, planets = {
        { name = 'Quann', resources = 2, influence = 1, trait = 'cultural' },
    }},
    ['31e03b'] = { tile = 26, wormholes = { 'alpha' }, planets = {
        { name = 'Lodor', resources = 3, influence = 1, trait = 'cultural' },
    }},
    ['35d7dc'] = { tile = 27, planets = {
        { name = 'New Albion', resources = 1, influence = 1, trait = 'industrial', tech = 'green' },
        { name = 'Starpoint', resources = 3, influence = 1, trait = 'hazardous' },
    }},
    ['1b163e'] = { tile = 28, planets = {
        { name = "Tequ'Ran", resources = 2, influence = 0 , trait = 'hazardous' },
        { name = 'Torkan', resources = 0, influence = 3, trait = 'cultural' },
    }},
    ['9be0b1'] = { tile = 29, planets = {
        { name = "Qucen'n", resources = 1, influence = 2, trait = 'industrial' },
        { name = 'Rarron', resources = 0, influence = 3, trait = 'cultural' },
    }},
    ['dad8f9'] = { tile = 30, planets = {
        { name = 'Mellon', resources = 0, influence = 2, trait = 'cultural' },
        { name = 'Zohbat', resources = 3, influence = 1, trait = 'hazardous' },
    }},
    ['de7dec'] = { tile = 31, planets = {
        { name = 'Lazar', resources = 1, influence = 0, trait = 'industrial', tech = 'yellow' },
        { name = 'Sakulag', resources = 2, influence = 1, trait = 'hazardous' },
    }},
    ['1c0625'] = { tile = 32, planets = {
        { name = 'Dal Bootha', resources = 0, influence = 2, trait = 'cultural' },
        { name = 'Xxehan', resources = 1, influence = 1, trait = 'cultural' },
    }},
    ['dcd17c'] = { tile = 33, planets = {
        { name = 'Corneeq', resources = 1, influence = 2, trait = 'cultural' },
        { name = 'Resculon', resources = 2, influence = 0, trait = 'cultural' },
    }},
    ['350970'] = { tile = 34, planets = {
        { name = 'Centauri', resources = 1, influence = 3, trait = 'cultural' },
        { name = 'Gral', resources = 1, influence = 1, trait = 'industrial', tech = 'blue' },
    }},
    ['322174'] = { tile = 35, planets = {
        { name = 'Bereg', resources = 3, influence = 1, trait = 'hazardous' },
        { name = 'Lirta IV', resources = 2, influence = 3, trait = 'hazardous' },
    }},
    ['e97aac'] = { tile = 36, planets = {
        { name = 'Arnor', resources = 2, influence = 1, trait = 'industrial' },
        { name = 'Lor', resources = 1, influence = 2, trait = 'industrial' },
    }},
    ['cae2ce'] = { tile = 37, planets = {
        { name = 'Arinam', resources = 1, influence = 2, trait = 'industrial' },
        { name = 'Meer', resources = 0, influence = 4, trait = 'hazardous', tech = 'red' },
    }},
    ['69f885'] = { tile = 38, planets = {
        { name = 'Abyz', resources = 3, influence = 0, trait = 'hazardous' },
        { name = 'Fria', resources = 2, influence = 0, trait = 'hazardous' },
    }},
    ['33520d'] = { tile = 39, wormholes = { 'alpha' } },
    ['b0a6a6'] = { tile = 40, wormholes = { 'beta' } },
    ['3ea35d'] = { tile = 41, anomalies = { 'gravity rift' } },
    ['4d6424'] = { tile = 42, anomalies = { 'nebula' } },
    ['0b360f'] = { tile = 43, anomalies = { 'supernova' } },
    ['006abc'] = { tile = 44, anomalies = { 'asteroid field' } },
    ['120e40'] = { tile = 45, anomalies = { 'asteroid field' } },
    ['b50950'] = { tile = 46 },
    ['faec50'] = { tile = 47 },
    ['12a49a'] = { tile = 48 },
    ['8f40b4'] = { tile = 49 },
    ['d83cd4'] = { tile = 50 },
    ['e3be37'] = { tile = 51, home = true, wormholes = { 'delta' }, offMap = true, planets = {
        { name = 'Creuss', resources = 4, influence = 2, position = { x = -0.05, z = -0.4 }, radius = 0.8 },
    }},

    -- PoK systems.
    ['2bc02a'] = { source = "POK", tile = 52, home = true, planets = {
        { name = 'Ixth', resources = 3, influence = 5 },
    }},
    ['811df5'] = { source = "POK", tile = 53, home = true, planets = {
        { name = 'Arcturus', resources = 4, influence = 4 },
    }},
    ['8e0645'] = { source = "POK", tile = 54, home = true, planets = {
        { name = 'Acheron', resources = 4, influence = 0 },
    }},
    ['98d4c2'] = { source = "POK", tile = 55, home = true, planets = {
        { name = 'Elysium', resources = 4, influence = 1, radius = 1.5 },
    }},
    ['110112'] = { source = "POK", tile = 56, home = true, anomalies = { 'nebula' }, planets = {
        { name = 'The Dark', resources = 3, influence = 4 },
    }},
    ['49318b'] = { source = "POK", tile = 57, home = true, planets = {
        { name = 'Naazir', resources = 2, influence = 1 },
        { name = 'Rokha', resources = 1, influence = 2 },
    }},
    ['6f20aa'] = { source = "POK", tile = 58, home = true, planets = {
        { name = 'Valk', resources = 2, influence = 0 },
        { name = 'Ylir', resources = 0, influence = 2 },
        { name = 'Avar', resources = 1, influence = 1 },
    }},
    ['6b5ed1'] = { source = "POK", tile = 59, planets = {
        { name = 'Archon Vail', resources = 1, influence = 3, trait = 'hazardous', tech = 'blue' },
    }},
    ['0a93a9'] = { source = "POK", tile = 60, planets = {
        { name = 'Perimeter', resources = 2, influence = 1, trait = 'industrial' },
    }},
    ['780b2f'] = { source = "POK", tile = 61, planets = {
        { name = 'Ang', resources = 2, influence = 0, trait = 'industrial', tech = 'red' },
    }},
    ['4c1e0a'] = { source = "POK", tile = 62, planets = {
        { name = 'Sem-Lore', resources = 3, influence = 2, trait = 'cultural', tech = 'yellow' },
    }},
    ['8064e3'] = { source = "POK", tile = 63, planets = {
        { name = 'Vorhal', resources = 0, influence = 2, trait = 'cultural', tech = 'green' },
    }},
    ['a28bb1'] = { source = "POK", tile = 64, wormholes = { 'beta' }, planets = {
        { name = 'Atlas', resources = 3, influence = 1, trait = 'hazardous', },
    }},
    ['b642cd'] = { source = "POK", tile = 65, planets = {
        { name = 'Primor', resources = 2, influence = 1, trait = 'cultural', radius = 1.5,
         legendary = true, legendaryCard = 'The Atrament' },
    }},
    ['1154bc'] = { source = "POK", tile = 66, planets = {
        { name = "Hope's End", resources = 3, influence = 0, trait = 'hazardous', radius = 1.5,
        legendary = true, legendaryCard = 'Imperial Arms Vault' },
    }},
    ['834e88'] = { source = "POK", tile = 67, anomalies = { 'gravity rift' }, planets = {
        { name = 'Cormund', resources = 2, influence = 0, trait = 'hazardous', position = { x = 0.45, z = -0.25 } },
    }},
    ['8bc917'] = { source = "POK", tile = 68, anomalies = { 'nebula' }, planets = {
        { name = 'Everra', resources = 3, influence = 1, trait = 'cultural', position = { x = 0.45, z = -0.25 } },
    }},
    ['40bc9e'] = { source = "POK", tile = 69, planets = {
        { name = 'Accoen', resources = 2, influence = 3, trait = 'industrial' },
        { name = 'Jeol Ir', resources = 2, influence = 3, trait = 'industrial' },
    }},
    ['0fb4f5'] = { source = "POK", tile = 70, planets = {
        { name = 'Kraag', resources = 2, influence = 1, trait = 'hazardous' },
        { name = 'Siig', resources = 0, influence = 2, trait = 'hazardous' },
    }},
    ['14a065'] = { source = "POK", tile = 71, planets = {
        { name = "Ba'kal", resources = 3, influence = 2, trait = 'industrial' },
        { name = 'Alio Prima', resources = 1, influence = 1, trait = 'cultural' }
    }},
    ['c8d135'] = { source = "POK", tile = 72, planets = {
        { name = 'Lisis', resources = 2, influence = 2, trait = 'industrial' },
        { name = 'Velnor', resources = 2, influence = 1, trait = 'industrial', tech = 'red' },
    }},
    ['a931d3'] = { source = "POK", tile = 73, planets = {
        { name = 'Cealdri', resources = 0, influence = 2, trait = 'cultural', tech = 'yellow' },
        { name = 'Xanhact', resources = 0, influence = 1, trait = 'hazardous' }
    }},
    ['c763de'] = { source = "POK", tile = 74, planets = {
        { name = 'Vega Major', resources = 2, influence = 1, trait = 'cultural' },
        { name = 'Vega Minor', resources = 1, influence = 2, trait = 'cultural', tech = 'blue' },
    }},
    ['9c6682'] = { source = "POK", tile = 75, planets = {
        { name = 'Loki', resources = 1, influence = 2, trait = 'cultural' },
        { name = 'Abaddon', resources = 1, influence = 0, trait = 'cultural' },
        { name = 'Ashtroth', resources = 2, influence = 0, trait = 'hazardous' },
    }},
    ['9a3731'] = { source = "POK", tile = 76, planets = {
        { name = 'Rigel III', resources = 1, influence = 1, trait = 'industrial', tech = 'green' },
        { name = 'Rigel II', resources = 1, influence = 2, trait = 'industrial' },
        { name = 'Rigel I', resources = 0, influence = 1, trait = 'hazardous' },
    }},
    ['75bd47'] = { source = "POK", tile = 77 },
    ['b8dff6'] = { source = "POK", tile = 78 },
    ['1a6583'] = { source = "POK", tile = 79, anomalies = { 'asteroid field' }, wormholes = { 'alpha' } },
    ['015a9f'] = { source = "POK", tile = 80, anomalies = { 'supernova' } },
    ['33c12d'] = { source = "POK", tile = 81, anomalies = { 'supernova' }, faction = 'muaat' },
    ['82bf35'] = { source = "POK", tile = 82,
        wormholes_faceUp = { 'gamma', 'alpha', 'beta' },
        wormholes_faceDown = { 'gamma' },
        offMap = true, planets = {
            {
                name = 'Mallice', resources = 0, influence = 3,
                legendary = true, legendaryCard = 'Exterrix Headquarters', trait = 'cultural',
                position = { x = -0.45, z = -0.47 }, radius = 0.8, -- position is face up
            }
        }
    },

    -- Hyperlane tiles
    -- hyperlanes is an array of 6 indices, representing hyperlane connexion. Indices are zero-based (0 to 5)
    -- Using _fillMissingSystemData to automatically fill 'hyperlanes' with the right data depending if the tile is flipped or not
    -- 0 is top right side, when the tile is rotated at -180° on Y axis (Y rotation of zero)
    ['81a64a'] = { tile = 83, hyperlane = true,
        hyperlanes_faceUp = { {3}, {}, {}, {0}, {}, {} },
        hyperlanes_faceDown = { {}, {5}, {4,5}, {}, {2}, {1,2} }
    },
    ['bed0e0'] = { tile = 84, hyperlane = true,
        hyperlanes_faceUp = { {}, {4}, {}, {}, {1}, {} },
        hyperlanes_faceDown = { {2}, {}, {0,5}, {5}, {}, {2,3} }
    },
    ['a64a36'] = { tile = 85, hyperlane = true,
        hyperlanes_faceUp = { {}, {3}, {}, {1}, {}, {} },
        hyperlanes_faceDown = { {}, {5}, {4,5}, {}, {2}, {1,2} }
    },
    ['b34afa'] = { tile = 86, hyperlane = true,
        hyperlanes_faceUp = { {}, {3}, {}, {1}, {}, {} },
        hyperlanes_faceDown = { {2}, {}, {0,5}, {5}, {}, {2,3} }
    },
    ['3ccc62'] = { tile = 87, hyperlane = true,
        hyperlanes_faceUp = { {4}, {4}, {4}, {}, {0,1,2}, {} },
        hyperlanes_faceDown = { {}, {}, {4,5}, {}, {2}, {2} }
    },
    ['ee4bf1'] = { tile = 88, hyperlane = true,
        hyperlanes_faceUp = { {2,3,4}, {}, {0}, {0}, {0}, {} },
        hyperlanes_faceDown = { {}, {5}, {4,5}, {}, {2}, {1,2} }
    },
    ['33e49a'] = { tile = 89, hyperlane = true,
        hyperlanes_faceUp = { {2,4}, {}, {0,4}, {}, {0,2}, {} },
        hyperlanes_faceDown = { {2}, {}, {0,5}, {}, {}, {2} }
    },
    ['7e7ee1'] = { tile = 90, hyperlane = true,
        hyperlanes_faceUp = { {4}, {3}, {}, {1}, {0}, {} },
        hyperlanes_faceDown = { {2}, {}, {0,5}, {}, {}, {2} }
    },
    ['565980'] = { tile = 91, hyperlane = true,
        hyperlanes_faceUp = { {2}, {}, {0,5}, {5}, {}, {2,3} },
        hyperlanes_faceDown = { {}, {}, {4,5}, {}, {2}, {2} }
    },

    -- Keleres
    ['d05172'] = { tile = 202, home = true, planets = {
        { name = 'Moll Primus', resources = 4, influence = 1 },
    }},
    ['feae10'] = { tile = 214, home = true, planets = {
        { name = 'Archon Ren', resources = 2, influence = 3 },
        { name = 'Archon Tau', resources = 1, influence = 1 },
    }},
    ['badf4c'] = { tile = 258, home = true, planets = {
        { name = 'Valk', resources = 2, influence = 0 },
        { name = 'Ylir', resources = 0, influence = 2 },
        { name = 'Avar', resources = 1, influence = 1 },
    }},


    -- Phil's warp zones.
    ['3830ca'] = { tile = 1001, hyperlane = true }, -- A
    ['5dbaf9'] = { tile = 1002, hyperlane = true }, -- A
    ['e604ce'] = { tile = 1003, hyperlane = true }, -- B
    ['902424'] = { tile = 1004, hyperlane = true }, -- B
    ['903187'] = { tile = 1005, hyperlane = true }, -- G
    ['507cb6'] = { tile = 1006, hyperlane = true }, -- G
    ['35b72d'] = { tile = 1007, hyperlane = true, hyperlanes = {
        {3}, {}, {}, {0}, {}, {}
    } },
    ['b41a78'] = { tile = 1008, hyperlane = true, hyperlanes = {
        {2}, {}, {0}, {}, {}, {}
    } },
    ['1000e9'] = { tile = 1009, hyperlane = true, hyperlanes = {
        {2,4}, {}, {0,4}, {}, {0,2}, {}
    } },
    ['9a71c7'] = { tile = 1010, hyperlane = true, hyperlanes = {
        {2}, {}, {0,5}, {5}, {}, {2,3}
    } },
    ['204530'] = { tile = 1011, hyperlane = true, hyperlanes = {
        {2,3}, {}, {0}, {0,5}, {}, {3}
    } },
    ['b74682'] = { tile = 1012, hyperlane = true, hyperlanes = {
        {2}, {}, {0}, {}, {}, {}
    } },
    ['1ffd34'] = { tile = 1013, hyperlane = true, hyperlanes = {
        {3}, {3}, {}, {0,1,5}, {}, {3}
    } },
    ['bdf753'] = { tile = 1014, hyperlane = true, hyperlanes = {
        {2,4}, {}, {0,4}, {}, {0,2}, {}
    } },
    ['a35ea3'] = { tile = 1015, hyperlane = true, hyperlanes = {
        {2}, {}, {0}, {}, {}, {}
    } },
    ['613593'] = { tile = 1016, hyperlane = true, hyperlanes = {
        {3}, {}, {}, {0}, {}, {}
    } },
    ['2c5e05'] = { tile = 1017, hyperlane = true, hyperlanes = {
        {2}, {}, {0}, {5}, {}, {3}
    } },
    ['c131ce'] = { tile = 1018, hyperlane = true, hyperlanes = {
        {3}, {}, {}, {0}, {}, {}
    } },
    ['bb11c7'] = { tile = 1019, hyperlane = true, hyperlanes = {
        {3}, {3}, {}, {0,1,5}, {}, {3}
    } },
    ['34cbfd'] = { tile = 1020, hyperlane = true, hyperlanes = {
        {2}, {}, {0}, {5}, {}, {3}
    } },

    -- Pick-A-Planet systems.
    ['0dcdee'] = { tile = 2001, planets = {{ name = 'A' }} },
    ['c68187'] = { tile = 2002, planets = {{ name = 'A' }} },
    ['3c3949'] = { tile = 2003, planets = {{ name = 'A' }} },
    ['8e69fb'] = { tile = 2004, planets = {{ name = 'A' }} },
    ['75d1cd'] = { tile = 2005, planets = {{ name = 'A' }} },
    ['ea61c5'] = { tile = 2006, planets = {{ name = 'A' }} },
    ['8518e6'] = { tile = 2007, planets = {{ name = 'A' }} },
    ['eda114'] = { tile = 2008, planets = {{ name = 'A' }} },
    ['1300b8'] = { tile = 2009, planets = {{ name = 'A' }} },
    ['fd8349'] = { tile = 2010, planets = {{ name = 'A' }} },
    ['941405'] = { tile = 2011, planets = {{ name = 'A' }} },
    ['ef89f5'] = { tile = 2012, planets = {{ name = 'A' }} },
    ['eb1837'] = { tile = 2013, planets = {{ name = 'A' }} },
    ['8e7edf'] = { tile = 2014, planets = {{ name = 'A' }} },
    ['ffb0d9'] = { tile = 2015, planets = {{ name = 'A' }} },
    ['26820b'] = { tile = 2016, planets = {{ name = 'A' }} },
    ['9b66db'] = { tile = 2017, planets = {{ name = 'A' }} },
    ['943567'] = { tile = 2018, planets = {{ name = 'A' }} },
    ['ea6aa3'] = { tile = 2019, planets = {{ name = 'A' }, { name = 'B' }} },
    ['b81d49'] = { tile = 2020, planets = {{ name = 'A' }, { name = 'B' }} },
    ['042a91'] = { tile = 2021, planets = {{ name = 'A' }, { name = 'B' }} },
    ['3d388c'] = { tile = 2022, planets = {{ name = 'A' }, { name = 'B' }} },
    ['652379'] = { tile = 2023, planets = {{ name = 'A' }, { name = 'B' }} },
    ['636039'] = { tile = 2024, planets = {{ name = 'A' }, { name = 'B' }} },
    ['26d4e0'] = { tile = 2025, planets = {{ name = 'A' }, { name = 'B' }} },
    ['78011d'] = { tile = 2026, planets = {{ name = 'A' }, { name = 'B' }} },
    ['862968'] = { tile = 2027, planets = {{ name = 'A' }, { name = 'B' }} },
    ['a4a6bb'] = { tile = 2028, planets = {{ name = 'A' }, { name = 'B' }} },
    ['7679a9'] = { tile = 2029, planets = {{ name = 'A' }, { name = 'B' }} },
    ['ce4179'] = { tile = 2030, planets = {{ name = 'A' }, { name = 'B' }} },
    ['8ef29f'] = { tile = 2031, planets = {{ name = 'A' }, { name = 'B' }} },
    ['cfd3f1'] = { tile = 2032, planets = {{ name = 'A' }, { name = 'B' }} },
    ['cae6b7'] = { tile = 2033, planets = {{ name = 'A' }, { name = 'B' }} },
    ['ca6044'] = { tile = 2034, planets = {{ name = 'A' }, { name = 'B' }} },
    ['517d73'] = { tile = 2035, planets = {{ name = 'A' }, { name = 'B' }} },
    ['8c22eb'] = { tile = 2036, planets = {{ name = 'A' }, { name = 'B' }} },
}

local _wormholeTypes = {
  ["alpha"] = "Orange", ["beta"] = "Green", ["delta"] = "Blue", ["gamma"] = "Pink"
}
local _connectionsThisFrame = false
local CONNECTIONS = { _activeConnections = {}, _systemConectivity = {}}

local connectionRules = {
  ['wormholes'] = {
    id = "wormholes",
    sources = { targetType = "ALL", isUniversalRule = true},
    connectionType = {{ name = "alpha"}, {name = "beta"}, {name = "delta"}, {name = "gamma"}},
    connectionObjects = {
      {--alpha wormholes
        names = {"Alpha Wormhole Token"},
        advancedSearch = {
          FIND = {obj = self, func = "getPrintedWormholeSystems_inPlay", params = {type = "alpha"}}
        },
        connectsTo = "alpha"
      },
      {--beta wormholes
        names = {"Beta Wormhole Token"},
        advancedSearch = {
          FIND = {obj = self, func = "getPrintedWormholeSystems_inPlay", params = {type = "beta"}}
        },
        connectsTo = "beta"
      },
      {--gamma wormholes
        names = {"Gamma Wormhole Token"},
        advancedSearch = {
          FIND = {obj = self, func = "getPrintedWormholeSystems_inPlay", params = {type = "gamma"}}
        },
        connectsTo = "gamma"
      },
      {--delta wormholes
        names = {"Hil Colish"},
        advancedSearch = {
          FIND = {obj = self, func = "getPrintedWormholeSystems_inPlay", params = {type = "delta"}}
        },
        connectsTo = "delta"
      },
    }
  },
  ['alpha-beta link'] = {
    id = 'alpha-beta link',
    sources = {
      {
        targetType = "OWNER",
        refs = { FACTION_ABILITIES = {"Quantum Entanglement"}}
      },
      {
        targetType = "ALL",
        refs = {OBJECTS = {
          {name = "Wormhole Reconstruction", isDiscardable = true, requireFaceup = true},
          {name = "Lost Star Chart", isDiscardable = true, requireFaceup = true}
        }}
      }
    },
    connectionMutators = {
      targetConnections = {"alpha", "beta"},
      mutate = {obj = self, func = "_linkConnectionToWormholes", params = {linkTo = {"alpha", "beta"}}}
    }
  },
  ["ion storm"] = {
    id = "ion strom",
    sources = {targetType = "ALL", refs = {OBJECTS = {"Ion Storm Token"}}},
    connectionObjects = {
      names = {"Ion Storm Token"},
      connectsTo = "GET",
      getConnections = {obj = self, func = "getIonStormWormhole"}
    }
  },
  ["link all wormholes"] = {
    id = "link all wormholes",
    sources = {
      targetType = "ALL",
      refs = { OBJECTS = {{name = "Emissary Taivra", requireFaceup = true, requireActive = "true"}}}
    },
    connectionMutators = {
      targetConnections = "GET",
      getTargetConnections = {obj = self, func = "getWormholeTypes"},
      mutate = {obj = self, func = "_linkToOtherWormholes"},
      --params = {color = ""color mutator is applying to, connectsTo = {}table of connectedTo for each target}
      --return new connectedTo table {["alpha"] = true,...}indexed by value
      --mutate is called sequentialy, once for each target
    }
  },
  ["lazax gate folding"] = {
    id = "lazax gate folding",
    sources = {
      targetType = "ALL",
      refs = {OBJECTS = {"Lazax Gate Folding"}}
    },
    connectionObjects = {
      advancedSearch = {
        FIND = {obj = self, func = "getLazaxGateFolding"} --finds mecatol rex if LGF requirements are fulfilled
      },
      connectsTo = {"alpha", "beta"}
    }
  },
}

local _nonPlanetResourceInfluenceCards = {
    -- Keep base game agendas here?  Are they gone?  XXX TODO

    { name = 'Core Mining', resources = 2, influence = 0 },
    { name = 'Senate Sanctuary', resources = 0, influence = 2 },
    { name = 'Terraforming Initiative', resources = 1, influence = 1 },

    { name = 'Custodia Vigilia', resources = 2, influence = 3 },

    -- Attachment tokens are the new way to do things.
    -- { name = 'Rich World', resources = 1, influence = 0 },
    -- { name = 'Mining World', resources = 2, influence = 0 },
    -- { name = 'Lazax Survivors', resources = 1, influence = 2 },
    -- { name = 'Tomb of Emphidia', resources = 0, influence = 1 },
    -- { name = 'Paradise World', resources = 0, influence = 2 },
    -- { name = 'Dyson Sphere', resources = 2, influence = 1 },
    -- { name = 'Biotic Research Facility', resources = 1, influence = 1 },
    -- { name = 'Cybernetic Research Facility', resources = 1, influence = 1 },
    -- { name = 'Warfare Research Facility', resources = 1, influence = 1 },
    -- { name = 'Propulsion Research Facility', resources = 1, influence = 1 },
    -- { name = 'Terraform', resources = 1, influence = 1 },
    -- { name = 'Ul the Progenitor', resources = 3, influence = 3, requireFaceUp = true },

    -- Technology
    -- Predictive Intelligence: Increase minimum available votes by 3.
    -- ... but for each vote, see Zeal comment below why this is problematic.
    -- Comment out for now, reintroduce once there's a better way to do these.
    --{ name = 'Predictive Intelligence', resources = 0, influence = 3, requireFaceUp = true },
}

local TYPE = {
    MUTATE = 'mutate', -- adds or removes attribute(s), do first.
    ADJUST = 'adjust',  -- adjusts existing attribute(s).
    CHOOSE = 'choose',  -- picks from available unit(s), do after all others.
}

local LEADER = {
    AGENT = 'agent',
    COMMANDER = 'commander',
    HERO = 'hero'
}

--{["pName"] = resources = {obj = self, func = "getRes"}, influence = {obj = self, func = "getInf"}}
local _dynamicPlanetValues = {}
local _resInfModifiers = {
    ['Elder Qanoj'] = {
        description = 'Each planet you exhaust to cast votes provides 1 additional vote',
        type = TYPE.ADJUST,
        leader = LEADER.COMMANDER, -- Xxcha
        apply = function(resInfCards)
            local planetNameSet = {}
            for _, system in pairs(_systems) do
                for _, planet in ipairs(system.planets or {}) do
                    planetNameSet[planet.name] = true
                end
            end
            for _, resInfCard in ipairs(resInfCards) do
                if planetNameSet[resInfCard.name] then
                    -- Technically this adds a *vote* and not influence.
                    resInfCard.influence = resInfCard.influence + 1
                end
            end
        end
    },

    ['Xxekir Grom Ω'] = {
        description = 'When you exhaust planets, combine the value of their resources and influence. Treat the combined value as if it were both resources and influence.',
        type = TYPE.ADJUST,
        leader = LEADER.HERO, -- Xxchaa
        apply = function(resInfCards)
            local planetNameSet = {}
            for _, system in pairs(_systems) do
                for _, planet in ipairs(system.planets or {}) do
                    planetNameSet[planet.name] = true
                end
            end
            for _, resInfCard in ipairs(resInfCards) do
                if planetNameSet[resInfCard.name] then
                    resInfCard.influence = resInfCard.influence + resInfCard.resources
                end
            end
        end
    },

    -- This modifier isn't quite right, get N votes for EACH time voting.
    -- Comment this out for now (players can manage) until figuring a better way.
    -- ['Zeal'] = {
    --     description = 'When you cast at least 1 vote, cast 1 additional vote for each player in the game, including you',
    --     type = TYPE.CHOOSE,
    --     apply = function(resInfCards)
    --         -- Only applies if votes would otherwise be >0
    --         local votesAvailable = false
    --         for _, resInfCard in ipairs(resInfCards) do
    --             votesAvailable = votesAvailable or (resInfCard.influence > 0)
    --         end
    --
    --         if votesAvailable then
    --             local seatedPlayerZones = _zoneHelper.zones()
    --
    --             table.insert( resInfCards, { name = 'Zeal', resources = 0, influence = #seatedPlayerZones } )
    --         end
    --     end
    -- },
}

local LOCAL_DISTANCE_TO_PLANET = 1.1
local LOCAL_PLANET_RADIUS = 0.8
local LOCAL_SYSTEM_TILE_RADIUS = 2.26
local LOCAL_SYSTEM_TILE_Y = 0.094 -- mesh Y is -0.1062 to 0.0937

--Public Getters----------------------------------------------------------------

--- Get all systems.
-- @return table: map from tile GUID to system table.
function systems()
    for guid, system in pairs(_systems) do
        _fillMissingSystemData(guid, system)
    end
    return _systems
end

--- Get all planets.
-- @return table: map from LOWERCASE planet name to planet table.
function planets()
    local result = {}
    for _, system in pairs(_systems) do
        _updateVariablePlanetValues(system)
        for _, planet in ipairs(system.planets or {}) do
            result[string.lower(planet.name)] = planet
        end
    end
    return result
end

--- Get system at position.
-- @param postition (table): {xyz} position.
-- @return system table.
function systemFromPosition(position)
    assert(type(position) == 'table' and type(position.x) == 'number')
    -- Ray cast not always reliable, use box.
    local hits = Physics.cast({
        origin = { x = position.x, y = position.y, z = position.z },
        direction = { x = 0, y = -1, z = 0 },
        type = 3, -- box
        size = { 0.1, 10, 0.1 }
    })
    for _, hit in ipairs(hits) do
        local guid = hit.hit_object.getGUID()
        local system = systemFromGuid(guid)
        if system then
            return system
        end
    end
end

-- Get systems at positions. Does NOT use ray-casting like "systemFromPosition".
-- @param Map of arbitrary key to {xyz} position
-- @return Map of same arbitrary key to system attributes or false
function systemsFromPositions(keysToPositions)
    assert(type(keysToPositions) == 'table')

    -- Fill in extra system data
    local systems = systems()

    -- Get position of each system
    local systemGuidToPosition = {}
    for _, object in ipairs(getAllObjects()) do
        local guid = object.getGUID()
        if systems[guid] then
            systemGuidToPosition[guid] = object.getPosition()
        end
    end

    -- Get hex of each system
    local systemGuidToHexes = hexesFromPositions(systemGuidToPosition)
    -- Build reverse map (of system GUID to hex)
    local systemHexToGuid = {}
    for systemGuid, hex in pairs(systemGuidToHexes) do
        if hex then
            -- Warn (without failing) when a system already occupies this hex position (meaning the tiles are overlapping).
            if systemHexToGuid[hex] then
                print('WARNING: System tiles are overlapping at hex coordinate ' .. hex .. ' (' .. _systems[systemGuid].string .. ' and ' .. _systems[systemHexToGuid[hex]].string .. '). Some functions may be affected.')
            else
                systemHexToGuid[hex] = systemGuid
            end
        end
    end

    -- Get hex of each input key
    local inputKeyToHexes = hexesFromPositions(keysToPositions)

    -- Get system for each input key, using hex coordinate maps as a bridge
    local keysToSystems = {}
    for inputKey, hex in pairs(inputKeyToHexes) do
        local systemGuid = systemHexToGuid[hex]

        if systemGuid then
            keysToSystems[inputKey] = assert(systems[systemGuid])
        else
            keysToSystems[inputKey] = false
        end
    end

    return keysToSystems
end

--- Get system with the given tile number.
-- @param tile (number).
-- @return system table.
function systemFromTile(tile)
    for guid, system in pairs(_systems) do
        if system.tile == tile then
            _fillMissingSystemData(guid, system)
            return system
        end
    end
end

--- Get system from tile guid.
-- @param guid (string): system tile guid.
-- @return system table.
function systemFromGuid(guid)
    local system = _systems[guid]
    if system then
        _fillMissingSystemData(guid, system)
        return system
    end
end

--- Get planet at position.
-- Normally finds the closest planet after carving the system tile into zones,
-- optionally require position to be inside planet radius (via params.exact).
-- @params table: { systemGuid, position{xyz}, exact boolean }
-- @return planet table.
function planetFromPosition(params)
    assert(type(params) == 'table')
    local systemGuid = assert(params.systemGuid)
    local position = assert(params.position)
    local exact = params.exact
    assert(type(systemGuid) == 'string')
    assert(type(position) == 'table' and type(position.x) == 'number')
    local system = systemFromGuid(systemGuid)
    local best = false
    if system then
        local object = getObjectFromGUID(system.guid)
        local p1 = object.positionToLocal(position)
        local bestDistanceSq = false
        for _, planet in ipairs(system.planets or {}) do
            local p2 = assert(planet.position)
            local distanceSq = (p1.x - p2.x) ^ 2 + (p1.z - p2.z) ^ 2
            if not bestDistanceSq or distanceSq < bestDistanceSq then
                best = planet
                bestDistanceSq = distanceSq
            end
        end
        if best and exact and math.sqrt(bestDistanceSq) > best.radius then
            best = false
        end
    end
    return best
end

--- Get map from wormhole type to object guids.
-- @param playerColor (string) : player color or nil
--refactord to support injected wormholes
function wormholes(playerColor)
  local result = {
    --[[format:
    ["alpha"] = {
    guids = {g1,g2...},
    connected = {"alpha",...}
  }--]]
  }
  CONNECTIONS.build()
  for eachWormhole,_ in pairs(_wormholeTypes) do
    result[eachWormhole] = {
      guids = {},
      connected = {}
    }

    local systems = _getSystemsConnectedTo(eachWormhole, playerColor)
    --convert hash to list
    for eachSystem,_ in pairs(systems or {}) do
      table.insert(result[eachWormhole].guids, eachSystem)
    end
    if CONNECTIONS._activeConnections[playerColor] and CONNECTIONS._activeConnections[playerColor].connections and CONNECTIONS._activeConnections[playerColor].connections[eachWormhole] then
      local connections = CONNECTIONS._activeConnections[playerColor].connections[eachWormhole].connectsTo
      --convert hash to list
      for eachConnection,_ in pairs(connections or {}) do
        table.insert(result[eachWormhole].connected, eachConnection)
      end
    end
  end

  return result
end

--wormhole types are injectable
function getWormholeTypes()
  return _wormholeTypes
end

--gets all adjacent systems after all modifers/rules are applied.
  --checks physical neighbors, hyperlane neighbors, and connections through wormholes and other injected connections
--return: table of adjacent system guids with hex locations: {["guid1"] = {hex = "hexPosition", system = systemTable}, ["g2"] =...}
--params: {
  --color = "playerColor",--players (like ghosts) may have different system adjacency --*optional defaults to Turns.turn_color
  --system = "systemGUID" *optional:defaults to active system,
  --highlight = bool or # *optional:defaults to no highlight. true = permanent highlight, # = duration. Highlights all adjacent systems
--}
function getAdjacentSystems(params)
  assert(params and type(params) == "table")
  assert(params.system == nil or type(params.system) == "string")
  assert(params.color == nil or (params.color and type(params.color) == "string"))
  local color = assert(params.color or (Turns.enable and Turns.turn_color) or false, "Could not determine a color.")
  local system = params.system or (getActivatedSystem() and getActivatedSystem().guid) or false
  assert(system, "Could not determine active system.")

  return _getAdjacentSystems(system, params.color, params.highlight)
end

--ONLY finds systems connected by a "connection" (wormhole or injected connection). Does not return all adjacent systems
--target can be a system guid or a type of connection such as "alpha"
--return: table of guids indexed by value {["guid"] = true, ["g2"] = true,...}
function getSystemsConnectedTo(params)
  return _getSystemsConnectedTo(params.target, params.color)
end

--params: *optional, specify a type of wormhole {type = ""}
--returns: [wormhole] = {guid1,...} table containing each wormhole or only the specified wormhole type
function getPrintedWormholeSystems(params)
  local type = params and type(params) == "table" and params.type or nil
  return CONNECTIONS.getPrintedWormholeSystems(type)
end

--returns table of objRefs
function getPrintedWormholeSystems_inPlay(params)
  local type = params and type(params) == "table" and params.type or nil
  local systems = CONNECTIONS.getPrintedWormholeSystems() or {}
  local result = {}
  if type then
    for _,eachGUID in ipairs(systems[type] or {}) do
      local obj = getObjectFromGUID(eachGUID)
      if obj ~= nil  then
        table.insert(result, obj)
      end
    end
  else
    for eachType,data in pairs(systems) do
      for _,eachGUID in ipairs(data) do
        local obj = getObjectFromGUID(eachGUID)
        if obj ~= nil  then
          table.insert(result, obj)
        end
      end
    end
  end
  return result
end

--when you call getAdjacentSystems, you can optionally highlight all the adjacent systems. This function removes those highlights
function removeSystemHighlights()
  _removeSystemHighlights()
end

--expose the ability to activate a system to other scripts
--params: {system = "GUID" of system tile, color = new active player *optional, defaults to current turn color}
function activateSystem(params)
  params = params or {}
  assert(params.system and type(params.system) == "string")
  local system = _systems[params.system]
  if not system then return end
  local color = params.color or (Turns.enable and Turns.turn_color)
  if not color then return end

  _activateSystem(color, system)
end

--Injection----------------------------------------------------------------------

--[[System table attributes:
local systemFormat = {
  source = "stringName", --identrfy where this system came from
  tile = #number,--decimals accepted. For large sets, consider choosing a prefix number, then increment from it: 8000.00, 8000.01, 8000.02 ...
  home = true,--this is a home system
  faction = nil, -- or "nameOfFactionOrAbility", --links the system to a faction or abiltiy. It will not be draftable (Muaat supernova, etc.)
  anomalies = nil, --{"asteroid field", "nebula", "supernova", "gravity rift"},
  wormholes = nil, --{"alpha", "beta", "delta", "gamma"},
    --wormholes_faceUp = {}, if your system is like Mallice, remove the wormholes field and replace it with these
    --wormholes_faceDown = {},
  offMap = nil, --true, --for spiral hexes. if true not part of the system map (e.g. do not count for slice r/i).

  --uncommon overrides
  --rotate = #, --degrees, number
  --localY = #, --override tile height (ghosts home system) --see LOCAL_SYSTEM_TILE_Y

  --hyperlane = nil, --true,
    -- Hyperlane tiles
    -- hyperlanes is an array of 6 indices, representing hyperlane connexion. Indices are zero-based (0 to 5)
    -- 0 is top right side, when the tile is rotated at -180° on Y axis (Y rotation of zero)
  --hyperlanes = {{},{},{},{},{},{}},--connection matrix: Each inner table reperesents a side.
      --For each side, list each other side that is connected (0 indexed: {0} --> connects to the first {}side)
      --{{2}, {}, {0}, {5}, {}, {3}} Example table:
      --{S0,  S1, S2,  S3,  S4,  S5} S0 ({2}) says it connects to S2| S3 {5} connects to S5{3}. Each inner table can have multiple #s: {5,3,2}
    --hyperlanes_faceUp/hyperlanes_faceDown also available for double-sided tiles

  --internal vars
  -- - guid: tile GUID.
  -- - string = _systemToString(system)
  -- - y = localY or LOCAL_SYSTEM_TILE_Y,
  -- - zoneEdgePositions: local edge positions carving per-planet zones.
  -- - planets[].position: local {xyz} position.
  -- - planets[].radius: local space.

  planets = nil,--{}, --list of planetTables
}--]]

--[[Planet table attributes:
local planetTable = {
  name = "string",
  resources = #, or table for dynamic values{obj = self, func = "getResources", default = #},--params: {planet = "name", resources = true} --return #
  influence = #, or table for dynamic values{obj = self, func = "getInfluence", default = #},--params: {planet = "name", influence = true} --return #
  trait = "", --string: "cultural",|"industrial",|"hazardous", --multi-trait planets not supported (queue sad titan noise)
  tech = "", --string "red",|"green",|"yellow",|"blue",
  legendary = false, --true,
  legendaryCard = nil, --"cardName"

  ----uncommon overrides
  --position = {x,z}, --local space
  --radius = #, --local space
}
--]]
-- @param system: system table.
function injectSystem(system)
    assert(type(system) == 'table')

    -- Unclear if the systems are shared with the caller, make a copy to be
    -- sure any later mutations to the caller's version does not change this.
    system = copyTable(system)

    local guid = system.guid
    if not guid or type(guid) ~= 'string' then
        error('injectSystem: missing guid')
    end
    local success, errorMessage = _systemIsValid(system)
    if not success then
        error('injectSystem: ' .. guid .. ' ' .. errorMessage)
    end
    system.guid = nil  -- force rebuild of any auto-generated fields
    system._homebrew = true
    system.source = system.source or "unsourcedHomebrew"
    --find any planets with dynamic res/inf
    for _,eachPlanet in ipairs(system.planets or {}) do
      if type(eachPlanet.resources) == "table" then
        assert(type(eachPlanet.resources.func) == "string")
        _dynamicPlanetValues[eachPlanet.name] = _dynamicPlanetValues[eachPlanet.name] or {}
        _dynamicPlanetValues[eachPlanet.name].resources = {callData = copyTable(eachPlanet.resources), lastResult = 0}
        eachPlanet.resources = eachPlanet.resources or 0
      end
      if type(eachPlanet.influence) == "table" then
        assert(type(eachPlanet.influence.func) == "string")
        _dynamicPlanetValues[eachPlanet.name] = _dynamicPlanetValues[eachPlanet.name] or {}
        _dynamicPlanetValues[eachPlanet.name].influence = {callData = copyTable(eachPlanet.influence), lastResult = 0}
        eachPlanet.influence = eachPlanet.influence.default or 0
      end
    end

    local isOverride = _systems[guid] and true or false
    _systems[guid] = system
    _fillMissingSystemData(guid, system)
    _batchPrintInjectionResult("System", guid, isOverride)
end

function injectResourceInfluenceModifier(params)
    assert(type(params.name) == 'string', 'bad name')
    assert((not params.resource) or type(params.resource) == 'number', 'bad resource')
    assert((not params.influence) or type(params.influence) == 'number', 'bad influence')
    for i, entry in ipairs(_nonPlanetResourceInfluenceCards) do
        if entry.name == params.name then
            _nonPlanetResourceInfluenceCards[i] = params
            _batchPrintInjectionResult("Res/Inf_Modifier", params.name, true)
            return
        end
    end
    table.insert(_nonPlanetResourceInfluenceCards, params)
    _batchPrintInjectionResult("Res/Inf_Modifier", params.name)
end

--[[create a new type of wormhole!
  --injection will generate the wormhole's connectionRule and adds support for a Wormhole Token
  params: "stringName" or table:{
    name = "string",*the only required field. All lower case
    color = "", *Optional, defaults to "Teal". What color represents this wormhole
    additionalConnections =  "string"|{table of strings}, --by default the wormhole connects only to itself, you may add other connection types {"alpha", "beta"...}
  }--]]
function injectWormhole(params)
  params = params or {}
  local name = type(params) == "string" and params or assert(params.name)
  _wormholeTypes[name] = params.color or "Teal"

  --prep fields
  local capsName = name:gsub("^%l", string.upper)
  local addC = type(params) == "table" and params.additionalConnections or {}
  local connections = type(addC) == "table" and addC or {addC}
  table.insert(connections, name)
  --create connection
  local wormholeConnection = {
    names = {capsName.." Wormhole Token"},
    advancedSearch = {
      FIND = {obj = self, func = "getPrintedWormholeSystems_inPlay", params = {type = name}}
    },
    connectsTo = connections
  }
  table.insert(connectionRules["wormholes"].connectionObjects, wormholeConnection)
  table.insert(connectionRules["wormholes"].connectionType, {name = name})

  _batchPrintInjectionResult("Wormhole", name)
end

--[[Rule format:
local connectionRule = {
  id = "", --give this rule a unique id
  --Sources determine when this rule is in play and who it effects
  sources = {--single table, or table of sourceTables: rules can have multiple types of sources, each with multiple references
    {--sourceTable
      isUniversalRule = false, --Is this rule allways in play?
      --if not universal, refs are how we determine if this source is active/in play
      refs = { --You may ommit any of these subTables
        FACTION_ABILITIES = {"abilityName_1",...},
        OBJECTS = {"stringName", objectTable}, --Look for objects that may enable this rule
         --mixed table of stings/objectTables. objectTables allow additional settings
         --objectTable =
         {
          --*How to find this object(include only 1)
          *name = "",
          *guid = "",

          requireFaceup = false,
          requireActive = false, --Will create a toggle Active button on the object
          isDiscardable = false, --set to true to prevent this object from being found in it's discard pile
        },
        GET = {obj = self, func = "isConnectionRuleActive"}, --function should return true if this source is active/in play
      }

      --If this source is active/in play, who will it effect?
      targetType = "OWNER"|"OTHERS"|"ALL"|"GET" --"OTHERS" == NOT OWNER
      --If target is "GET", you must include getTarget
      --getTarget = {obj = self, func = "myTargetFuncName"}, --function should return a color or table of colors to target

      --*internal values
      --isActive = bool,
      --_activeObjects = {objRef},--objects from refs that have been found (and are faceup/active if required)
      --_activeAbilityOwners = {[color] = true}, --color indexed list of colors whose factions have an ability found in refs.FACTION_ABILITIES
  }},
  --*internal vars
  --_activeTargets = false, --or {[color] = true} table of color targets, no douplicates

  --Each of the below tables are optional

  --Create a new type of connection (or a table of connections)
  connectionType = {
    name = "",--unique name for the connection type
    connectsTo = {"name", "alpha"},--*optional; if not included, it will be set to only connect to itself
        --If you include this table, you will need to have this connection's name in the table or it will not connect to itself
  },
  --Register objects that corespond to a connection. When an object is found in a system, that system gains that connection (objects can be systems)
  connectionObjects = {--single table or table of tables; 1 table for each set of objects that have the same connections
    {
      names = "",--stringName or table of stringNames (commom case where an object just has to exist in a system)
      systems = "systemGUID", -- guid|table of guids (you can also add any non-systemTile obj guid to this list, this is just a guid search)
      advancedSearch = --single table or table of tables
      {
       --*How to find this object(include only 1)
       *name = "",
       *guid = "",
       *FIND = {obj = self, func = "findConnectionObject"},
         --params: {color} --return: objRef or table of objRefs

       requireFaceup = false,
       requireActive = false,
       isDiscardable = false, --set to true to prevent this object from being found in its discard pile
     },
     connectsTo = "", --name of a connection string|{table of strings}|"GET"
      --if connectsTo is "GET", you must include getConnections
      --getConnections = {obj = self, func = "getConnectionsFunctionName"}
          --params: {color = "", obj = object Reference, system = systemTable that obj is located in}
          --return: table of connectionNames {"alpha", ...}
    },
  },
  --Instead of a system gaining a connection by finding an object in it(see above), explicitly add systems to connections
  connectionSetters = { --single setter or table of setters
    {
      systems = "systemGUID", --"guid"|{table of systemGUIDs}|"GET"
        --If target is "GET", you must include getSystems
      --getSystems = {obj = self, func = "getFunctionName"},
        --params: {color}
        --return "guid" or table of guids {"g1",...}

      connectsTo = "alpha", --"connectionName"|{table of "connections"}|"GET"
        --If connectsTo is "GET", you must include getConnections
      --getConnections = {obj = self, func = "getFunctionName"},
        --params: {color}
        --return: "connectionName" or table of connectionsNames {"alpha",...}
    },
  },
  --Modify what existing connections connect to. i.e. alpha.connectsTo = {["alpha"]} --> {["alpha"], ["beta"]}
  connectionMutators = {--table of tables, 1 for each mutator
    {
      targetConnections = "", --string|{tableOfStrings}|"GET"
        --if target is "GET", you must include getTargetConnections
      --getTargetConnections = {obj = self, func = "funcName"}, --return a string or {table of strings} representing connections (alpha, beta,...)
      mutate = {obj = self, func = "mutateFunctionName"},
      --params = {color = ""color mutator is applying to, connectsTo = {}table of connectedTo for each target}
      --return new connectedTo table
      --mutate is called sequentialy, once for each target
    },
  }
}
--]]
function injectConnectionRule(params)
  assert(params and type(params) == "table")
  assert(params.id and type(params.id) == 'string', "Your connection rule must have a unique id")
  assert(params.sources and type(params.sources) == "table", "Your connection rule must have a source to define when it should be applied")
  local rule = copyTable(params)

  local isValidTarget = {["OWNER"] = true, ["OTHERS"] = true, ["ALL"] = true, ["GET"] = true}
  local validateSources = rule.sources[1] and rule.sources or {rule.sources}
  for _,each in ipairs(validateSources) do
    assert(each.targetType and isValidTarget[each.targetType])
    if each.targetType == "GET" then
      assert(each.getTarget and type(each.getTarget) == "table" and type(each.getTarget.func) == "string")
    end
  end

  local newRule = {
    id = rule.id,
    sources = validateSources
  }
  --validate optional connectionTypes
  if rule.connectionType then
    newRule.connectionType = rule.connectionType[1] and rule.connectionType or {rule.connectionType}
    for _,each in ipairs(newRule.connectionType) do
      assert(each.name and type(each.name) == "string")
      if not each.connectsTo then each.connectsTo = {each.name} end
    end
  end

  --validate optional connectionObjects
  if rule.connectionObjects then
    newRule.connectionObjects = rule.connectionObjects[1] and rule.connectionObjects or {rule.connectionObjects}
    for _,each in ipairs(newRule.connectionObjects) do
      assert(each.connectsTo, "Connection objects must define what they connectTo")
      local t = type(each.connectsTo)
      assert(t == "string" or t == "table")
      if t == "GET" then
        assert(each.getConnections and type(each.getConnections) == "table" and type(each.getConnections.func) == "string")
      end
    end
  end

  --validate optional connectionSetters
  if rule.connectionSetters then
    newRule.connectionSetters = rule.connectionSetters[1] and rule.connectionSetters or {rule.connectionSetters}
    for _,each in ipairs(newRule.connectionSetters) do
      assert(each.systems)
      local t = type(each.systems)
      assert(t == "string" or t == "table")
      if t == "GET" then assert(each.getSystems and type(each.getSystems) == "table" and type(each.getSystems.func) == "string") end

      assert(each.connectsTo)
      t = type(each.connectsTo)
      assert(t == "string" or t == "table")
      if t == "GET" then assert(each.getConnections and type(each.getConnections) == "table" and type(each.getConnections.func) == "string") end
    end
  end

  --validate optional connectionMutators
  if rule.connectionMutators then
    newRule.connectionMutators = rule.connectionMutators[1] and rule.connectionMutators or {rule.connectionMutators}
    for _,each in ipairs(newRule.connectionMutators) do
      assert(each.targetConnections)
      local t = type(each.targetConnections)
      assert(t == "string" or t == "table")
      if t == "GET" then assert(each.getTargetConnections and type(each.getTargetConnections) == "table" and type(each.getTargetConnections.func) == "string") end

      assert(each.mutate and type(each.mutate) == "table" and type(each.mutate.func) == "string")
    end
  end

  local isOverride = connectionRules[params.id] and true or false
  connectionRules[params.id] = newRule
  _batchPrintInjectionResult("connectionRule", params.id, isOverride)
end

local printInjections = false
local _injectionMessenger = {msg = {}}
function _batchPrintInjectionResult(injectionType, injectedID, isOverride)
  if not printInjections or not injectedID then return end
  local function printMessage()
    local msg = {}
    local pgraphs = {}
    for eachType,tbl in pairs(_injectionMessenger.msg) do
      local p = "____________________\n" .. eachType .." injections:\n"
      for eachID,ovRide in pairs(tbl) do
        p = ovRide and p ..eachID.."(override), " or p.. eachID..", "
      end
      table.insert(pgraphs, p)
    end

    for _,eachMsg in ipairs(pgraphs) do
      printToAll(eachMsg, "Yellow")
    end

    _injectionMessenger.wait = false
    _injectionMessenger.msg = {}
  end

  _injectionMessenger.wait = _injectionMessenger.wait or Wait.frames(printMessage, 3)
  _injectionMessenger.msg[injectionType] = _injectionMessenger.msg[injectionType] or {}
  _injectionMessenger.msg[injectionType][injectedID] = isOverride or false
end
-------------------------------------------------------------------------------

--- Get non-planet items that affect resources and/or influence.
-- DEPRECATED.  PLEASE USE getColorToResInfCards, getColorToResInfModifiers, applyResInfModifiers.
-- @return table: map from LOWERCASE object name to {name,resources,influence} table.
function nonPlanetResourceInfluenceCards()
    local result = {}
    for _, item in ipairs(_nonPlanetResourceInfluenceCards) do
        result[string.lower(item.name)] = item
    end
    return result
end

--- Get resource/influence cards.
-- @param includeFaceDown (boolean): include face down cards.
-- @return table: map from color list of { name, res, inf } tables.
function getColorToResInfCards(includeFaceDown)
    assert((not includeFaceDown) or type(includeFaceDown) == 'boolean')

    local cardToValues = {}
    for _, system in pairs(_systems) do
        for _, planet in ipairs(system.planets or {}) do
            cardToValues[planet.name] = { -- only res/inf fields
                name = planet.name,
                resources = planet.resources or 0,
                influence = planet.influence or 0
            }
        end
    end
    for _, entry in ipairs(_nonPlanetResourceInfluenceCards) do
        cardToValues[entry.name] = entry
    end

    local guidToPosition = {}
    local guidToValues = {}
    local inHandGuidSet = _zoneHelper.inHand()
    local function getValues(object)
        if object.tag ~= 'Card' then
            return false
        elseif inHandGuidSet[object.getGUID()] then
            return false
        end
        local values = cardToValues[object.getName()]
        if not values then
            return false
        end
        if object.is_face_down then
            if values.requireFaceUp or (not includeFaceDown) then
                return false
            end
        end
        return values
    end
    for _, object in ipairs(getAllObjects()) do
        local values = getValues(object)
        if values then
            local guid = object.getGUID()
            guidToPosition[guid] = object.getPosition()
            guidToValues[guid] = values
        end
    end

    local colorToResInfCards = {}
    for _, color in ipairs(_zoneHelper.zones()) do
        colorToResInfCards[color] = {}
    end
    local guidToColor = _zoneHelper.zonesFromPositions(guidToPosition)
    for guid, color in pairs(guidToColor) do
        local values = guidToValues[guid]
        local entry = colorToResInfCards[color]
        table.insert(entry, values)
    end
    return colorToResInfCards
end

--- Get non-trivial modifiers.
-- @return table: map from color to list of modifier names.
function getColorToResInfModifiers()
    local guidToPosition = {}
    local guidToName = {}
    local inHandGuidSet = _zoneHelper.inHand()
    for _, object in ipairs(getAllObjects()) do
        local guid = object.getGUID()
        if object.tag == 'Card' and (not inHandGuidSet[guid]) and (not object.is_face_down) then
            local name = object.getName()
            local modifier = _resInfModifiers[name]
            if modifier then
                local position = object.getPosition()
                guidToPosition[guid] = position
                guidToName[guid] = name
            end
        end
    end

    local colorToResInfModifiers = {}
    local function addModifier(color, modifier)
        local entry = colorToResInfModifiers[color]
        if not entry then
            entry = {}
            colorToResInfModifiers[color] = entry
        end
        for _, value in ipairs(entry) do
            if value == modifier then
                return
            end
        end
        table.insert(entry, modifier)
    end

    for _, color in ipairs(_zoneHelper.zones()) do
        colorToResInfModifiers[color] = {}
    end
    local guidToColor = _zoneHelper.zonesFromPositions(guidToPosition)
    for guid, color in pairs(guidToColor) do
        local name = guidToName[guid]
        addModifier(color, name)
    end

    -- Add faction abilities
    for color, faction in pairs(_factionHelper.allFactions()) do
        for _, ability in ipairs(faction and faction.abilities or {}) do
            if _resInfModifiers[ability] then
                addModifier(color, ability)
            end
        end
    end

    -- Apply alliances, imperia.
    local colorToCommanders = _factionHelper.getColorToCommanders()
    for color, commanders in pairs(colorToCommanders) do
        for _, commander in ipairs(commanders) do
            if _resInfModifiers[commander] then
                addModifier(color, commander)
            end
        end
    end

    return colorToResInfModifiers
end

--- Return modifier descriptions.
-- @param resInfModifiers (table) : list of modifier names.
-- @return (table) : map from name to description.
function getResInfModifierDescriptions(resInfModifiers)
    assert(type(resInfModifiers) == 'table')
    local result = {}
    for _, name in ipairs(resInfModifiers) do
        local modifier = _resInfModifiers[name]
        if modifier then
            result[name] = assert(modifier.description)
        end
    end
    return result
end

--- Compute resource/influcence.
-- @return {resource=#,influence=#} table.
function applyResInfModifiers(params)
    assert(type(params) == 'table')
    assert(type(params.cards) == 'table')
    assert(type(params.modifiers) == 'table')

    local cards = copyTable(params.cards)  -- do not modify in place

    -- Apply MUTATE first to add/remove attributes.
    for _, modifier in ipairs(params.modifiers) do
        assert(type(modifier) == 'string')
        local modifier = _resInfModifiers[modifier]
        if modifier and modifier.type == TYPE.MUTATE then
            modifier.apply(cards)
        end
    end

    -- Apply ADJUST to update (but not add/remove) values.
    for _, modifier in ipairs(params.modifiers) do
        assert(type(modifier) == 'string')
        local modifier = _resInfModifiers[modifier]
        if modifier and modifier.type == TYPE.ADJUST then
            modifier.apply(cards)
        end
    end

    -- Apply CHOOSE to apply effects based on adjusted attributes.
    for _, modifier in ipairs(params.modifiers) do
        assert(type(modifier) == 'string')
        local modifier = _resInfModifiers[modifier]
        if modifier and modifier.type == TYPE.CHOOSE then
            modifier.apply(cards)
        end
    end

    return cards
end

function verifyAllSystems()
    local errors = false
    for guid, system in pairs(_systems) do
        local success, errorMessage = _systemIsValid(system)
        if not success then
            errors = errors or {}
            table.insert(errors, guid .. ': ' .. errorMessage)
        end
    end
    if errors then
        error('verifyAllSystems ' .. table.concat(errors, ', '))
    end
    print('verifyAllSystems: success')
end

--- Verify system follows expectations.
-- @parameters table: system.
-- @return success boolean, string error message.
function _systemIsValid(system)
    local tile = system.tile
    if not tile or type(tile) ~= 'number' then
        return false, 'system.tile must be a number (zero can be used for homebrew)'
    end
    local home = system.home
    if home and type(home) ~= 'boolean' then
        return false, 'system.home must be nil or a boolean'
    end

    local planets = system.planets
    if planets and (type(planets) ~= 'table') then
        return false, 'system.planets must be nil or a list'
    elseif planets then
        for _, planet in ipairs(planets) do
            local name = planet.name
            if not name or type(name) ~= 'string' or string.len(name) == 0 then
                return false, 'planet.name must be a non-empty string'
            end
            local radius = planet.radius
            if radius and (type(radius) ~= 'number' or radius <= 0) then
                return false, 'planet.radius must be nil or a positive number'
            end
            local position = planet.position
            if position and (type(position) ~= 'table' or type(position.x) ~= 'number' or type(position.x) ~= 'number') then
                return false, 'planet.position must be nil or a local {x, z} table'
            end
            local resources = planet.resources
            if resources then
              if type(resources) == "table" then
                if not resources.func or type(resources.func) ~= "string" then
                  return false, "a dynamic resource table must have the string name of a function defined in .func"
                end
              elseif (type(resources) ~= 'number' or resources < 0) then
                return false, 'planet.resources must be nil or a non-negative number'
              end
            end
            local influence = planet.influence
            if influence then
              if type(influence) == "table" then
                if not influence.func or type(influence.func) ~= "string" then
                  return false, "a dynamic influence table must have the string name of a function defined in .func"
                end
              elseif (type(influence) ~= 'number' or influence < 0) then
                return false, 'planet.influence must be nil or a non-negative number'
              end
            end
            local tech = planet.tech
            if tech and tech ~= 'red' and tech ~= 'green' and tech ~= 'yellow' and tech ~= 'blue' then
                return false, 'planet.tech must be {red|green|yellow|blue}'
            end
            local trait = planet.trait
            if trait and trait ~= 'cultural' and trait ~= 'industrial' and trait ~= 'hazardous' then
                return false, 'planet.trait must be {cultural|industrial|hazardous}'
            end
            local legendary = planet.legendary
            if legendary and (type(legendary) ~= 'boolean') then
                return false, 'planet.legendary must be {true|false}'
            end
        end
    end

    local wormholes = system.wormholes
    if wormholes then
        if type(wormholes) ~= 'table' or not wormholes[1] then
            return false, 'system.wormholes must be nil or a non-empty list'
        end
        for _, wormhole in ipairs(wormholes) do
            if not type(wormhole) == 'string' or string.len(wormhole) == 0 then
                return false, 'wormhole must be a non-empty string'
            end
        end
    end

    local anomalies = system.anomalies
    if anomalies then
        if type(anomalies) ~= 'table' or not anomalies[1] then
            return false, 'system.anomalies must be nil or a non-empty list'
        end
        for _, anomaly in ipairs(anomalies) do
            if not type(anomaly) == 'string' or string.len(anomaly) == 0 then
                return false, 'anomaly must be a non-empty string'
            end
        end
    end

    return true
end

--- Get system as printable string (stored in system.string)
-- @param system table.
-- @return string.
function _systemToString(system)
    assert(type(system) == 'table' and system.tile)
    local function capitalizeWords(words)
        local words, _ = words:gsub("(%l)(%w*)", function(a,b) return string.upper(a)..b end)
        return words
    end
    local message = {
        'System ' .. system.tile
    }
    for _, planet in ipairs(system.planets or {}) do
        table.insert(message, #message == 1 and ': ' or ', ')
        table.insert(message, '“' .. planet.name .. '”')
    end
    for _, wormhole in ipairs(system.wormholes or {}) do
        table.insert(message, #message == 1 and ': ' or ', ')
        table.insert(message, capitalizeWords(wormhole) .. ' Wormhole')
    end
    for _, anomaly in ipairs(system.anomalies or {}) do
        table.insert(message, #message == 1 and ': ' or ', ')
        table.insert(message, capitalizeWords(anomaly))
    end
    if system.hyperlane then
        table.insert(message, #message == 1 and ': ' or ', ')
        table.insert(message, 'Hyperlane')
    end
    return table.concat(message, '')
end

--- Convert local bearing coordinate to local XYZ.
function _bearingToPosition(bearing, distance, y)
    assert(type(bearing) == 'number' and 0 <= bearing and bearing < 360 and type(distance) == 'number')
    local bearing = -bearing * math.pi / 180.0
    return {
        x = distance * math.sin(bearing),
        y = y or 0,
        z = -distance * math.cos(bearing)
    }
end

--- Split a system into zones, one for each planet/wormhole.
function _getZoneBorders(system)
    assert(type(system) == 'table' and system.tile)
    local numPlanets = system.planets and #system.planets or 0
    local numWormholes = system.wormholes and #system.wormholes or 0
    local numZones = numPlanets + numWormholes

    -- The local coordinate space for a tile shows {x=1,z=1} to be lower left.
    -- Set zone borders to track planets starting left going clockwise.
    local zoneBorders
    if numZones <= 1 then
        zoneBorders = { 0, 360 }
    elseif numZones == 2 then
        zoneBorders = { 240, 60, 240 }
    elseif numZones == 3 then
        zoneBorders = { 210, 330, 90, 210 }
    else
        -- Mallice has a planet plus three wormholes.  Treat excessive as one zone.
        zoneBorders = { 0, 360 }
    end

    -- Support non-standard rotations (applies to a TI3 tile).
    for i, v in ipairs(zoneBorders) do
        zoneBorders[i] = (v + (system.rotate or 0)) % 360
    end
    return zoneBorders
end

--- Get planet location in local space.  Account for tile variations.
function _planetPosition(system, zoneBorders, planetIndex)
    assert(type(system) == 'table' and system.tile)
    local planet = system.planets[planetIndex]
    local localRadius = planet.radius or LOCAL_PLANET_RADIUS
    local localY = system.localY or LOCAL_SYSTEM_TILE_Y

    -- If planet already has a position, use it.
    if planet.position then
        return { x = planet.position.x, y = localY, z = planet.position.z }, localRadius
    end

    -- Compute the default bearing and distance.
    local distanceToPlanet = 0
    local bearingToPlanet = 0
    if #zoneBorders > 2 then
        local a = zoneBorders[planetIndex]
        local b = zoneBorders[planetIndex + 1]
        if a < b then
            bearingToPlanet = (a + b) / 2
        else
            bearingToPlanet = ((a + 360 + b) / 2) % 360
        end
        distanceToPlanet = LOCAL_DISTANCE_TO_PLANET
    end

    -- Planets bearings are almost but not exactly in the center of their zones.
    -- Home system planets are slightly offset.  Different same-number-of-planets
    -- systems vary slightly, so unless want to hard code each tile this is close.
    local numZones = #zoneBorders - 1
    if numZones == 1 then
        if system.home then
            distanceToPlanet = 0.25
            bearingToPlanet = 0
        else
            distanceToPlanet = 0.1
            bearingToPlanet = 180
        end
    elseif numZones == 2 then
        if planetIndex == 1 then
            if system.home then
                distanceToPlanet = distanceToPlanet - 0.05
                bearingToPlanet = bearingToPlanet + 2
            else
                distanceToPlanet = distanceToPlanet - 0.17
                bearingToPlanet = bearingToPlanet - 0
            end
        elseif planetIndex == 2 then
            if system.home then
                distanceToPlanet = distanceToPlanet - 0
                bearingToPlanet = bearingToPlanet - 17
            else
                distanceToPlanet = distanceToPlanet - 0.07
                bearingToPlanet = bearingToPlanet - 1
            end
        end
    elseif numZones == 3 then
        if planetIndex == 1 then  -- hercant
            if system.home then
                distanceToPlanet = distanceToPlanet + 0.1
                bearingToPlanet = bearingToPlanet + 5
            else
                distanceToPlanet = distanceToPlanet + 0.3
                bearingToPlanet = bearingToPlanet + 8
            end
        elseif planetIndex == 2 then
            if system.home then
                distanceToPlanet = distanceToPlanet + 0.01
                bearingToPlanet = bearingToPlanet - 0
            else
                distanceToPlanet = distanceToPlanet - 0.02
                bearingToPlanet = bearingToPlanet + 4
            end
        elseif planetIndex == 3 then
            if system.home then
                distanceToPlanet = distanceToPlanet + 0.22
                bearingToPlanet = bearingToPlanet - 7
            else
                distanceToPlanet = distanceToPlanet + 0.22
                bearingToPlanet = bearingToPlanet - 2
            end
        end
    end

    return _bearingToPosition(bearingToPlanet, distanceToPlanet, localY), localRadius
end

--- Fill in system fields (only done on the first access, then reused).
function _fillMissingSystemData(guid, system)
    assert(type(guid) == 'string' and type(system) == 'table' and system.tile)
    if not system.guid then
        system.guid = guid
        system.string = _systemToString(system)
        system.y = system.localY or LOCAL_SYSTEM_TILE_Y

        -- Fill zone edge positions, points on edge diving per-planet zones.
        local zoneBorders = _getZoneBorders(system)
        if #zoneBorders > 2 then
            system.zoneEdgePositions = {}
            local r = LOCAL_SYSTEM_TILE_RADIUS
            local y = system.localY or LOCAL_SYSTEM_TILE_Y
            for i = 1, #zoneBorders - 1 do
                local bearing = zoneBorders[i]
                table.insert(system.zoneEdgePositions, _bearingToPosition(bearing, r, y))
            end
        end

        -- Fill in local planet position, radius.
        for i, planet in ipairs(system.planets or {}) do
            planet.position, planet.radius = _planetPosition(system, zoneBorders, i)
        end
    end

    -- If a system has face-up/face-down attributes, reset based on state.
    for k, v in pairs(system) do
        local attrName, side = string.match(k, '^(.*)_face(.*)$')
        local systemObject = attrName and getObjectFromGUID(guid)
        if attrName and systemObject then
            if systemObject.is_face_down then
                if side == 'Down' then
                    system[attrName] = v
                end
            else
                if side == 'Up' then
                    system[attrName] = v
                end
            end
        end
    end

    --update any dynamic planet values(res/inf)
    _updateVariablePlanetValues(system)
end

--update any dynamic planet values(res/inf)
local _varPlanetsUpdatedThisFrame = false
function _updateVariablePlanetValues(system)
  if not _varPlanetsUpdatedThisFrame then Wait.frames(function() _varPlanetsUpdatedThisFrame = false end, 1) end
  system = system or {}

  for _,eachPlanet in ipairs(system.planets or {}) do
    if _dynamicPlanetValues[eachPlanet.name] then
      local getRes = _dynamicPlanetValues[eachPlanet.name].resources or false
      local getInf = _dynamicPlanetValues[eachPlanet.name].influence or false
      if getRes then
        local newRes = _varPlanetsUpdatedThisFrame and getRes.lastResult or tryCall(getRes.callData, {planet = eachPlanet.name, resources = true}) or getRes.lastResult
        getRes.lastResult = newRes
        eachPlanet.resources = newRes
      end

      if getInf then
        local newInf = _varPlanetsUpdatedThisFrame and getInf.lastResult or tryCall(getInf.callData, {planet = eachPlanet.name, influence = true}) or getInf.lastResult
        eachPlanet.influence = newInf
        getInf.lastResult = newInf
      end
    end
  end

  _varPlanetsUpdatedThisFrame = true
end

--wormholes() now builds from CONNECTIONS which allows for injection and returns a result in the same format
function wormholes_depricated(playerColor)
    assert(not playerColor or type(playerColor) == 'string')
    local result = {
        ['alpha'] = {
            guids = {},
            connected = { 'alpha' }
        },
        ['beta'] = {
            guids = {},
            connected = { 'beta' }
        },
        ['delta'] = {
            guids = {},
            connected = { 'delta' }
        },
        ['gamma'] = {
            guids = {},
            connected = { 'gamma' }
        },
    }

    local function addGuid(wormhole, guid)
        table.insert(result[wormhole].guids, guid)
    end

    local function addConnection(src, dst)
        for _, existing in ipairs(result[src].connected) do
            if existing == dst then
                return
            end
        end
        table.insert(result[src].connected, dst)
    end

    -- Ghosts (or Franken with the ability) connect A/B.
    local faction = playerColor and _factionHelper.fromColor(playerColor)
    for _, ability in ipairs(faction and faction.abilities or {}) do
        if ability == 'Quantum Entanglement' then
            addConnection('alpha', 'beta')
            addConnection('beta', 'alpha')
        end
    end

    -- Non-system wormhole objects.
    local objectNameToNonSystemWormholes = {
        ['Alpha Wormhole Token'] = { 'alpha' },
        ['Beta Wormhole Token'] = { 'beta' },
        ['Hil Colish'] = { 'delta' },
        ['Gamma Wormhole Token'] = { 'gamma' },
    }

    for _, object in ipairs(getAllObjects()) do
        if object.tag ~= 'Bag' then
            local guid = object.getGUID()
            local name = object.getName()

            local system = systemFromGuid(guid)
            local nonSystemWormholes = objectNameToNonSystemWormholes[name]

            if system then
                for _, wormhole in ipairs(system.wormholes or {}) do
                    addGuid(wormhole, guid)
                end
            elseif nonSystemWormholes then
                for _, wormhole in ipairs(nonSystemWormholes) do
                    addGuid(wormhole, guid)
                end
            end

            if name == 'Ion Storm Token' then
                local wormholeSide = 'alpha'
                if object.is_face_down then
                    wormholeSide = 'beta'
                end
                addGuid(wormholeSide, guid)
            end

            if name == 'Wormhole Reconstruction' and (not object.is_face_down) and (not _deckHelper.isDiscard(guid)) then
                addConnection('alpha', 'beta')
                addConnection('beta', 'alpha')
            end

            if name == 'Lost Star Chart' and (not object.is_face_down) and (not _deckHelper.isDiscard(guid)) then
                addConnection('alpha', 'beta')
                addConnection('beta', 'alpha')
            end

            -- Ghosts agent.
            if name == 'Emissary Taivra' and (not object.is_face_down) and _unitHelper._isToggleActiveCardActive(object) then
                local activeSystem = getActivatedSystem()
                if activeSystem then
                    _fillMissingSystemData(activeSystem.guid, activeSystem)
                    for _, wormhole in ipairs(activeSystem.wormholes or {}) do
                        if wormhole ~= 'delta' then
                            addConnection('alpha', 'beta')
                            addConnection('alpha', 'gamma')
                            addConnection('alpha', 'delta')
                            addConnection('beta', 'gamma')
                            addConnection('beta', 'delta')
                            addConnection('gamma', 'delta')
                            break
                        end
                    end
                end
            end
        end
    end

    return result
end

-------------------------------------------------------------------------------

--- Make sure system tile is grid aligned and laying flat.
function lockSystemTile(tileGuid)
    assert(type(tileGuid) == 'string')
    local object = getObjectFromGUID(tileGuid)
    if object then
        -- Get grid position.
        local hex = hexFromPosition(object.getPosition())
        local pos = hexToPosition(hex)

        -- Place so laying flat on table surface.
        local h = object.getBoundsNormalized().size.y
        pos.y = _zoneHelper.getTableY() + (h / 2) - 0.01

        -- Rotation (expect y = 0 or 180).
        local rot = object.getRotation()
        rot = {
            x = math.floor(rot.x + 0.5),
            y = math.floor(rot.y + 0.5),
            z = math.floor(rot.z + 0.5)
        }

        object.setPosition(pos)
        object.setRotation(rot)
        object.setLock(true)
    end
end

function summarizeTiles(tiles)
    assert(type(tiles) == 'table')
    local r = 0
    local i = 0
    local tech = {}
    local legendary = 0
    local wormholes = {}

    -- local wormholeToSymbol = {
    --     ['alpha'] = '\u{03B1}',
    --     ['beta'] = '\u{03B2}',
    --     ['delta'] = '\u{03B3}',
    --     ['gamma'] = '\u{03B4}',
    -- }
    local wormholeToSymbol = {
        ['alpha'] = 'α',
        ['beta'] = 'β',
        ['delta'] = 'δ',
        ['gamma'] = 'γ',
    }
    for _, tile in ipairs(tiles) do
        local system = systemFromTile(tile)
        if not system then
            error('summarizeTiles: bad tile ' .. tile)
        end
        for _, planet in ipairs(system.planets or {}) do
            r = r + (planet.resources or 0)
            i = i + (planet.influence or 0)
            if planet.tech then
                table.insert(tech, string.sub(planet.tech, 1, 1):upper())
            end
            if planet.legendary then
                legendary = legendary + 1
            end
        end
        for _, wormhole in ipairs(system.wormholes or {}) do
            local symbol = wormholeToSymbol[wormhole]
            if symbol then
                table.insert(wormholes, symbol)
            end
        end
    end
    local items = {
        r .. '/' .. i
    }
    if #tech > 0 then
        table.sort(tech)
        table.insert(items, table.concat(tech, ''))
    end
    if legendary > 0 then
        local n = legendary
        table.insert(items, ((n > 1) and n or '') .. 'L')
    end
    if #wormholes > 0 then
        table.sort(wormholes)
        table.insert(items, table.concat(wormholes, ''))
    end
    return table.concat(items, ' ')
end

-------------------------------------------------------------------------------

-- Heavily distilled hex math based on RedBlobGames excellent hex math.
local _M = {
    -- F matrix translates hex to position.
    f0 = 3.0 / 2.0,
    f1 = 0.0,
    f2 = math.sqrt(3.0) / 2.0,
    f3 = math.sqrt(3.0),
    -- B matrix translates position to hex.
    b0 = 2.0 / 3.0,
    b1 = 0.0,
    b2 = -1.0 / 3.0,
    b3 = math.sqrt(3.0) / 3.0,
    -- Angle to first corner (0 for flat top hex).
    start_angle = 0.0
}

local _LAYOUT = {
    size = { x = (Grid.sizeX or 7) / 2.0, z = (Grid.sizeY or 7) / 2.0 },
    origin = { x = 0, z = 0 }
}

--- Get a hex id from a position.
-- @param position table : {xyz} position.
-- @return hex string.
function hexFromPosition(position)
    assert(type(position) == 'table')

    -- Fractional hex position.
    local p = {
        x = (position.x - _LAYOUT.origin.x) / _LAYOUT.size.x,
        z = (position.z - _LAYOUT.origin.z) / _LAYOUT.size.z
    }
    local q = _M.b0 * p.x + _M.b1 * p.z
    local r = _M.b2 * p.x + _M.b3 * p.z
    local s = -q - r

    -- Round to grid aligned hex.
    local qi = math.floor(0.5 + q)
    local ri = math.floor(0.5 + r)
    local si = math.floor(0.5 + s)
    local q_diff = math.abs(qi - q)
    local r_diff = math.abs(ri - r)
    local s_diff = math.abs(si - s)
    if q_diff > r_diff and q_diff > s_diff then
        qi = -ri - si
    else
        if r_diff > s_diff then
            ri = -qi - si
        else
            si = -qi - ri
        end
    end

    return '<' .. qi .. ',' .. ri .. ',' .. si .. '>'
end

--- Bulk hexFromPosition.
function hexesFromPositions(guidToPosition)
    assert(type(guidToPosition) == 'table')
    local result = {}
    for guid, position in pairs(guidToPosition) do
        result[guid] = hexFromPosition(position)
    end
    return result
end

--- Get a position from a hex.
-- @param hex : hex encoded as string.
-- @return table : position {xyz}.
function hexToPosition(hex)
    assert(type(hex) == 'string')
    local q, r, s = string.match(hex, '<(%-?%d+),(%-?%d+),(%-?%d+)>')
    assert(not (math.floor (0.5 + q + r + s) ~= 0), 'q + r + s must be 0')
    local x = (_M.f0 * q + _M.f1 * r) * _LAYOUT.size.x
    local z = (_M.f2 * q + _M.f3 * r) * _LAYOUT.size.z
    return { x = x + _LAYOUT.origin.x, y = 0, z = z + _LAYOUT.origin.z }
end

-- Bulk hexToPosition
function hexesToPosition(guidToHex)
    assert(type(guidToHex) == 'table')
    local result = {}
    for guid, hex in pairs(guidToHex) do
        result[guid] = hexToPosition(hex)
    end
    return result
end

--- Get clockwise winding corners about a hex.
-- @param hex : hex encoded as string.
-- @return table : list of {xyz} positions.
function hexCorners(hex)
    local center = hexToPosition(hex)
    local function hexCornerOffset(corner)
        local angle = 2.0 * math.pi * (_M.start_angle - corner) / 6.0
        return {
            x = center.x + _LAYOUT.size.x * math.cos(angle),
            y = center.y,
            z = center.z + _LAYOUT.size.z * math.sin(angle)
        }
    end
    local corners = {}
    for i = 0, 5 do
        table.insert(corners, hexCornerOffset(i))
    end
    return corners
end

--- Get clockwise winding neighbors about a hex.
-- @param hex : hex encoded as string.
-- @return table : list of neighbor hex strings.
function hexNeighbors(hex)
    assert(type(hex) == 'string')
    local q, r, s = string.match(hex, '<(%-?%d+),(%-?%d+),(%-?%d+)>')
    local function makeHex(q, r, s)
        return '<' .. q .. ',' .. r .. ',' .. s .. '>'
    end
    return {
        makeHex(q + 1, r + 0, s - 1),
        makeHex(q + 1, r - 1, s + 0),
        makeHex(q + 0, r - 1, s + 1),
        makeHex(q - 1, r + 0, s + 1),
        makeHex(q - 1, r + 1, s + 0),
        makeHex(q + 0, r + 1, s - 1)
    }
end

--- Get wormhole-adjacent hexes.
-- @param params : {hex=string, isGhosts=boolean} table.
-- @return table : list of wormhole-adjacent hex strings.
function hexAdjacentWormholes(params)
    assert(type(params) == 'table')
    assert(type(params.hex) == 'string')
    assert(not params.playerColor or type(params.playerColor) == 'string')
    local hex = params.hex

    local wormholes = wormholes(params.playerColor)
    local wormholesInThisHexSet = {}
    local wormholeToHexSet = {}
    for wormhole, state in pairs(wormholes) do
        wormholeToHexSet[wormhole] = {}
        for _, guid in ipairs(state.guids) do
            local object = getObjectFromGUID(guid)
            local wormholeHex = hexFromPosition(object.getPosition())
            if hex == wormholeHex then
                wormholesInThisHexSet[wormhole] = true
            else
                -- Only include wormholes in other hexes.
                wormholeToHexSet[wormhole][wormholeHex] = true
            end
        end
    end

    local adjacentSet = {}
    for wormhole, _ in pairs(wormholesInThisHexSet) do
        for _, connected in ipairs(wormholes[wormhole].connected) do
            for wormholeHex, _ in pairs(wormholeToHexSet[connected]) do
                adjacentSet[wormholeHex] = true
            end
        end
    end

    local result = {}
    for adjacentHex, _ in pairs(adjacentSet) do
        if adjacentHex ~= hex then
            table.insert(result, adjacentHex)
        end
    end
    return result
end

--- Get neighbors through an hyperlane system
-- @param scrHex (hex) : source hex
-- @param hyperlaneSystem (system) : hyperlane system
-- @return table : list of neighbor hex strings. Will not return hyperlanes hexes.
function getHyperlaneNeighbors(srcHex, hyperlaneSystem, visitedHexSet)
    local hyperlaneObj = getObjectFromGUID(hyperlaneSystem.guid)
    local hyperlaneHex = hexFromPosition(hyperlaneObj.getPosition())
    local hyperlaneNeighbors = hexNeighbors(hyperlaneHex)
    visitedHexSet[srcHex] = true

    local hyperlaneRotation = hyperlaneObj.getRotation().y % 360
    local rotationOffset = math.floor(hyperlaneRotation / 60 + 0.5)
    local idxSrc = 0

    -- Find on which side of the hyperlane the source hex is
    for idx, value in pairs(hyperlaneNeighbors) do
        if value and value == srcHex then
            idxSrc = ((idx - 1 - rotationOffset) % 6) + 1
        end
    end

    local result = {}
    if idxSrc < 1 and idxSrc > 12 then
        log("WARNING getHyperlaneNeighbors : source hex is not adjacent to hyperlane")
        return result
    end

    -- get the list of hexes connected throuh the hyperlane
    local connectedNeighborsIdx = hyperlaneSystem.hyperlanes[idxSrc]
    for _, connectedNeighbor in pairs(connectedNeighborsIdx) do
        local updatedIdx = (connectedNeighbor + rotationOffset) % 6 + 1
        local connectedHex = hyperlaneNeighbors[updatedIdx]

        if connectedHex ~= hyperlaneHex then
            local neighborSystem = systemFromPosition(hexToPosition(connectedHex))
            -- if the connected hex is an hyperlane, keep processing the path
            if neighborSystem and neighborSystem.hyperlanes then
                if not visitedHexSet[connectedHex] then
                    local allConnected = getHyperlaneNeighbors(hyperlaneHex, neighborSystem, visitedHexSet)
                    for _, allConnectedHex in pairs(allConnected) do
                        table.insert(result, allConnectedHex)
                    end
                end
            else
                table.insert(result, connectedHex)
            end
        end
    end
    return result
end

--- Get all adjacent hexes, including hyperlane-connected hexes
-- @param hex : hex encoded as string.
-- @return table : list of neighbor hex strings.
function hexNeighborsWithHyperlanes(hex)

    local allHexesNeighbors = hexNeighbors(hex)
    local connectedNeighbors = {}
    for _, neighborHex in pairs(allHexesNeighbors) do
        local neighborSystem = systemFromPosition(hexToPosition(neighborHex))
        if neighborSystem and neighborSystem.hyperlanes then
            local allConnectedNeighbors = getHyperlaneNeighbors(hex, neighborSystem, {})
            for _, connectedHex in pairs(allConnectedNeighbors) do
                table.insert(connectedNeighbors, connectedHex)
            end
        else
            table.insert(connectedNeighbors, neighborHex)
        end
    end

    -- remove duplicates and self
    local finalResult = {}
    local hash = {}
    for _,v in ipairs(connectedNeighbors) do
        if not hash[v] and v ~= hex then
            table.insert(finalResult, v)
            hash[v] = true
        end
    end

    return finalResult
end

--CONNECTIONS-------------------------------------------------------------------

--[[CONNECTIONS._activeConnections =
  {--table for each color that has a faction
    [color] = {
      connections = {
        ["connectionName"] = {
          --values in these tables are stored as keys to prevent douplicate entries
          systems = {[guid] = true,...},
          connectsTo = { ["alpah"] = true,...}
        }
      },
      connectionMutators = {},
    }
}--]]

--[[CONNECTIONS._systemConectivity = the final result after all connections are applied
{
  [color] = { --table for each color
    [systemGUID] = {["alpah"] = true,...}--table of systems indexed by connection type
  }
}--]]

--[[ --rule format:
local connectionRule = {
  id = "", --give this modifier a unique id
  description = "",
  --Sources determine when when this rule is in play and who it effects
  sources = {
    {--rules can have multiple types of sources, each with multiple references
      isUniversalRule = false, --Is this rule allways in play?
      --if not universal, refs are how we determine if this source is active/in play
      refs = { --You may ommit any of these subTables
        OBJECTS = {"stringName", objectTable}, --Look for objects that may enable this rule
         --mixed table of stings/objectTables. objectTables allow additional settings
         --objectTable =
         {
          --*How to find this object(include only 1)
          *name = "",
          *guid = "",

          requireFaceup = false,
          requireActive = false, --Does the object have a toggle Active button (unit modifier cards only), this does not create a toggel button for the obj
          isDiscardable = false, --set to true to prevent this object from being found in its discard pile
        },
        FACTION_ABILITIES = {"abilityName_1",...},
        GET = {obj = self, func = "isConnectionRuleActive"}, --function should return true if this source is active/in play
      }

      --If this source is active/in play, who will it effect?
      targetType = "OWNER"|"OTHERS"|"ALL"|"GET" --"OTHERS" == NOT OWNER
      --If target is "GET", you must include getTarget
      --getTarget = {obj = self, func = "myTargetFuncName"}, --function should return a color or table of colors to target

      --*internal values
      --isActive = bool,
      --_activeObjects = {objRef},--objects from refs that have been found (and are faceup/active if required)
      --_activeAbilityOwners = {[color] = true}, --color indexed list of colors whose factions have an ability found in refs.FACTION_ABILITIES
  }},
  --*internal vars
  --_activeTargets = false, --or {[color] = true} table of color targets, no douplicates

  --Each of the below tables are optional

  --Create a new type of connection (or a table of connections)
  connectionType = {
    name = "",--unique name for the connection type
    connectsTo = {"name", "alpha"},--*optional if not included, it will be set to only connect to itself
        --If you include this table, you will have to have this connection's name in the table or it will not connect to itself
  },
  --Register objects that corespond to a connection. When an object is found in a system, that system gains that connection (objects can be systems)
  connectionObjects = {--table of tables; 1 table for each set of objects that have the same connections
    {
      names = "",--stringName or table of stringNames (commom case where an object just has to exist in a system)
      systems = "systemGUID", -- guid|table of guids (you can also add any non-systemTile obj guid to this list, this is just a guid search)
      advancedSearch = --single table or table of tables
      {
       --*How to find this object(include only 1)
       *name = "",
       *guid = "",
       *FIND = {obj = self, func = "findConnectionObject"},
         --params: {color} --return: objRef or table of objRefs

       requireFaceup = false,
       requireActive = false,
       isDiscardable = false, --set to true to prevent this object from being found in its discard pile
     },
     connectsTo = "", --name of a connection string|{table of strings}|"GET"
      --if connectsTo is "GET", you must include getConnections
      --getConnections = {obj = self, func = "getConnectionsFunctionName"}
          --params: {color = "", obj = object Reference, system = systemTable that obj is located in}
    },
  },
  --Instead of a system gaining a connection by finding an object in it(see above), explicitly add systems to connections
  connectionSetters = { --single setter or table of setters
    {
      systems = "systemGUID", --"guid"|{table of systemGUIDs}|"GET"
        --If target is "GET", you must include getSystems
      --getSystems = {obj = self, func = "getFunctionName"},
        --params: {color}
        --return "guid" or table of guids {"g1",...}

      connectsTo = "alpha", --"connectionName"|{table of "connections"}|"GET"
        --If connectsTo is "GET", you must include getConnections
      --getConnections = {obj = self, func = "getFunctionName"},
        --params: {color}
        --return: "connectionName" or table of connectionsNames {"alpha",...}
    },
  },
  --Modify what existing connections connect to. i.e. alpha.connectsTo = {["alpha"]} --> {["alpha"], ["beta"]}
  connectionMutators = {--table of tables, 1 for each mutator
    {
      targetConnections = "", --string|{tableOfStrings}|"GET"
        --if target is "GET", you must include getTargetConnections
      --getTargetConnections = {obj = self, func = "funcName"}, --return a string or {table of strings} representing connections (alpha, beta,...)
      mutate = {obj = self, func = "mutateFunctionName"},
      --params = {color = ""color mutator is applying to, connectsTo = {}table of connectedTo for each target}
      --return new connectedTo table
      --mutate is called sequentialy, once for each target
    },
  }
}
--]]

---Connection mutator and get functions-------------------------------------------------
--connectionMutators are provided the following params. Additional params may be exlpicitly added
--[[default params = {
  color = "The color player connections are being built for",
  connectsTo = {["alpha"] = true,...}, value indexed table of the current connections that apply to color player
}--]]

--additional params: linkTo = {"alpah",...} define what wormholes to add connections for
function _linkConnectionToWormholes(params)
  local connectsTo = params.connectsTo or {}
  local linkTo = type(params.linkTo) == "table" and params.linkTo or {params.linkTo}
  for _,eachType in ipairs(linkTo) do
    connectsTo[eachType] = true
  end
  return connectsTo
end

function _linkToOtherWormholes(params)
  local worms = {}
  for each,_ in pairs(_worholeTypes) do
    table.insert(worms, each)
  end
  return _linkConnectionToWormholes({linkTo = worms, connectsTo = params.connectsTo})
end

--params = {color, obj, system}
function getIonStormWormhole(params)
  params = params or {}
  if params.obj == nil or type(params.obj) ~= "userdata" or params.obj.getName() ~= "Ion Storm Token" then return end
  return params.obj.is_face_down and {"beta"} or {"alpha"}
end

local _LzxGF = false
local _rex = {card = false, hex = false}
function getLazaxGateFolding()
  if _LzxGF then return _LzxGF.result end
  _LzxGF = {result = {}, cards = {}, wait = Wait.time(function() _LzxGF = false end, 3)}

  _rex.card = _rex.card or getObjectFromGUID("76215f")
  _rex.hex = _rex.hex or getObjectFromGUID("3442d7")
  if not Turns.enable or not _rex.card or not _rex.hex then return {} end
  if _zoneHelper.zoneFromPosition(_rex.card.getPosition()) == Turns.turn_color then return {} end

  for _,eachObj in ipairs(getAllObjects()) do
    if eachObj.getName() == "Lazax Gate Folding" then
      table.insert(_LzxGF.cards, eachObj)
    end
  end

  for _,eachObj in ipairs(_LzxGF.cards or {}) do
    if _zoneHelper.zoneFromPosition(eachObj.getPosition()) == Turns.turn_color then
      _LzxGF.result = {_rex.hex}
      return {_rex.hex}
    end
  end
  return {}
end
--------

--gets neighbors, hyperlane neighbors, and connections through wormholes and other injected connections
--return: table of adjacent system guids with hex and system data: {["guid1"] = {hex = hexPosition, system = systemTable}}
function _getAdjacentSystems(systemGuid, playerColor, highlight)
  local systemObj = getObjectFromGUID(systemGuid)
  if systemObj == nil then return {} end

  local activeHex = hexFromPosition(systemObj.getPosition())
  CONNECTIONS.build()
  local result = {}

  --get adjacents from connections (wormholes and injected connection rules)
  local connections = _getSystemsConnectedTo(systemGuid, playerColor) or {}
  for eachGUID,_ in pairs(connections) do
    local sObj = getObjectFromGUID(eachGUID)
    if sObj ~= nil then
      local hex = hexFromPosition(sObj.getPosition())
      result[eachGUID] = {hex = hex, system = _systems[eachGUID]}
    end
  end

  --get adjacents from physical neighbors and hyperlanes
  local neighbors = hexNeighborsWithHyperlanes(activeHex) or {}
  for _,eachHex in ipairs(neighbors) do
    local system = systemFromPosition(hexToPosition(eachHex))
    if system ~= nil then
      result[system.guid] = {hex = eachHex, system = system}
    end
  end

  result[systemGuid] = nil --active system not adjacent to self
  if highlight then _highlightSystems(result, playerColor, type(highlight) == "number" and highlight or nil) end

  return result
end

--params:
  --system = {[guid_1] = true,...} table indexed by system guid (the format of system tables in getAdjSystems)
  --colorPerspective = "color". Faction abilities can effect system connections
  --duration = # *optional, defaults to permanent highlight
local _highlightedSystems = false
local _waitingHighlightReset = false
function _highlightSystems(systems, colorPerspective, duration)
  --turn off any previously highlighted sytems
  for _,eachObj in ipairs(_highlightedSystems or {}) do
    if eachObj ~= nil then eachObj.highlightOff() end
  end
  if _waitingHighlightReset then
    Wait.stop(_waitingHighlightReset)
    _waitingHighlightReset = false
  end

  local function getBestHighlight(systemGuid)
    if not CONNECTIONS._systemConectivity or not CONNECTIONS._systemConectivity[colorPerspective] or not CONNECTIONS._systemConectivity[colorPerspective][systemGuid] then return "White" end

    local scoreColor = { "White", "Green", "Orange", "Brown", "Teal", "Pink", "Blue", "Purple" }
    local weight = {
      ["beta"] = 1,
      ["alpha"] = 2,
      --a&b = 3
      --injectedWormholes = 4
      ["gamma"] = 5,
      ["delta"] = 6,
      --nonWormhole/injected connections = 7
    }

    local best = 0
    local _connections = CONNECTIONS._systemConectivity[colorPerspective][systemGuid] or {}
    local aAndb = 0

    for each,_ in pairs(_connections) do
      --known wormhole or injected wormhole or non-wormhole connection
      local score = weight[each] or (_wormholeTypes[each] and 4) or 7
      aAndb = aAndb + ((each == "alpha" or each == "beta") and 1 or 0)
      score = aAndb == 2 and score < 3 and 3 or score
      if score == 4 then scoreColor[5] = _wormholeTypes[each] end --get the color of injected wormhole
      best = score > best and score or best
    end

    return scoreColor[best + 1] -- +1 because default value(White) is 0. oops
  end

  _highlightedSystems = {}
  if duration then _waitingHighlightReset = Wait.time(function() _waitingHighlightReset = false _highlightedSystems = {} end, duration) end
  for eachGUID,_ in pairs(systems) do
    local systemObj = getObjectFromGUID(eachGUID)
    if systemObj then
      table.insert(_highlightedSystems, systemObj)
      systemObj.highlightOn(getBestHighlight(eachGUID), duration)
    end
  end
end

function _removeSystemHighlights()
  --turn off any previously highlighted sytems
  for _,eachObj in ipairs(_highlightedSystems or {}) do
    if eachObj ~= nil then eachObj.highlightOff() end
  end
  if _waitingHighlightReset then Wait.stop(_waitingHighlightReset) end

  _waitingHighlightReset = false
  _highlightedSystems = {}
end

--ONLY finds systems connected by a "connection" (wormhole or injected connection). Does not return all adjacent systems
--target can be a system guid or a type of connection such as "alpha"
--return: table of guids indexed by value {["guid"] = true, ["g2"] = true,...}
function _getSystemsConnectedTo(target, playerColor)
  CONNECTIONS.build()
  if not CONNECTIONS._activeConnections[playerColor] then return {} end
  local result = {}
  --if target is a type of connection, get each connection type that is connected to target
  if CONNECTIONS._activeConnections[playerColor].connections[target] then
    for eachConnection, data in pairs(CONNECTIONS._activeConnections[playerColor].connections or {}) do
      if data.connectsTo and data.connectsTo[target] then
        for eachSystem,_ in pairs(data.systems or {}) do
          result[eachSystem] = true
        end
      end
    end
    return result
  end

  --target is system guid. Get each connection type that has that guid
  for eachConnection, data in pairs(CONNECTIONS._activeConnections[playerColor].connections or {}) do
    if data.systems and data.systems[target] then
      for eachSystem,_ in pairs(data.systems) do
        result[eachSystem] = true
      end
    end
  end

  result[target] = nil
  return result
end

function getConnectionData()
  CONNECTIONS.build()
  return {connections = copyTable(CONNECTIONS._activeConnections), connectionsBySystem = copyTable(CONNECTIONS._systemConectivity)}
end

CONNECTIONS.build = function()
  if _connectionsThisFrame then return end
  _connectionsThisFrame = {waitingReset = Wait.frames(function() _connectionsThisFrame = false end, 1)}
  CONNECTIONS._activeConnections = {}
  CONNECTIONS._systemConectivity = {}
  CONNECTIONS.getActiveSources()
  CONNECTIONS.getRuleTargets()

  local function addRuleConnections(color, rule)
    if not rule.connectionType then return end
    --init tables
    CONNECTIONS._activeConnections[color] = CONNECTIONS._activeConnections[color] or {}
    CONNECTIONS._activeConnections[color].connections = CONNECTIONS._activeConnections[color].connections or {}

    --convert to table of tables
    local connectionTypes = rule.connectionType[1] and rule.connectionType or {rule.connectionType}
    for _,connectionData in ipairs(connectionTypes) do
      --set value
      local _connections = connectionData.connectsTo or {[connectionData.name] = true}
      local hashConnections = {} --convert a list of strings into a hash to prevent douplicates {"alpha", "beta"} --> {["alpha"] = true, ["beta"] = true}
      for k, val in pairs(_connections) do
        if type(k) == "number" then hashConnections[val] = true
        else hashConnections[k] = true
        end
      end
      CONNECTIONS._activeConnections[color].connections[connectionData.name] = {systems = {}, connectsTo = hashConnections}
    end
  end

  local function addRuleMutators(color, rule)
    if not rule.connectionMutators then return end
    --init tables
    CONNECTIONS._activeConnections[color] = CONNECTIONS._activeConnections[color] or {}
    CONNECTIONS._activeConnections[color].connectionMutators = CONNECTIONS._activeConnections[color].connectionMutators or {}

    --convert to table of tables
    local mutators = rule.connectionMutators[1] and rule.connectionMutators or {rule.connectionMutators}
    for _,mutateData in ipairs(mutators) do
      --set value
      table.insert(CONNECTIONS._activeConnections[color].connectionMutators, mutateData)
    end
  end

  local objectsToFind = {names = {}, guids = {}, found = {}}
  local function registerConnectionObjects(color, rule)
    if not rule.connectionObjects then return end

    --convert to table of tables
    local objData = rule.connectionObjects[1] and rule.connectionObjects or {rule.connectionObjects}
    for _,eachSet in ipairs(objData) do
      local connectsTo = type(eachSet.connectsTo) == "table" and eachSet.connectsTo or {eachSet.connectsTo}
      local function regByName(name, requireFaceup, requireActive, isDiscardable)
        objectsToFind.names[name] = objectsToFind.names[name] or {}
        objectsToFind.names[name][color] = objectsToFind.names[name][color] or {}
        local instance = {
          requireFaceup = requireFaceup,
          requireActive = requireActive,
          isDiscardable = isDiscardable,
          connectsTo = connectsTo,
          getConnections = eachSet.getConnections
        }
        table.insert(objectsToFind.names[name][color], instance)
      end
      local function regByGUID(guid, requireFaceup, requireActive, isDiscardable)
        objectsToFind.guids[guid] = objectsToFind.guids[guid] or {}
        objectsToFind.guids[guid][color] = objectsToFind.guids[guid][color] or {}
        local instance = {
          requireFaceup = requireFaceup,
          requireActive = requireActive,
          isDiscardable = isDiscardable,
          connectsTo = connectsTo,
          getConnections = eachSet.getConnections
        }
        table.insert(objectsToFind.guids[guid][color], instance)
      end

      for _,eachName in ipairs(eachSet.names or {}) do
        regByName(eachName)
      end
      for _,eachTile in ipairs(eachSet.systemTiles or {}) do
        regByGUID(eachTile)
      end
      if eachSet.advancedSearch then
        local advancedSearch = eachSet.advancedSearch[1] and eachSet.advancedSearch or {eachSet.advancedSearch}
        for _,eachSearch in ipairs(advancedSearch) do
          if eachSearch.name   then regByName(eachSearch.name, eachSearch.requireFaceup, eachSearch.requireActive, eachSearch.isDiscardable)
          elseif eachSearch.guid then regByGUID(eachSearch.guid, eachSearch.requireFaceup, eachSearch.requireActive, eachSearch.isDiscardable)
          else
            local foundResult = tryCall(eachSearch.FIND, {color = color}) or {}
            for _,each in ipairs(foundResult) do
              regByGUID(each.getGUID(), eachSearch.requireFaceup, eachSearch.requireActive, eachSearch.isDiscardable)
            end
          end
        end
      end
    end
  end

  for _,eachRule in pairs(connectionRules) do
    for effectedColor,_ in pairs(eachRule._activeTargets or {}) do
      addRuleConnections(effectedColor, eachRule)
      addRuleMutators(effectedColor, eachRule)
      registerConnectionObjects(effectedColor, eachRule)
    end
  end

  --apply mutators
  for eachColor,data in pairs(CONNECTIONS._activeConnections) do
    if data.connections then
      for _,eachMutator in ipairs(data.connectionMutators or {}) do
        --get targets as a table of strings
        local targets = type(eachMutator.targetConnections) == "table" and eachMutator.targetConnections
          or (eachMutator.targetConnections ~= "GET" and {eachMutator.targetConnections} or tryCall(eachMutator.getTargetConnections, {color = eachColor})) or {}
        for _,eachTarget in ipairs(targets) do
          if data.connections[eachTarget] then
            local callResult = tryCall(eachMutator.mutate, {color = eachColor, connectsTo = data.connections[eachTarget].connectsTo})
            --callResult should be a table of connections indexed by those connections: {["alpha"] = true, ["gamma"] = true}
            data.connections[eachTarget].connectsTo = callResult or data.connections[eachTarget].connectsTo
          end
        end
      end
    end
  end

  --apply connection objects
  for _,eachObj in ipairs(getAllObjects()) do
    local name = eachObj.getName()
    local guid = eachObj.getGUID()
    if objectsToFind.names[name] or objectsToFind.guids[guid] then
      local inSystem = systemFromPosition(eachObj.getPosition()) or false--Maybe bulk this if ray casts are too expinsive?
      if inSystem then
        local function applyConnections(objTable)
          for eachColor, instances in pairs(objTable) do
            --each object may be referenced by multiple different connections(instances)
            for _, data in ipairs(instances) do
              if (not data.requireFaceup or not eachObj.is_face_down) and (not data.requireActive or _unitHelper._isToggleActiveCardActive(eachObj)) and (not data.isDiscardable or not _deckHelper.isDiscard(guid)) then
                local connectsTo = not data.getConnections and data.connectsTo or tryCall(data.getConnections,{color = eachColor, obj = eachObj, system = inSystem})
                for _,eachConnection in ipairs(connectsTo or {}) do
                  --instead of simply adding this obj to each connection listed in the object's connectedTo table,
                  --we need to go to each of those connections and add the object to each of the connetions' connectedTo tables
                  --otherwise mutations will not be applied.
                  if CONNECTIONS._activeConnections[eachColor].connections[eachConnection] then
                    for eachLink,_ in pairs(CONNECTIONS._activeConnections[eachColor].connections[eachConnection].connectsTo or {}) do
                      if CONNECTIONS._activeConnections[eachColor].connections[eachLink] then
                        CONNECTIONS._activeConnections[eachColor].connections[eachLink].systems[inSystem.guid] = true
                      end
                    end
                  end
                end
              end
            end
          end
        end
        applyConnections(objectsToFind.names[name] or {})
        applyConnections(objectsToFind.guids[guid] or {})
      end
    end
  end

  --apply setters
  for _,eachRule in pairs(connectionRules) do
    for effectedColor,_ in pairs(eachRule._activeTargets or {}) do
      local setters = eachRule.connectionSetters and (eachRule.connectionSetters[1] and eachRule.connectionSetters or {eachRule.connectionSetters}) or {}
      for _,eachSetter in ipairs(setters) do
          local getConect = eachSetter.connectsTo == "GET" and tryCall(eachSetter.getConnections,{color = effectedColor}) or false
        local connections = getConect and (type(getConect) == "table" and getConect or {getConect}) or (type(eachSetter.connectsTo) == "table" and eachSetter.connectsTo or {eachSetter.connectsTo}) or {}
          local getSystems = eachSetter.systems == "GET" and tryCall(eachSetter.getSystems,{color = effectedColor}) or false
        local systems = getSystems and (type(getSystems) == "table" and getSystems or {getSystems}) or (type(eachSetter.systems) == "table" and eachSetter.systems or {eachSetter.systems}) or {}
        for _,eachConnection in ipairs(connections) do
          if CONNECTIONS._activeConnections[effectedColor] and CONNECTIONS._activeConnections[effectedColor].connections[eachConnection] then
            CONNECTIONS._activeConnections[effectedColor].connections[eachConnection].systems = CONNECTIONS._activeConnections[effectedColor].connections[eachConnection].systems or {}
            for _,eachSystem in ipairs(systems) do
              CONNECTIONS._activeConnections[effectedColor].connections[eachConnection].systems[eachSystem] = true
            end
          end
        end
      end
    end
  end

  --Create resulting _systemConectivity table
  for eachColor,data in pairs(CONNECTIONS._activeConnections) do
    CONNECTIONS._systemConectivity[eachColor] = {}
    for name,eachConnection in pairs(data.connections or {}) do
      for eachGUID,_ in pairs(eachConnection.systems or {}) do
        CONNECTIONS._systemConectivity[eachColor][eachGUID] = CONNECTIONS._systemConectivity[eachColor][eachGUID] or {}
        for eachConectsTo,_ in pairs(eachConnection.connectsTo or {}) do
          CONNECTIONS._systemConectivity[eachColor][eachGUID][eachConectsTo] = true
          --table fomrat: CONNECTIONS._systemConectivity = { [color] = { [guid_1] = {[alpha] = true, [beta] = true},...}}
        end
      end
    end
  end
end

CONNECTIONS.getRuleTargets = function()
  local function getTargetsFromGet(rule, source)
    local result = tryCall(source.getTarget) or {}
    return type(result) == "table" and result or {result}
  end

  local function getTargetsFromOwner(rule, source)
    local targets = {}
    --if an ability obj is in a player zone, add that player to targets
    for _,eachObj in ipairs(source._activeObjects or {}) do
      local zoneColor = _zoneHelper.zoneFromPosition(eachObj.getPosition())
      if zoneColor then table.insert(targets, zoneColor) end
    end
    --if a faction has the specified ability, add that player to targets
    for eachCol,bool in pairs(source._activeAbilityOwners or {}) do
      table.insert(targets, eachCol)
    end

    return targets
  end

  local function getTargetsFromOther(rule, source)
    local allCols = _zoneHelper.zones()
    local targets = {}
    local function addOthers(excludeCol)
      for _,each in ipairs(allCols) do
        if each ~= excludeCol then
          table.insert(targets, each)
        end
      end
    end

    --if an ability obj is in a player zone, add other players to targets
    for _,eachObj in ipairs(source._activeObjects or {}) do
      local zoneColor = _zoneHelper.zoneFromPosition(eachObj.getPosition())
      if zoneColor then addOthers(zoneColor) end
    end
    --if a faction has the specified ability, add other players to targets
    for eachCol,bool in pairs(source._activeAbilityOwners or {}) do
      addOthers(eachCol)
    end

    return targets
  end

  local function getTargetsFromAll(rule, source)
    return _zoneHelper.zones()
  end

  local switch = {
    ["GET"] = getTargetsFromGet,
    ["OWNER"] = getTargetsFromOwner,
    ["OTHER"] = getTargetsFromOther,
    ["ALL"] = getTargetsFromAll,
    ["catch"] = function(rule, source)
      local errMsg = { val = source.targetType or "nil", rule = rule.id or "nil"}
      error("Caught bad value >"..errMsg.val.."< for targetType in a source for connectionRule >"..errMsg.rule.."<")
      return
    end
  }

  --Sets ._activeTargets of each rule to a table of colors that are effected by that rule
  for _,eachRule in pairs(connectionRules) do
    eachRule._activeTargets = {}
    -- .sources may be a table(single source) or tabel of tables(multiple sources). Convert to table of tables
    local sources = eachRule.sources[1] and eachRule.sources or {eachRule.sources}
    for _,eachSource in ipairs(sources) do
      if eachSource.isActive then
        local try = switch[eachSource.targetType] and eachSource.targetType or "catch"
        local result = switch[try](eachRule, eachSource) or {}
        for _,eachCol in ipairs(result) do
          eachRule._activeTargets[eachCol] = true
        end
      end
    end
  end
end

CONNECTIONS.getActiveSources = function()
  local objectsToFind_name = {}
  local objectsToFind_GUID = {}
  local abilitiesToFind = {}
  for _,eachRule in pairs(connectionRules) do
    eachRule._activeTargets = {}
    -- .sources may be a table(single source) or tabel of tables(multiple sources). Convert to table of tables
    local sources = eachRule.sources[1] and eachRule.sources or {eachRule.sources}
    for _,eachSource in ipairs(sources) do
      eachSource.isActive = eachSource.isUniversalRule or false
      eachSource._activeObjects = false
      eachSource._activeAbilityOwners = false

      if eachSource.refs then
        if eachSource.refs.GET then
          eachSource.isActive = tryCall(eachSource.refs.GET) or false
        else --gather faction abilities and objects to find in bulk
          for _,each in ipairs(eachSource.refs.FACTION_ABILITIES or {}) do
            abilitiesToFind[each] = abilitiesToFind[each] or {}
            table.insert(abilitiesToFind[each], eachSource)
          end
          for _,each in ipairs(eachSource.refs.OBJECTS or {}) do
            local findByName = type(each) == "string" or each.name or false
            local key = type(each) == "string" and each or each.name or each.guid
            if findByName then
              objectsToFind_name[key] = objectsToFind_name[key] or {}
              table.insert(objectsToFind_name[key],
                {source = eachSource,
                requireFaceup = type(each) == "table" and each.requireFaceup,
                requireActive = type(each) == "table" and each.requireActive,
                isDiscardable = type(each) == "table" and each.isDiscardable,
                })
            else
              objectsToFind_GUID[key] = objectsToFind_GUID[key] or {}
              table.insert(objectsToFind_GUID[key],
                {source = eachSource,
                requireFaceup = type(each) == "table" and each.requireFaceup,
                requireActive = type(each) == "table" and each.requireActive,
                isDiscardable = type(each) == "table" and each.isDiscardable,
                })
            end
          end
        end
      end
    end
  end

  local factionsInPlay = _factionHelper.allFactions()
  for _,eachFaction in pairs(factionsInPlay) do
    for _,eachAbility in ipairs(eachFaction.abilities) do
      for _,eachSource in ipairs(abilitiesToFind[eachAbility] or {}) do
        eachSource.isActive = true
        eachSource._activeAbilityOwners = eachSource._activeAbilityOwners or {}
        eachSource._activeAbilityOwners[eachFaction.color] = true
      end
    end
  end

  for _,eachObj in ipairs(getAllObjects()) do
    local objName = eachObj.getName()
    local objGUID = eachObj.getGUID()

    local mergedResults = objectsToFind_name[objName] or {}
    local foundGUID = objectsToFind_GUID[objGUID] or {}
    for _,each in ipairs(foundGUID) do
      table.insert(mergedResults, each)
    end
    for _,eachResult in ipairs(mergedResults) do
      if (not eachResult.requireFaceup or not eachObj.is_face_down)
        and (not eachResult.requireActive or not _unitHelper._isToggleActiveCard(eachObj) or _unitHelper._isToggleActiveCardActive(eachObj))
        and (not eachResult.isDiscardable or not _deckHelper.isDiscard(objGUID))
        then
        eachResult.source.isActive = true
        eachResult.source._activeObjects = eachResult.source._activeObjects or {}
        table.insert(eachResult.source._activeObjects, eachObj)
      end
    end
  end
end

CONNECTIONS._printedWormholesThisFrame = false
CONNECTIONS.getPrintedWormholeSystems = function(returnSpecific)
  if CONNECTIONS._printedWormholesThisFrame then return CONNECTIONS._printedWormholesThisFrame.systems end
  CONNECTIONS._printedWormholesThisFrame = { systems = {}, wait = Wait.frames(function() CONNECTIONS._printedWormholesThisFrame = false end, 1)}
  for guid,eachSystem in pairs(_systems) do
    local wormholes = eachSystem.wormholes or {}
    if eachSystem.wormholes_faceUp then
      local systemObj = getObjectFromGUID(eachSystem.guid)
      wormholes = systemObj ~= nil and (systemObj.is_face_down and eachSystem.wormholes_faceDown) or eachSystem.wormholes_faceUp
    end
    for _,eachWormhole in ipairs(wormholes) do
      CONNECTIONS._printedWormholesThisFrame.systems[eachWormhole] = CONNECTIONS._printedWormholesThisFrame.systems[eachWormhole] or {}
      table.insert(CONNECTIONS._printedWormholesThisFrame.systems[eachWormhole], guid)
    end
  end
  if returnSpecific then
    return CONNECTIONS._printedWormholesThisFrame.systems[returnSpecific]
  end
  return CONNECTIONS._printedWormholesThisFrame.systems
end

-------------------------------------------------------------------------------

local _activatedSystem = false
local _lastActivatedSystem = false  -- rememeber even when turn changes

--- Get the currently activated system.
-- Objects may declare an 'onSystemActivation(system)' called on activation.
function getActivatedSystem()
    return _activatedSystem
end

function getLastActivatedSystem()
    return _lastActivatedSystem
end

-------------------------------------------------------------------------------

function _moveTokenFromReinforcements(systemObject, colors)
    assert(type(systemObject) == 'userdata' and type(colors) == 'table')
    local bagNameSet = {}
    for _, color in ipairs(colors) do
        local faction = _factionHelper.fromColor(color)
        if faction then
            bagNameSet[faction.tokenName .. ' Command Tokens Bag'] = true
        end
    end
    local bags = {}
    for _, object in ipairs(getAllObjects()) do
        if object.tag == 'Bag' and bagNameSet[object.getName()] then
            table.insert(bags, object)
        end
    end
    local r = 1
    local p0 = systemObject.getPosition()
    local success = true
    for i, bag in ipairs(bags) do
        local phi = math.rad(360 * i / #bags)
        if bag.getQuantity() > 0 then
            bag.takeObject({
                position = {
                    x = p0.x + math.cos(phi) * r,
                    y = p0.y + 3 + i * 0.2,
                    z= p0.z + math.sin(phi) * r,
                },
                rotation = {
                    x = 0,
                    y = -math.deg(phi),
                    z = 0
                },
                smooth = true,
            })
        else
            broadcastToAll(bag.getName() .. ' empty, please assign token manually', 'Red')
            success = false
        end
    end
    return success
end

function _moveTokenFromCommandSheet(systemObject, color, section)
    assert(type(systemObject) == 'userdata' and type(color) == 'string' and type(section) == 'string')
    local faction = _factionHelper.fromColor(color)
    local commandSheet = faction and getObjectFromGUID(faction.commandSheetGuid)
    local commandTokenName = faction and faction.tokenName .. ' Command Token'
    local function isToken(commandToken)
        local p = commandSheet.positionToLocal(commandToken.getPosition())
        local dSq = p.x * p.x + p.z * p.z
        if dSq > 15 then
            return false
        end
        local degrees = (math.deg(math.atan2(p.z, p.x)) + 360) % 360
        if section == 'tactics' and 300 > degrees and degrees > 240 then
            return true
        elseif section == 'fleet' and 240 > degrees and degrees > 180 then
            return true
        elseif section == 'strategy' and 180 > degrees and degrees > 120 then
            return true
        end
    end
    local commandToken = false
    if commandSheet and commandTokenName then
        for _, object in ipairs(getAllObjects()) do
            if object.getName() == commandTokenName and isToken(object) then
                commandToken = object
                break
            end
        end
    end
    local success = true
    if commandToken then
        -- Off-center, near the tile number.
        local p0 = systemObject.positionToWorld({
            x = 1.8,
            y = 0,
            z = 0
        })
        local position = {
            x = p0.x,
            y = p0.y + 3,
            z = p0.z
        }
        local collide = false
        local fast = false
        commandToken.setPositionSmooth(position, collide, fast)

        -- Rotate if a stack.
        local hits = Physics.cast({
            origin = { x = p0.x, y = p0.y, z = p0.z },
            direction = { x = 0, y = -1, z = 0 },
            type = 3, -- box
            size = { 0.1, 5, 0.1 }
        })
        local count = 0
        for _, hit in ipairs(hits) do
            local hitName = hit.hit_object.getName()
            if string.match(hitName, 'Command Token$') then
                count = count + 1
            end
        end
        local rotation = {
            x = 0,
            y = (count * 20) % 360,
            z = 0
        }
        commandToken.setRotationSmooth(rotation, collide, fast)
    else
        broadcastToAll(color .. ' ' .. section .. ' pool is empty', 'Red')
        success = false
    end
    return success
end

function _moveOwnerToken(systemObject, color)
    assert(type(systemObject) == 'userdata' and type(color) == 'string')
    local faction = _factionHelper.fromColor(color)
    local ownerTokensBagName = faction and faction.tokenName .. ' Owner Tokens Bag'
    local ownerTokensBag = false
    if ownerTokensBagName then
        for _, object in ipairs(getAllObjects()) do
            if object.tag == 'Infinite' and object.getName() == ownerTokensBagName then
                ownerTokensBag = object
                break
            end
        end
    end
    if ownerTokensBag then
        -- Off-center, near the tile number.
        local p0 = systemObject.positionToWorld({
            x = 1.8,
            y = 0,
            z = 0
        })
        ownerTokensBag.takeObject({
            position = {
                x = p0.x,
                y = p0.y + 3,
                z = p0.z
            },
            smooth = true
        })
    end
end

function onClickDiplomacySystem(clickerColor, systemObject)
    assert(type(clickerColor) == 'string' and type(systemObject) == 'userdata')
    local system = systemFromGuid(systemObject.getGUID())
    printToAll(clickerColor .. ' applying Diplomacy to ' .. system.string)
    local colors = {}
    for _, faction in pairs(_factionHelper.allFactions()) do
        if faction.color ~= clickerColor then
            table.insert(colors, faction.color)
        end
    end
    _moveTokenFromReinforcements(systemObject, colors)
end

function onClickActivateSystem(clickerColor, systemObject)
    assert(type(clickerColor) == 'string' and type(systemObject) == 'userdata')
    local system = systemFromGuid(systemObject.getGUID())
    -- No need to announce, _activateSystem will do that.
    if (not Turns.enable) or Turns.turn_color ~= clickerColor then
        printToColor('Activate system: ' .. clickerColor .. ' is not the active player, ignoring', clickerColor, 'Red')
        return
    end
    if _moveTokenFromCommandSheet(systemObject, clickerColor, 'tactics') then
        _activateSystem(clickerColor, system)
    end
end

function onClickStrategyToken(clickerColor, systemObject)
    assert(type(clickerColor) == 'string' and type(systemObject) == 'userdata')
    local system = systemFromGuid(systemObject.getGUID())
    if _moveTokenFromCommandSheet(systemObject, clickerColor, 'strategy') then
        printToAll(clickerColor .. ' placing command token from strategy in ' .. system.string)
    end
end

function onClickReinforcementsToken(clickerColor, systemObject)
    assert(type(clickerColor) == 'string' and type(systemObject) == 'userdata')
    local system = systemFromGuid(systemObject.getGUID())
    if _moveTokenFromReinforcements(systemObject, { clickerColor }) then
        printToAll(clickerColor .. ' placing command token from reinforcements in ' .. system.string)
    end
end

function onClickOwnerToken(clickerColor, systemObject)
    assert(type(clickerColor) == 'string' and type(systemObject) == 'userdata')
    local system = systemFromGuid(systemObject.getGUID())
    _moveOwnerToken(systemObject, clickerColor)
    printToAll(clickerColor .. ' placing owner token in ' .. system.string)
end

function _addContextMenuItems(systemObject)
    assert(type(systemObject) == 'userdata')
    assert(_systems[systemObject.getGUID()])
    systemObject.addContextMenuItem('Activate System', function(clickerColor) onClickActivateSystem(clickerColor, systemObject) end, false)
    systemObject.addContextMenuItem('Owner Token', function(clickerColor) onClickOwnerToken(clickerColor, systemObject) end, false)
    systemObject.addContextMenuItem('Strategy Token', function(clickerColor) onClickStrategyToken(clickerColor, systemObject) end, false)
    systemObject.addContextMenuItem('Reinforcements Tkn', function(clickerColor) onClickReinforcementsToken(clickerColor, systemObject) end, false)
    systemObject.addContextMenuItem('Diplomacy System', function(clickerColor) onClickDiplomacySystem(clickerColor, systemObject) end, false)
end

function onObjectSpawn(object)
    if _systems[object.getGUID()] and not _systems[object.getGUID()].hyperlane then
        _addContextMenuItems(object)
    end
end

-------------------------------------------------------------------------------

function onLoad(saveState)
    self.setColorTint({ r = 0.25, g = 0.25, b = 0.25 })
    self.setScale({ x = 2, y = 0.01, z = 2 })
    self.setName('TI4_SYSTEM_HELPER')
    self.setDescription('Shared helper functions used by other objects, PLEASE LEAVE ON TABLE! This object is only visible to the black (GM) player.')

    self.addContextMenuItem('Verify', verifyAllSystems)

    -- Not for full releases, exists for map builders who want to find tiles easily.
    self.addContextMenuItem('Rename Tiles', function() startLuaCoroutine(self, '_renameSystemTilesCoroutine') end)

    -- Only the GM/black player can see this object.  Others can still interact!
    local invisibleTo = {}
    for _, color in ipairs(Player.getColors()) do
        if color ~= 'Black' then
            table.insert(invisibleTo, color)
        end
    end
    self.setInvisibleTo(invisibleTo)

    local function delayedAddContextMenuItems()
        for _, object in ipairs(getAllObjects()) do
            if _systems[object.getGUID()] then
                _addContextMenuItems(object)
            end
        end
    end
    Wait.frames(delayedAddContextMenuItems, 9)
end

function onPlayerTurnEnd(player_color_end, player_color_next)
    _activatedSystem = false
end

function onObjectDrop(playerColor, object)
    if playerColor ~= Turns.turn_color then
        return
    end

    local tokenName = string.match(object.getName(), '^(.*) Command Token')
    if not tokenName then
        return
    end

    -- In addition to "FACTION Command Token" accept "COLOR Command Token".
    local faction = _factionHelper.fromTokenName(tokenName)
    local matchesFaction = faction and faction.color == playerColor
    local matchesColor = tokenName == playerColor
    if (not matchesFaction) and (not matchesColor) then
        return
    end

    local system = systemFromPosition(object.getPosition())
    if not system then
        return
    end

    _activateSystem(playerColor, system)
end

function _activateSystem(playerColor, system)
    assert(type(playerColor) == 'string' and type(system) == 'table')

    _fillMissingSystemData(system.guid, system)

    _activatedSystem = system
    _lastActivatedSystem = system

    local faction = _factionHelper.fromColor(playerColor)
    local factionName = (faction and faction.name) or playerColor
    broadcastToAll(factionName .. ' activated ' .. system.string, playerColor)
    local systemObject = getObjectFromGUID(system.guid)
    systemObject.highlightOn(playerColor, 30)

    -- Tell any interested parties.
    local reportTo = {}
    for _, object in ipairs(getAllObjects()) do
        if object.getVar('onSystemActivation') then
            table.insert(reportTo, object)
        end
    end
    for i, object in ipairs(reportTo) do
        -- Wrap each in a separate 'Wait' instance so if one fails the rest go ahead.
        -- Since that is happening, also spread out over N frames.
        Wait.frames(function() object.call('onSystemActivation', system) end, i)
    end
end

-------------------------------------------------------------------------------

function _renameSystemTilesCoroutine()
    local bagAndGuidEntries = {} -- allow multiple copies of a tile in different bags
    for _, object in ipairs(getAllObjects()) do
        if _systems[object.getGUID()] then
            table.insert(bagAndGuidEntries, { bag = false, guid = object.getGUID() })
        elseif object.tag == 'Bag' then
            for _, entry in ipairs(object.getObjects()) do
                if _systems[entry.guid] then
                    table.insert(bagAndGuidEntries, { bag = object, guid = entry.guid })
                end
            end
        end
    end
    coroutine.yield(0)
    for i, bagAndGuidEntry in ipairs(bagAndGuidEntries) do
        local bag = bagAndGuidEntry.bag
        local guid = assert(bagAndGuidEntry.guid)
        local system = assert(_systems[guid])
        local name = _systemToString(system)
        local object = false
        if bag then
            local pos = bag.getPosition()
            object = bag.takeObject({
                guid = guid,
                position = { x = pos.x, y = pos.y + 5 + i * 0.3, z = pos.z }
            })
            while object.spawning do
                coroutine.yield(0)
            end
            coroutine.yield(0)
        else
            object = getObjectFromGUID(guid)
        end
        assert(object)
        object.setRotation({ x = 0, y = 180, z = 0 })
        object.use_hands = true
        if string.len(object.getName()) == 0 then
            object.setName(name)
        end
        if bag then
            bag.putObject(object)
            for _ = 1, 20 do
                coroutine.yield(0)
            end
        end
        coroutine.yield(0)
    end
    return 1
end

-------------------------------------------------------------------------------

function tryCall(callData, params)
  local function try()
    assert(callData and type(callData) == "table")
    assert(callData.obj ~= nil and type(callData.obj) == "userdata")
    assert(callData.func and type(callData.func) == "string" and callData.obj.getVar(callData.func), 'missing ' .. callData.obj.getName() .. '.' .. callData.func)
    local passParams = params == nil and {} or type(params) == "table" and params or {params}
    local dataParams = callData.params == nil and {} or type(callData.params) == "table" and callData.params or {callData.params}
    local mergedParams = {} --params will overide callData.params values that have the same key
    for k,v in pairs(dataParams) do mergedParams[k] = v end
    for k, v in pairs(passParams) do
      if type(k) == "number" then table.insert(mergedParams, v)
      else mergedParams[k] = v
      end
    end
    return callData.obj.call(callData.func, mergedParams)
  end
  local success, result = pcall(try)
  if not success then print("Failed callback: callData incorrectly formated. ", result) return end
  return result
end

function printTable(table)
  if not table or type(table) ~= 'table' then print("Error: printTable() requires a table param.") return end
  if not next(table) then print("Empty") end

  local function typeToPrintable(input)
   if input == nil then return "nil" end
   if type(input) == "string" and input == "" then return '""' end
   if type(input) == 'boolean' then return input and "true" or "false" end
   if type(input) == 'userdata' then return "userData" end
   return input
  end

  local function pt(_table, depth)
    local string = ""
    for i = 1, depth, 1 do
      string = string .. "-"
    end

    for k,v in pairs(_table) do
      local keyString = typeToPrintable(k)
      if type(v) == "table" then
        local tableString = string .. keyString .. " = {"
        if not next(v) then tableString = tableString .. "}" end
        print(tableString)
        pt(v, depth + 1)
        print(string .. "}")
      else
        print(string .. keyString .. ": " .. typeToPrintable(v))
      end
    end
  end

  print("______________")
  pt(table, 0)
end

-------------------------------------------------------------------------------
-- Index is only called when the key does not already exist.
local _lockGlobalsMetaTable = {}
function _lockGlobalsMetaTable.__index(table, key)
    error('Accessing missing global "' .. tostring(key or '<nil>') .. '", typo?', 2)
end
function _lockGlobalsMetaTable.__newindex(table, key, value)
    error('Globals are locked, cannot create global variable "' .. tostring(key or '<nil>') .. '"', 2)
end
setmetatable(_G, _lockGlobalsMetaTable)