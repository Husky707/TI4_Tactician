--_WARNING!! [ctrl] + [k] + [1] to collapse tables or suffer scrolling through xml tables! (atom editor)

function getHelperClient(helperObjectName)
    local helperObject = Global.call('getHelper', helperObjectName)
    local function getCallWrapper(functionName)
        helperObject = helperObject or getHelperObject()
        if not helperObject.getVar(functionName) then error('missing ' .. helperObjectName .. '.' .. functionName) end
        return function(parameters) return helperObject.call(functionName, parameters) end
    end
    return setmetatable({}, { __index = function(t, k) return getCallWrapper(k) end })
end

local _factionHelper = getHelperClient('TI4_FACTION_HELPER')
local _zoneHelper = getHelperClient('TI4_ZONE_HELPER')
local _systemHelper = getHelperClient('TI4_SYSTEM_HELPER')
local _unitHelper = getHelperClient('TI4_UNIT_HELPER')

--Data containers-----------------------------
local _cmdToken = { --handels the floating command token object/animations
  --*obj = nil, --runtime only
  --activeColor = color of player that last activated -- runtimeOnly
  guid = false,
  diffuse = "http://cloud-3.steamusercontent.com/ugc/2013722609377867963/0E05B3E0F2109C3779C15989F135C7D55AD0E490/",
  data = {
    Nickname = "Auto-roller Command Token",
    Description = "Drag & Drop me to activate a system, flip me to change who is activating",
    Tooltip = true,
    Grid = false,
    Snap = false,
    DragSelectable = false,
    Sticky = false,
    Hands = false,
    AttachedDecals = {},
  },
  posOffset = {x = 1.117, y = 0.3, z = -1.875},
  scaleRatio = 1.4/3.45, --Command Token scale to Tactician scale --Maintain ratio when tactician is scaled

  canAnimate = false,
  animator = false,
  tracking = false,
  use_gravity = false,
  dropTokens = {},
}
local debugCoroutines = true
local Coru = {
 _coroutines = {},
 _coRunner = false,
 _coQueue = {},
 _coKillQueue = {},
 step = {
   ["running"] = function() end,
   ["normal"] = function() end,
   ["suspended"] = function(eachCo, callbackData)
     local status, result = coroutine.resume(eachCo)
     if not status then
       print("Coroutine error: ", result)
       if callbackData and callbackData.callback then callbackData.callback(result) end
       return -1
     else
       if callbackData and callbackData.yieldback then callbackData.yieldback(result) end
     end
   end,
   ["dead"] = function(eachCo, callbackData)
     if callbackData and callbackData.callback then callbackData.callback(1) end
     return -1
   end,
   ["catch"] = function(eachCo, callbackData, badState)
     print("Caught a bad coru state: ", badState)
     if callbackData and callbackData.callback then callbackData.callback(-1) end
     return -1
    end
 },
}
local Tween = {}
local Animate = {}
local AnimClip = {}
local ToggleButton = {}
local MultiRoller = {} --logic responible for responding to roll requests
local Invasion = {} --Handles the more complex invasion UI
local Planets = { --Handles the planet UI, closely connected to Invasion
  layouts = { --planet count to transforms
    [0] = {},
    [1] = {{x = 0, y = 85, scale = 1.4}},
    [2] = {{x = -116, y = 235, scale = 1}, {x = 206, y = -184, scale = 1}},
    [3] = {{x = -282, y = -31, scale = 1}, {x = 132.4, y = 293, scale = 0.9375}, {x = 242, y = -210, scale = 0.9375}},
    [4] = {{x = -149, y = 290, scale = 0.875}, {x = 271, y = 106, scale = 0.775}, {x = 204, y = -300, scale = 0.85}, {x = -294, y = -148, scale = 0.9375}},
    [5] = {{x = -141, y = 344, scale = 0.775}, {x = 244, y = 210, scale = 0.675}, {x = 343, y = -143, scale = 0.775}, {x = 0, y = -53, scale = 0.85}, {x = -302, y = -53, scale = 0.975}}, --Max of 5 planets supported (Xulltron + Ivan in 3p system)
  },
  focusLayouts = {
    [1] = {{x = 0, y = -470, scale = 2.3}},--Transform of FOCUS planet
    [2] = {{x = 0, y = 326, scale = 0.975}},
    [3] = {{x = -187, y = 230, scale = 0.775}, {x = 206, y = 347, scale = 0.7}},
    [4] = {{x = -228, y = 224, scale = 0.54}, {x = 0, y = 443, scale = 0.5875}, {x = 228, y = 224, scale = 0.5875}},
    [5] = {{x = 276, y = 323, scale = 0.5875}, {x = 0, y = 476, scale = 0.5875}, {x = -276, y = 323, scale = 0.5875}, {x = 0, y = 186, scale = 0.54}}, --Max of 5 planets supported (Xulltron + Ivan in 3p system)
  },
  traits = {
    data = { offset = 16, focusOffset = 42},
    ["industrial"] = "Icon_Industrial",
    ["cultural"] = "Icon_Cultural",
    ["hazardous"] = "Icon_Hazardous"
  },
  --focus = { scale = 2, pos = "0 0", traitOffset = {x = 0, y = 10}},
  animationData = {},

  defaults = {
    traitOffset = {x = 0, y = 0},
    scale = 1,
  },

  --
  plasmaTarget = false,
  _displayedSystem = false
}

--The core logic/state machine for the Tactician
local Tac = {
  disableAnimations = false,
  rollForMe = {["White"] = true, ["Pink"] = true, ["Red"] = true, ["Blue"] = true, ["Green"] = true, ["Yellow"] = true, ["Orange"] = true, ["Purple"] = true, ["Grey"] = false, ["Black"] = false, ["Teal"] = false, ["Brown"] = true},
  highlightAdjSystems = {}, --[color] = true

  isActionPhase = false,
  color = "Black",
  previousState = "Uninitialized",
  State = "Initializing",
  inStateTransition = false, --or State
  _onStateOpen = false,
  eStates = {
    Initializing = function() return "Initializing" end,
    Main = function() return "Main" end,
    Turns = function() return "Turns" end,
    Movement = function() return "Movement" end,
    SpaceCombat = function() return "SpaceCombat" end,
    Invasion = function() return "Invasion" end,
  },
  eGameEvents = {
    ["NewActivePlayer"] = function() return "NewActivePlayer" end,
    ["StartActionPhase"] = function() return "StartActionPhase" end,
    ["EndActionPhase"] = function() return "EndActionPhase" end,
    ["PlayerTurnStart"] = function() return "PlayerTurnStart" end,
    ["SystemActivated"] = function() return "SystemActivated" end,
    ["PlayerPassed"] = function() return "PlayerPassed" end,
    ["TacStepBtnClicked"] = function() return "TacStepBtnClicked" end,
    ["UnitMapUpdated"] = function() return "UnitMapUpdated" end
  },
}

--Data table passed to unit modifiers
local TacData = {
  --activePlayer = "color",
  --activeSystem = {hex = activeHex, system = system},
  --adjacentSystems
  --unitMap
  --hexToUnits
  --initialized
}

--FINAL_WARNING!! [ctrl] + [k] + [1] to collapse tables or suffer scrolling through xml tables!
local ui = {
  assets = {
    --FONT
    {
      type = 1,
      name = "TI4_Fonts",
      url = "http://cloud-3.steamusercontent.com/ugc/1838056330496306579/02322986579B5ECCC96723A6031D1B71826CBE3B/"
    },
    {
      name = "Background_Empty",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445386/2E9974D51FDB94CD00B88FE30D1949473738B86C/"
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998417342035/B6D2EFB52B0786D073D0D7D799E5364DDE3427F3/"--Token/HEX
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445459/B53F7180834F5681609A2F779E1C09B965839566/"--Buttons
    },
    {
      name = "Background_Fill",
      url = "http://cloud-3.steamusercontent.com/ugc/2164602992656627046/EC5F8D1F7170F1EDF29D6FAED0E004A5A05E3E9C/"
    },
    { name = "ZoneCover_Red",
      url = "http://cloud-3.steamusercontent.com/ugc/2187121345779668056/61B18C31220576699999E0C0030FE398A2B6310B/"
    },
    { name = "ZoneCover_Blue",
      url = "http://cloud-3.steamusercontent.com/ugc/2187121345779667947/FAD1134751CAD72CF084DFFC7CD1F9ADF439F83B/"
    },
    { name = "ZoneCover_Green",
      url = "http://cloud-3.steamusercontent.com/ugc/2187121345779667998/0B0315CC68384A022766465BC8BA3C7EDE9EB725/"
    },
    { name = "ZoneBackground_Blue",
      url = "http://cloud-3.steamusercontent.com/ugc/2164602709725365811/01C6300A371762CEE3A9600D09A14FB8B55D582F/"
    },
    { name = "ZoneBackground_Red",
      url = "http://cloud-3.steamusercontent.com/ugc/2164602709725336517/EAEA384C41355CA6A0409CFC94B708098AFDBBCD/"
    },
    { name = "HeaderCover",
      url = "http://cloud-3.steamusercontent.com/ugc/2164602709725551602/FD2E0EC4B30F11718F29277A6370E805D94D3081/"
    },

    --Turn Display-----------------------
    { name = "StrategyCard_Icon",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407446044/EA93AE12446EA9074EBE5F9603D9FC8E616491DC/",
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998407446006/8E3543C4396F8E83543E4F866E9745E7C3E57120/" --FontRef
    },
    { name = "Turns_PassedPlayer",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445964/EBA6A07722D0CD5BD6A19EC8E215ED213DC6402E/",
    },
    { name = "Turns_ActiveStrategy",
      url = "http://cloud-3.steamusercontent.com/ugc/2107180688382984408/8830EFD680A9B9A999643DF9EFF768D00C32F7B6/",
    },
    { name = "Turns_ActivePlayer",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445859/C525E6AB804963810B0D7E0A8AE49EAFFD423410/",
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445550/760850887ED0D58C41D4CCAC0D8CE11078CF1A3A/"--FontRef
    },
    { name = "Turns_NonactivePlayer",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445686/47A3DE7EA5599A1906153075D463688539AF1E7A/",
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445616/3A0B9D4056651D2AE9E85144BD9EB2D8672849FC/",--FontRef
    },
    { name = "Turns_NonactivePlayer_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445754/1EEE870F6C29E8792B8E0226C9CCFD42C402C814/",
    },
    { name = "Turns_NonactivePlayer_Pressed",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445805/F49E98F97DBA11A988C273C3158F41F5AD18016B/",
    },

    --Header--------------------
    { name = "Header",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444484/52E7AD8C2AE13786DD83150A485EF47FFAD3D57F/",
      --url = "http://cloud-3.steamusercontent.com/ugc/2107180546436243120/1039060BF1C2EF60E401270D0A41CFDFB868B957/"
    },
    { name = "Header_ActiveColor",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444543/F85F20095F15FA4B7F4AE834ECDF0DCFD1CF6544/",
    },
    { name = "Header_Subheader",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444591/CFE8FB5AF0C49DA2E9145DA3F639367C0F78ECFE/",
    },
    { name = "Header_Deco",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444443/AB60D9A36C0D90290EAD0974B2CAB564272D1D41/",
    },
    { name = "Header_Gradient",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444395/339D3632C67C7A77C91E88D98A391AE65A95420D/",
    },

    --Main buttons-------
    {--Generic button
      name = "Btn_Standard",
      url = "http://cloud-3.steamusercontent.com/ugc/2187121345765746441/DE13898426CB6D24AD4A8CD3EA3509854E3A28B1/",
    },
    { name = "Btn_NoTactical",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442759/46BA666A29229E7ECCFDC1E4F0B0504BC01EB0EC/",
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443349/AB97E1A6E7DE3FD15766AB88D8E383585CFF127C/"--fontRef
    },
    { name = "Btn_Blue",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442565/490A263AD69E9EF5663E470C8FDA9FAB17DDBF18/",
    },
    { name = "Btn_Blue_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442616/B0CCFE6C556E68AE24C41E4A78395AC8F38BD09A/",
    },
    { name = "Btn_Blue_Pressed",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442713/A2048F8CCC963A04D8090EB593DAD08BA4203955/",
    },
    { name = "Btn_Blue_Active",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442664/85D7526A5CC4A4FB28BDF3FCAA89454A64FF5C61/",
    },
    { name = "Btn_Red",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443162/838B972073CB88972185033E3E58BFBB570B383D/",
    },
    { name = "Btn_Red_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443205/9588A96897ABD7E8D165F143660063555734AED8/",
    },
    { name = "Btn_Red_Pressed",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443302/185020F274E7D7424294FF25A6C67271557F6155/",
    },
    { name = "Btn_Red_Active",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443253/DECCCE0960E47CA7491830531849F4E7C3B6B090/",
    },
    { name = "Btn_Green",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442336/C3669AAD7213231555A14002FCC866CBE14CF635/",
    },
    { name = "Btn_Green_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442398/07B9BB3952B4816A8E33E7F0E02FF0B18558A1CB/",
    },
    { name = "Btn_Green_Pressed",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442506/66EB1B076752D18CF4CF58202A87F030710C4749/",
    },
    { name = "Btn_Green_Active",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442451/4157ED0BB167AFC805726FC45173630DFBB99682/",
    },

    --Icons
    { name = "Icon_CombatCounter",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445273/7970410DE8CD5062B8DAC5B02D2C47EBF33D48FF/",
    },
    { name = "Icon_CombatCounter_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445209/1C90414895551D70E5A9EAF721D74FBFC4D8FE5B/",
    },
    { name = "Icon_CombatCounter_On",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445327/D28BB86998627363C90996F29FDCE32B10CC3880/",
    },
    { name = "Icon_Agenda",
      url = "http://cloud-3.steamusercontent.com/ugc/2107180688382556638/5E08E51D538D3D774B53FAA68DBED4BADD6D6313/",
    },
    { name = "Icon_Attacker",
      url = "http://cloud-3.steamusercontent.com/ugc/2187121345774821831/0C9E3EF33129BA157619141A06E021FC21CB9762/"
    },
    { name = "Icon_Defender",
      url = "http://cloud-3.steamusercontent.com/ugc/2187121345774803100/6D44217F542F677D422011941D0399B16C032882/"
    },
    { name = "Icon_Cultural",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767516136796/AC1E9F3C948AC16DE55D87200EFB8537BBD9F949/"
    },
    { name = "Icon_Hazardous",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767516136837/4D1423652D72FB4BB4F92076C29E291353CAF51D/"
    },
    { name = "Icon_Industrial",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767516136878/91446D03D61201B3A91F73F22C7181D7EB4E3591/"
    },

    --SmartButtons
    { name = "BtnOutline_SmartAttack",
      url = "http://cloud-3.steamusercontent.com/ugc/2270441745051813841/BC88343D2BB29FF450510DD659DC372527554C37/"
    },
    { name = "BtnOutline_SmartDefend",
      url = "http://cloud-3.steamusercontent.com/ugc/2270441745051813897/1321698E66376C56F5B1D92BBCDDF2481163E798/"
    },
    { name = "Btn_SmartAttack",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442851/FFBB05A62AFA84598CE35C3F6BEAB7E0EDBE9E70/",
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442807/2CE4041F599F4FCF96899AA524A0E49875DFC135/" --iconRef
    },
    { name = "Btn_SmartAttack_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442899/80C4359F00CEA5E0C1E1C053FEA131471ABC1F48/",
    },
    { name = "Btn_SmartAttack_Pressed",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407442950/F4D14EF01E66018AA6588F9A93B6571C3F894C1C/",
    },
    { name = "Btn_SmartDefend",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443040/2FFDC64B5D692E3F5891F6996C568BB8F7D598B8/",
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443000/6A1227928B1F06ABE5BB7BBEE4298E85900E07C2/", --iconRef
    },
    { name = "Btn_SmartDefend_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443083/DCC1098EFDE2D3A4C37412D80DC4DA86ABDC921C/",
    },
    { name = "Btn_SmartDefend_Pressed",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443122/41DFD2B125DB5EA84B7F53E790F8B28E43DBD5B8/",
    },
    { name = "Btn_SmartSubstep",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443827/54154DEF81F6F7F16402FDF722C18D6BC2CAA2B4/",
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443780/29E06F6953A017119AB41B15ACD21D0784DEFFA5/" --IconRef
    },
    { name = "Btn_SmartSubstep_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443883/5EE80A311DBEB16174901286AF25EB415262E0DA/",
    },
    { name = "Btn_SmartSubstep_Pressed",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443931/059CB527DDAD822B8E5B7300E3DAFC21A7F85858/",
    },

    --Invasion Substeps
    { name = "Btn_SpaceCannonDefMode",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444224/0C8EF6525F82B5D15A728B3AE4BF6F7830880A97/",
    },
    { name = "Btn_SpaceCannonDefMode_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444172/0FCC9269773E493286E88BA2C638914D6EAEDD6E/",
    },
    { name = "Btn_SpaceCannonDefMode_Pressed",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444272/22F8CF16751593430914B0EC95BEB1EE33C388CC/",
    },
    { name = "Btn_SpaceCannonDefMode_Active",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444105/4A18DA5209BEAE16B68D3E32E2994260F4F29FB1/",
    },
    { name = "Btn_SpaceCannonDefMode_Label",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444047/3C691C10A6D146C27EFB6B39CC43BE1F019A32B9/",
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443986/C8FAB11E9666DF99CA101AB034CDA7C62D1E5ED6/" --fontRef
    },
    { name = "Btn_InvasionSubstepHex",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443729/566E91457C01400A1654A351E2317AAC460D5114/",
    },
    { name = "Btn_InvasionSubstepHex_Active",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443681/BED39A89DC708E8F1D96F02744FB0B160A3608E5/",
    },
    { name = "Btn_BombardMode",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443584/159FB5657CF17A68C09465232ABEF1D6BC793DD2/",
    },
    { name = "Btn_BombardMode_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443536/763BA9FA4C736FFED604E6181E504A0E495C12E6/",
    },
    { name = "Btn_BombardMode_Pressed",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443631/D7C6FBEF48CD7BBE8289C4E951846E471F1DD0A6/",
    },
    { name = "Btn_BombardMode_Active",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443488/C508E6D312272D09429B4039148A157C4C4B5078/",
    },
    { name = "Btn_BombardMode_Label",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443444/06437021BC6B063E0032678254B745EE0C960A82/",
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998407443394/71F074C2FB57D38CA77CBADC3F982574532F6281/" --fontRef
    },

    --Invasion Hex
    { name = "FooterFade",
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444323/3976267E81E457794AABFDC4CDFA74F3A09A7D29/",
      url = "http://cloud-3.steamusercontent.com/ugc/2164602709737570717/22E9A1CDDD4E046710D84488F5D40C57C48F3F22/"
    },
    { name = "InvHex_Background",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444901/9C0E7E37FF40024D695D76A64E021230C6838462/",
    },
    { name = "InvHex_Space",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444819/20F4103438FFD825EFCEC7487B5D7FBB733FB4F3/",
    },
    { name = "InvHex_Outline",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444727/1AD85D7A7A0730926E3065DEDD329399B1660DCF/",
    },
    { name = "InvHex_ActiveColor",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444641/3BE066E2BC953A14CD6008478B4CF044862B3027/",
    },
    { name = "InvHex_Anomaly",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444680/28F9B7105B0DEE0618E4220869D0786CFB5A28BF/",
    },
    { name = "FocusPlanet_Nameplate",
      url = "http://cloud-3.steamusercontent.com/ugc/2107179998407445105/DEAD25627320C035D774F33A51BA85E94F04FE74/",
      --url = "http://cloud-3.steamusercontent.com/ugc/2107179998407444982/F8769B192F10D96104BA9F11C7F87872EBBF59F3/", --fontRef
    },
    { name = "FocusPlanet_Banner",
      url = "http://cloud-3.steamusercontent.com/ugc/2270441745051765453/B68CB40584F23C63BDB4EA4223A0BE55AE9DC0EC/"
    },

    --Wire Planets
    { name = "Wired_Planet",
      url = "http://cloud-3.steamusercontent.com/ugc/2271565016354292047/9AE485B9548DA25BCD3196AE130A6A40CB969334/"
    },
    { name = "Wired_Highlight",
      url = "http://cloud-3.steamusercontent.com/ugc/2271565016354292587/A553A67AEF56BB75A19E820F14893D40F901A988/"
    },
    { name = "Wired_cultural",
      url = "http://cloud-3.steamusercontent.com/ugc/2271565016354292386/7AF97E0E108E4EDCC8C4B9A8F8CFD74F3D796D94/"
    },
    { name = "Wired_hazardous",
      url = "http://cloud-3.steamusercontent.com/ugc/2271565016354292482/8F03B4A8850B5023E0B85CF3223AABD8624BD431/"
    },
    { name = "Wired_industrial",
      url = "http://cloud-3.steamusercontent.com/ugc/2271565016354292662/FB2DE8A3054288FAAD8A452DD78C1943939FD3B8/"
    },
    { name = "Wired_legendary",
      url = "http://cloud-3.steamusercontent.com/ugc/2271565016354292738/47866FB42F14CFA2C664FF9D544A075316F723FE/"
    },
    { name = "Wired_Rex",
      url = "http://cloud-3.steamusercontent.com/ugc/2271565016354292808/27890D8936C0A986C0D7AD3C458BABE98006DA8F/"
    },
    { name = "Wired_Nameplate",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767516136920/6DBA8BDAEB29C113FE41C565A09CC33860158F0E/"
    },
    { name = "Wired_Color",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767508088929/75DAEBB23D442A074D47C814655E43EE06CBB635/"
    },
    { name = "Wired_Color_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2271565016354292879/A0C524DA8A4490F1D415B2923CE67649BF626E2D/"
    },
    { name = "Wired_Color_Pressed",
      url = "http://cloud-3.steamusercontent.com/ugc/2271565016354292994/CF29784C4136D424458467A42DF21C6C930690BB/"
    },

    --Planetary Shield
    { name = "Btn_PShield_NoOverride",
      url = "http://cloud-3.steamusercontent.com/ugc/2270441745051767873/B5454A5FD01B954A8370BA530292A7AEA18F3E9A/"
    },
    { name = "Btn_PShield_Disable",
      url = "http://cloud-3.steamusercontent.com/ugc/2270441745051767513/C8F1E989002BED717D5256B70D1AA6B37BB05AEA/"
    },
    { name = "Btn_PShield_Disable_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2270441745051767630/50C3B5DE3AA3A595146BCFE8BEA48C1A3923D8C5/"
    },
    { name = "Btn_PShield_Disable_Dark",
      url = "http://cloud-3.steamusercontent.com/ugc/2270441745051767570/D7D0C6A0683BDA003F630DCD0EAE3B08E54CB8A5/"
    },
    { name = "Btn_PShield_Enable",
      url = "http://cloud-3.steamusercontent.com/ugc/2270441745051767695/8A6967351DF27C0709483DD8365F9BAB2B997B62/"
    },
    { name = "Btn_PShield_Enable_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2270441745051767817/1836CABC5FA6FB57F51A5C99653681D2E5EE8148/"
    },
    { name = "Btn_PShield_Enable_Dark",
      url = "http://cloud-3.steamusercontent.com/ugc/2270441745051767754/97E1B8571740E9968B08E4259760DD55F282F9B6/"
    },
    { name = "PlanetaryShield_Enabled",
      url = "http://cloud-3.steamusercontent.com/ugc/2270441745051767986/80B165CCE4B8ECD81FFD35580527BC5A21A996B0/"
    },
    { name = "PlanetaryShield_Disabled",
      url = "http://cloud-3.steamusercontent.com/ugc/2270441745051767916/FFA636DEB1842C29862A47972BC697977EF74005/"
    },

    --Quick buttons
    { name = "QuickBtn_Bombardment",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767508088791/836A63FC747C2BBC5EBEB09E9CD047C5B9341ABD/"
    },
    { name = "QuickBtn_Bombardment_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767508088837/A6700136D94BFB28D630D78BC7E253D351397D12/"
    },
    { name = "QuickBtn_Bombardment_Pressed",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767508088876/44CB5E8CAD591DE7D241215972B14219A2C4FA55/"
    },
    { name = "QuickBtn_PDS",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767508089164/08210B91770A906F59EC6EF99ECFF1C41F24E43F/"
    },
    { name = "QuickBtn_PDS_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767508089209/F1169DEE62E059EC852318AD450318AE80BF6686/"
    },
    { name = "QuickBtn_PDS_Pressed",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767508089252/482A150732C5B0984A9D424F59076CAD2340D925/"
    },
    { name = "Icon_PlasmaScoring",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767508089347/8A0DEEA71C6F9A73CBA3AB952CA09B34B4BE5DA3/"
    },
    { name = "Icon_PlasmaScoring_Hover",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767508089390/5910B49EF23DF049D2711AA99F088A1BB0F7A829/"
    },
    { name = "Icon_PlasmaScoring_Active",
      url = "http://cloud-3.steamusercontent.com/ugc/2215269767508089297/3893F50610D697248A6170D854B8B9B5F7277264/"
    },
  },

  xmlTable = {
   { tag = "Panel",
    attributes = {
      id = "Root",
      width = 2048,
      height = 3200,
      rotation = "0 0 180",
      position = "0 0 -5.1",
      scale ="0.146 0.146 1"
    },
    children = {
      -------------------------------------------------------------
      { --Background [1]
        tag = "Image",
        attributes = {
          id = "Blackground",
          image = "Background_Empty",
        },
        children = {
          {--Cover gradiant
            tag = "Image",
            attributes = {
              id = "BackFill_Main",
              image = "Background_Fill",
              height = "50%",
              rectAlignment = "LowerCenter"
            }
          }
        }
      },
      {--Header [2]
        tag = "Panel",
        attributes = {
          id = "Pnl_Header",
          height = 660,
          rectAlignment = "UpperCenter",
        },
        children = {
          {--ProgressBar
            tag = "Image",
            attributes = {
              id = "Header_ColorProgress",
              image = "Header_ActiveColor",
              color = "Grey",--dynamic
              position = "0 0 -0.01",
            }
          },
          {--ProgressMask
            tag = "Image",
            attributes = {
              id = "Header_ProgressMask",
              color = "Pink",
              width = 6, --animates 6 -> 2030
              height = 380,
              offsetXY = "4 36",
              rectAlignment = "LowerLeft",

              active = false,
              animationDuration = 0.25,
              hideAnimation = "FadeOut",
            }
          },
          {--Subheader
            tag = "Image",
            attributes = {
              id = "Header_Subheader",
              image = "Header_Subheader",
              position = "0 0 -0.03",
            }
          },
          {--Main Image
            tag = "Image",
            attributes = {
              id = "Header",
              image = "Header",
            }
          },
          {--Gradient
            tag = "Image",
            attributes = {
              id = "Header_Gradient",
              image = "Header_Gradient",
              color = "Gray",
              position = "0 0 -0.05",
              hideAnimation = "FadeOut",
              animationDuration = 2,
            }
          },
          {--Gradient ColorTransition
            tag = "Image",
            attributes = {
              id = "Header_GradientTransition",
              image = "Header_Gradient",
              color = "Gray",
              position = "0 0 -0.05",
              showAnimation = "FadeIn",
              showAnimationDelay = 1.5,
              animationDuration = 1.5,
            }
          },
          {--Deco Lines
            tag = "Image",
            attributes = {
              id = "Header_Deco",
              image = "Header_Deco",
              color = "Gray",
              position = "0 0 -0.06",
              hideAnimation = "FadeOut",
              animationDuration = 2,
            }
          },
          {--Deco Lines Transition
            tag = "Image",
            attributes = {
              id = "Header_DecoTransition",
              image = "Header_Deco",
              color = "Gray",
              position = "0 0 -0.06",
              showAnimation = "FadeIn",
              showAnimationDelay = 1.5,
              animationDuration = 1.5,
            }
          },
          { --HeaderTxt
            tag = "Panel",
            attributes = {
              id = "TxtPnl_Header",
            },
            children = {
              {--Title Txt
                tag = "Text",
                attributes = {
                  id = "Txt_HeaderTitle",
                  font = "TI4_Fonts/Handel_Gothic_D_Medium",
                  text = "TI4 TACTICIAN",
                  color = "White",
                  fontStyle = "Bold",
                  fontSize = 164,
                  alignment = "UpperCenter",
                  offsetXY = "200 -60"--"108 -36"
                }
              },
              {--Subheader Txt
                tag = "Text",
                attributes = {
                  id = "Txt_Subheader",
                  font = "TI4_Fonts/Handel_Gothic_D_Medium",
                  text = "Loading...",
                  color = "White",
                  fontStyle = "Bold",
                  fontSize = 82,
                  alignment = "upperLeft",
                  offsetXY = "620 -340"--"364 -206",
                }
              }
            }
          },
        }
      },
      {--Movement [3]
        tag = "Panel",
        attributes = {
          id = "Pnl_MovementStep",
          height = "40%",
          rectAlignment = "UpperCenter",
          --color = "rgba(0.8,0.1,0.1,0.2)",
          offsetXY = "0 -646",
        },
        children = {
          { --Active step transform
            tag = "Panel",
            attributes = {
              id = "Pnl_MovementStep_Active",
              --active = false
            },
            children = {
              {--Background
                tag = "Image",
                attributes = {
                  id = "Img_MovementBackground",
                  image = "ZoneBackground_Blue",
                  preserveAspect = true,
                },
                children = {}
              },
              {--BackgroundCover
                tag = "Image",
                attributes = {
                  id = "Img_MovementCover",
                  image = "ZoneCover_Blue",
                  preserveAspect = true,
                  offsetXY = "0 20",
                  rectAlignment = "UpperCenter",
                  --active = false
                },
                children = {
                  {--FooterMask
                    tag = "Image",
                    attributes = {
                      id = "Img_MovementFooterCover",
                      image = "Background_Fill",
                      height = "280",
                      rectAlignment = "LowerCenter",
                      offsetXY = "0 -10"
                    }
                  }
                }
              },
              {--HeaderCover
                tag = "Image",
                attributes = {
                  id = "Img_MovementHeaderCover",
                  image = "HeaderCover",
                  preserveAspect = true,
                  rectAlignment = "UpperCenter",
                  offsetXY = "0 150",
                  --active = false
                }
              },
            }
          },
          {--Main Button transform
            tag = "Image",
            attributes = {
              id = "BtnBounds_MovementState",
              preserveAspect = true,
              image = "Btn_NoTactical",
              width = "1164",--"56.8%",
              height = "218",--"17%"
              rectAlignment = "UpperCenter",
            },
            children = {
              {--Btn Label
                tag = "Text",
                attributes = {
                  id = "Txt_MoveState",
                  text = "MOVEMENT",
                  color = "White",
                  font = "TI4_Fonts/Handel_Gothic_D_Medium",
                  fontStyle = "Bold",
                  fontSize = 124,
                }
              }
            }
          },
        }
      },
      {--Space Combat [4]
        tag = "Panel",
        attributes = {
          id = "Pnl_SpaceCombatStep",
          height = "40%",
          rectAlignment = "UpperCenter",
          --color = "rgba(0.8,0.1,0.1,0.2)",
          offsetXY = "0 -938",--282 lower than PrevStep
        },
        children = {
          {--Active step transform
            tag = "Panel",
            attributes = {
              id = "Pnl_SpaceCombatStep_Active",
              --active = false
            },
            children = {
              {--Background
                tag = "Image",
                attributes = {
                  id = "Img_SpaceCombatBackground",
                  image = "ZoneBackground_Red",
                  preserveAspect = true,
                  --active = false
                },
                children = {}
              },
              {--BackgroundCover
                tag = "Image",
                attributes = {
                  id = "Img_SpaceCombatCover",
                  image = "ZoneCover_Red",
                  preserveAspect = true,
                  offsetXY = "0 20",
                  rectAlignment = "UpperCenter",
                  --active = false
                },
                children = {
                  {--FooterCover
                    tag = "Image",
                    attributes = {
                      id = "Img_SpaceCombatFooterCover",
                      image = "Background_Fill",
                      height = "280.0",
                      rectAlignment = "LowerCenter",
                      offsetXY = "0 -10"
                    }
                  },
                }
              },
              {--HeaderCover
                tag = "Image",
                attributes = {
                  id = "Img_SpaceCombatHeaderCover",
                  image = "HeaderCover",
                  preserveAspect = true,
                  rectAlignment = "UpperCenter",
                  offsetXY = "0 150",
                  --active = false
                }
              },
            }
          },
          {--Main Button transform
            tag = "Image",
            attributes = {
              id = "BtnBounds_SpaceCombatState",
              preserveAspect = true,
              image = "Btn_NoTactical",
              width = "1164",--"56.8%",
              height = "218",--"17%"
              rectAlignment = "UpperCenter",
            },
            children = {
              {--Btn Label
                tag = "Text",
                attributes = {
                  id = "Txt_SpaceCombatState",
                  text = "SPACE COMBAT",
                  color = "White",
                  font = "TI4_Fonts/Handel_Gothic_D_Medium",
                  fontStyle = "Bold",
                  fontSize = 124,
                }
              }
            }
          },
        }
      },
      {--Invasion [5]
        tag = "Panel",
        attributes = {
          id = "Pnl_InvasionStep",
          height = 1980,
          width = 2048,
          rectAlignment = "LowerCenter",
        },
        children = {
          {--Active step transform
            tag = "Panel",
            attributes = {
              id = "Pnl_InvasionStep_Active",
              rectAlignment = "LowerCenter",
              --color = "rgba(0.1,0.1,0.8,0.2)",
            },
            children = {
              {--Hex Transform_Lower
                tag = "Panel",
                attributes = {
                  id = "Pnl_InvasionHex_Lower",
                  height = 1945,
                  rectAlignment = "LowerCenter",
                },
                children = {
                  {--Blue space
                    tag = "Image",
                    attributes = {
                      id = "Hex_SpaceBase",
                      image = "InvHex_Space",
                      width = 1500,
                      height = 1300,
                    }
                  },
                  {--Orbital Rings
                    tag = "Panel",
                    attributes = {
                      id = "Pnl_Orbitals",
                      width = 1100,
                      height = 1100,
                    },
                    children = {}
                  },
                  --Planets injected here
                }
              },
              {--Background
                tag = "Image",
                attributes = {
                  id = "Img_InvasionBackground",
                  image = "InvHex_Background",
                  preserveAspect = true,
                  height = 1945,
                  rectAlignment = "LowerCenter",
                  --active = false
                },
              },
              {--Hex transform Upper
                tag = "Panel",
                attributes = {
                  id = "Pnl_InvasionHex",
                  height = 1945,
                  rectAlignment = "LowerCenter",
                },
                children = {
                  {--Active Player Hex
                    tag = "Image",
                    attributes = {
                      id = "Hex_ActivePlayer",
                      image = "InvHex_ActiveColor",
                      color = "Grey",--dynamic
                      width = 1719,
                      height = 1489,
                    }
                  },
                  {--Hex outline
                    tag = "Image",
                    attributes = {
                      id = "Hex_Boarder",
                      image = "InvHex_Outline",
                      width = 1595,
                      height = 1488
                    }
                  },
                  {--Active Planet Nameplate
                    tag = "Image",
                    attributes = {
                      id = "Hex_FocusNameplate",
                      image = "FocusPlanet_Nameplate",
                      width = 626,
                      height = 96,
                      rectAlignment = "LowerCenter",
                      offsetXY = "0 188",
                      active = false
                    },
                    children = {
                      {
                        tag = "Text",
                        attributes = {
                          id = "Txt_HexFocusLabel",
                          text = "Mecatol Rex",
                          color = "White",
                          font = "TI4_Fonts/Handel_Gothic_D_Medium",
                          fontStyle = "Bold",
                          fontSize = 64,
                        }
                      }
                    }
                  },
                  {--Interactables root [6]
                    tag = "Panel",
                    attributes = {
                      id = "Pnl_InvasionHex_Interactables",
                    },
                    children = {
                      {--Bombardment Mode
                        tag = "Panel",
                        attributes = {
                          id = "Pnl_BombardmentMode",
                          width = 432,
                          height = 374,
                          offsetXY = "-644 378",
                          --color = "rgba(0.1 0.8 0.1 0.2)"
                        },
                        children = {
                          {--Hex Outline
                            tag = "Image",
                            attributes = {
                              id = "Img_BombModeOutline",
                              image = "Btn_InvasionSubstepHex",
                              --OnHover change sprite?
                            }
                          },
                          {--Label
                            tag = "Image",
                            attributes = {
                              id = "Img_BombMode_Label",
                              image = "Btn_BombardMode_Label"
                            }
                          },
                          {--Label Txt
                            tag = "Text",
                            attributes = {
                              text = "BOMBARDMENT",
                              color = "White",
                              font = "TI4_Fonts/Handel_Gothic_D_Medium",
                              fontStyle = "Bold",
                              fontSize = 42,
                              offsetXY = "0 -46",
                              horizontalOverflow = "Overflow",
                              verticalOverflow = "Overflow"
                            }
                          },
                        }
                      },
                      {--SpcDeff Mode
                        tag = "Panel",
                        attributes = {
                          id = "Pnl_SpaceCannonDefMode",
                          width = 432,
                          height = 374,
                          offsetXY = "644 378",
                          --color = "rgba(0.1 0.8 0.1 0.2)"
                        },
                        children = {
                          {--Hex Outline
                            tag = "Image",
                            attributes = {
                              id = "Img_SpcDefModeOutline",
                              image = "Btn_InvasionSubstepHex",
                              --OnHover change sprite?
                            }
                          },
                          {--Label
                            tag = "Image",
                            attributes = {
                              id = "Img_SpcDefMode_Label",
                              image = "Btn_SpaceCannonDefMode_Label"
                            }
                          },
                          {--Label Txt
                            tag = "Text",
                            attributes = {
                              text = "SPACE CANNON",
                              color = "White",
                              font = "TI4_Fonts/Handel_Gothic_D_Medium",
                              fontStyle = "Bold",
                              fontSize = 42,
                              offsetXY = "0 -46",
                              horizontalOverflow = "Overflow",
                              verticalOverflow = "Overflow"
                            }
                          }
                        }
                      },
                    }
                  },
                  {--Anomaly
                    tag = "Image",
                    attributes = {
                      id = "Hex_Anamoly",
                      image = "InvHex_Anomaly",
                      width = 1717,
                      height = 1489,
                      active = false
                    }
                  },
                }
              },
              {--Cover Rect
                tag = "Image",
                attributes = {
                  id = "Img_InvasionCoverRect",
                  image = "Background_Fill",
                  rectAlignment = "LowerCenter",
                  height = 1945,
                  width = 2048
                }
              },
              {--BackgroundCover_Header
                tag = "Image",
                attributes = {
                  id = "Img_InvasionCover",
                  image = "ZoneCover_Green",
                  preserveAspect = true,
                  offsetXY = "0 20",
                  rectAlignment = "UpperCenter",
                  --active = false
                },
                children = {
                  {--GhostMask
                    tag = "Image",
                    attributes = {
                      image = "Background_Fill",
                      height = 30,
                      offsetXY = "0 -120",-- -128 + 20 + 10
                      rectAlignment = "UpperCenter"
                    }
                  }
                }
              },
              {--HeaderCover
                tag = "Image",
                attributes = {
                  id = "Img_InvasionHeaderCover",
                  image = "HeaderCover",
                  preserveAspect = true,
                  rectAlignment = "UpperCenter",
                  offsetXY = "0 145",
                }
              },
            }
          },
        }
      },
      {--Footer Fade [6]
        tag = "Image",
        attributes = {
          id = "Img_FooterFade",
          image = "FooterFade",
          preserveAspect = true,
          rectAlignment = "LowerCenter",
          showAnimation = "FadeIn",
          hideAnimation = "FadeOut",
          showAnimationDelay = 0.2,
          animationDuration = 0.4
          --active = false
        },
        children = {
          {--GhostMask
            tag = "Image",
            attributes = {
              id = "GhostMask_Footer",
              image = "Background_Fill",
              width = 2048,
              height = 16,
              offsetXY = "0 1020",
              rectAlignment = "LowerCenter",
            }
          }
        }
      },
      {--Invasion Label [7]
        tag = "Panel",
        attributes = {
          id = "Pnl_InvasionStep",
          height = 1980,
          width = 2048,
          rectAlignment = "LowerCenter",
        },
        children = {
          {--Main Button transform
            tag = "Image",
            attributes = {
              id = "BtnBounds_InvasionState",
              preserveAspect = true,
              image = "Btn_NoTactical",
              width = "1164",--"56.8%",
              height = "218",--"17%"
              rectAlignment = "UpperCenter",
            },
            children = {
              {--Btn Label
                tag = "Text",
                attributes = {
                  id = "Txt_InvasionState",
                  text = "INVASION",
                  color = "White",
                  font = "TI4_Fonts/Handel_Gothic_D_Medium",
                  fontStyle = "Bold",
                  fontSize = 124,
                }
              }
            }
          },
        }
      },
      { --Turn display [8]
        tag = "Panel",
        attributes = {
          id = "Pnl_Turns",
          height = "55%",
          rectAlignment = "LowerCenter",
          active = false
        },
        children = {
          {--Turn alignment panel
            tag = "Panel",
            attributes = {
              id = "Pnl_TurnsTransform",
            },
            children = {
              {--Turn Color Panel
                tag = "Panel",
                attributes = {
                  id = "Pnl_TurnButtons",
                  width = "36.5%",--746.0/3
                  offsetXY = "106 0",--"10.0 0"
                  --color = "Pink",
                },
                children = {
                  {--ActivePlayer Label
                    tag = "Panel",
                    attributes = {
                      id = "Pnl_ActivePlayer",
                      rectAlignment = "LowerLeft",
                      height = 140,
                      width = 910,
                      active = false,
                    },
                    children = {
                      {--Active Bar
                        tag = "image",
                        attributes = {
                          id = "Turns_activePlayer",
                          image = "Turns_ActivePlayer",
                          rectAlignment = "MiddleCenter",
                          --preserveAspect = true,
                          color = "Grey",
                        }
                      },
                      {--Text
                        tag = "Text",
                        attributes = {
                          id = "Turns_activePlayerName",
                          text = " Active Player",
                          font = "TI4_Fonts/Handel_Gothic_D_Medium",
                          color = "White",
                          fontStyle = "Bold",
                          fontSize = 82,
                          resizeTextMaxSize = 102,
                          alignment = "MiddleLeft",
                          verticalOverflow = "Overflow",
                          horizontalOverflow = "Overflow"
                        }
                      }
                    }
                  },
                },
              },
              {--StratPanel
                tag = "Panel",
                attributes = {
                  id = "Pnl_StratIcons",
                  width = "32%",--106.0,
                  rectAlignment = "LowerLeft",
                  offsetXY = "80 0",--x: 106px dim - padding
                  --color = "Blue",
                },
                children = {}
              },
            }
          },
        }
      },
      {--Agenda Icon
        tag= "Image",
        attributes = {
          id = "icon_agenda",
          image = "Icon_Agenda",
          offsetXY = "0 -310",
          preserveAspect = true,
          showAnimation = "FadeIn",
          hideAnimation = "FadeOut",
          animationDuration = 1.25
        }
      },
    }
   },
  },

  settings = {
    turns = {
      playerCount = 0,--runntime
      yOff = 25*7, yPadding = 25*7, yPadding_Passed = 10*7, pCountOff = 10*7, stratStackOff = -20*7,
      fontSize = 82,--48,
    },
  },

  stratAssignments = {},
  _batchChanges = {},
  _batchCo = false,

  eSubTxt = {
    ["FactionName"] = function() return "FactionName" end,
    ["NonActive"] = function() return "NonActive" end,--Not action phase
    ["Activate"] = function() return "Activate" end,
  }
}

--Active player != Turns.turn_color. The Tactician allows players to be "active" outside of their turn
local ActivePlayer = {
  color = "Black",
  previous = "Black",
  faction = false,
  tokenName = false,
  system = false,
  prevSystem = false
}
ActivePlayer.update = function(color)
  if not color then color = Turns.enable and Turns.turn_color or "Grey" end

  local faction = _factionHelper.fromColor(color) or false
  ActivePlayer.faction = faction and faction.name or false
  ActivePlayer.tokenName = faction and faction.tokenName or false

  if ActivePlayer.color == color then return end
  ActivePlayer.previous = ActivePlayer.color
  ActivePlayer.color = color
  --ActivePlayer.system is not changed here
end

local data = { --misc data container
  --Runtime data
  activePassedTokens = {},
  stratObjs = false,
  stratCards = {
    ['Leadership'] = {i = 1, color = "Red", holder = "Grey"},
    ['Diplomacy'] = {i = 2, color = "Orange", holder = "Grey"},
    ['Politics'] = {i = 3, color = "Yellow", holder = "Grey"},
    ['Construction'] = {i = 4, color = "Green", holder = "Grey"},
    ['Trade'] = {i = 5, color = "Teal", holder = "Grey"},
    ['Warfare'] = {i = 6, color = "Blue", holder = "Grey"},
    ['Technology'] = {i = 7, color = "#1c477a", holder = "Grey"},
    ['Imperial'] = {i = 8, color = "Purple", holder = "Grey"},
    --Alternatives
    ['Diplomacy (Revised)'] = {i = 2, color = "Orange", holder = "Grey"},
    ['Industry'] = {i = 5, color = "Teal", holder = "Grey"},
    ['Trade (6)'] = {i = 6, color = "Blue", holder = "Grey"},
    ['Warfare (7)'] = {i = 7, color = "#1c477a", holder = "Grey"},
    ['Logistics'] = {i = 8, color = "Purple", holder = "Grey"},
    ['Technology (9)'] = {i = 9, color = "#9116c5", holder = "Grey"},
    ['Imperial (10)'] = {i = 10, color = "Pink", holder = "Grey"},
  },
  playableColors = {"White", "Red", "Orange", "Yellow","Green", "Blue", "Purple", "Pink", "Brown"},
}

data.isPlayerPassed = function(color)
  local function _getTokensObjs(returnCol)
    local objs = {}
    for _,eachObj in ipairs(getAllObjects()) do
      local name = eachObj.getName()
      local iStart, iEnd = string.find(name, "Active/Passed (", 1, true)
      if iStart then
        local color = string.sub(name, iEnd + 1, #name - 1)
        data.activePassedTokens[color] = eachObj
        data.activePassedTokens[eachObj] = color
      end
    end
    if returnCol then return data.activePassedTokens[returnCol] end
  end

  local token = data.activePassedTokens[color] or _getTokensObjs(color)
  return token and token.is_face_down or false
end

--Returns table of strat card names or nil
data.getPlayerStrats = function(color)
  if not _zoneHelper.zoneAttributes(color) then return end

  local result = {}
  for name,each in pairs(data.stratCards) do
    if each.holder() == color then table.insert(result, name) end
  end

  return next(result) and result or nil
end

data.initStratCards = function()
  local function getStrats()
    data.stratObjs = {}
    for _,eachObj in ipairs(getAllObjects()) do
      local name = eachObj.getName()
      if data.stratCards[name] then
        data.stratObjs[name] = eachObj
      end
    end
  end
  getStrats()

  for name, each in pairs(data.stratCards) do
    local function getHolder()
      if not data.stratObjs[name] then
        getStrats()
        if not data.stratObjs[name] then return "Grey" end --couldnt find object
      end
      return _zoneHelper.zoneFromPosition(data.stratObjs[name].getPosition()) or "Grey"
    end

    each.holder = getHolder
  end
end

--Public funcs------------------------------------------------------------------

--system highlighter highlights adjacent systems during the Movement step. Set enabled/disabled per player color
--params: {color = "", enabled = t/f, toggle = t/f} --use toggle OR enable (not both)
function setSystemHighlighter(params)
  assert(params.color and type(params.color) == "string")
  local toState = params.enabled or false
  if params.toggle then toState = not Tac.highlightAdjSystems[params.color] end
  Tac.highlightAdjSystems[params.color] = toState

  --update UI now?
  if Tac.State == Tac.eStates.Movement() and params.color == ActivePlayer.color then
    print("TODO: Set system highlighter btn in >setSystemHighlighter()<")
    if toState then
      _systemHelper.getAdjacentSystems({color = ActivePlayer.color, highlight = true})
    else
      _systemHelper.removeSystemHighlights()
    end
  end
end


--UI----------------------------------------------------------------------------
ui.setSubheaderTxt = function(state)
  local switch = {
    ["FactionName"] = function() local txt = ActivePlayer.faction or ActivePlayer.color .. "\'S TURN" return string.upper(txt) end,
    ["NonActive"] = function() return "Set turns or activate a system" end,
    ["Activate"] = function() return "Activate a system to begin..." end
  }
  ui.batchSet("Txt_Subheader" ,{text = switch[state]()})
end
--{[btn_ID] = {smart = "attacker"/"defender"|nil, rollTarget = engagementType}}
ui.btnLookup = {}
local xmlIndex = {turns = 8, move = 3, SpC = 4, Inv = 5, InvLabel = 7, planets = 5}
ui.generateXML = function(callback)
  ui.onXmlInjected = callback

  local function turnUI()
    --Turn buttons
    local colIndex = data.playableColors
    for i = 1, 9, 1 do
      local xmlButton = {
        tag = "Button",
        attributes = {
          id = "Turns_" .. colIndex[i] .. "_inactive",
          transition = "SpriteSwap",
          image = "Turns_NonactivePlayer_Hover",--"Turns_NonactivePlayer",
          --sprite = "Turns_NonactivePlayer",
          highlightedSprite = "Turns_NonactivePlayer",--"Turns_NonactivePlayer_Hover",
          pressedSprite = "Turns_NonactivePlayer_Pressed",
          offsetXY = "0 " .. (i* ui.settings.turns.yPadding),
          height = "8%",
          rectAlignment = "LowerCenter",
          color = colIndex[i],
          preserveAspect = true,
          active = false,
        },
        children = {}
      }

      local btnTxt = {
        tag = "Text",
        attributes = {
          id = "Turns_" .. colIndex[i] .. "_Name",
          font = "TI4_Fonts/Handel_Gothic_D_Medium",
          text = "INACTIVE PLAYER",
          color = "White",
          fontStyle = "Bold",
          fontSize = ui.settings.turns.fontSize,
          resizeTextMaxSize = 102,
          alignment = "MiddleLeft",
          verticalOverflow = "Overflow",
          horizontalOverflow = "Overflow"
        }
      }
      table.insert(xmlButton.children, btnTxt)
      local passBar = {
        tag = "Image",
        attributes = {
          id = "Turns_PassedPlayer_" .. colIndex[i],
          image = "Turns_PassedPlayer",
          color = colIndex[i],
          rectAlignment = "LowerCenter",
          offsetXY = "0 " .. (i* ui.settings.turns.yPadding_Passed) + (8* ui.settings.turns.yPadding),
          preserveAspect = true,
          active = false
        }
      }
                   --Root    --> TurnsPanel --AlignmentPnl--TurnButtonsPnl
      --table.insert(ui.xmlTable[1].children[xmlIndex.turns].children[1].children[1].children, xmlButton)
      --table.insert(ui.xmlTable[1].children[xmlIndex.turns].children[1].children[1].children, passBar)
      ui.insertXml(xmlButton, "Pnl_TurnButtons")
      ui.insertXml(passBar, "Pnl_TurnButtons")
    end

    --Strategy cards
    for name,each in pairs(data.stratCards) do
        local stratCard = {
          tag = "Image",
          attributes = {
            id = "Icon_StratCard_" .. name,
            image = "StrategyCard_Icon",
            color = each.color,
            height = "8%",
            rectAlignment = "LowerRight",
            preserveAspect = true,
            active = false,
          },
          children = {}
        }
        local stratTxt = {
          tag = "Text",
          attributes = {
            id = "StratCard_Txt_" .. name,
            font = "TI4_Fonts/Handel_Gothic_D_Medium",
            text = each.i,
            color = "White",
            fontStyle = "Bold",
            fontSize = ui.settings.turns.fontSize,
            offsetXY = "-24 32",
            alignment = "LowerRight",
            resizeTextMaxSize = 128,
          }
        }
        if each.i == 1 then stratTxt.attributes.text = "1 " stratTxt.attributes.offsetXY = "-20 32" end
        table.insert(stratCard.children, stratTxt)
        ui.insertXml(stratCard, "Pnl_StratIcons")
    end
    local stratDeco = {
      tag = "Image",
      attributes = {
        id = "Icon_StratCardActive",
        image = "Turns_ActiveStrategy",
        preserveAspect = true,
        --offsetXY = "0 " .. (9*25) - (1*25),
        height = "8%",
        rectAlignment = "LowerRight",
      }
    }
    ui.insertXml(stratDeco, "Pnl_StratIcons")
  end
  turnUI()

  local function stepBtns()
    --Menu buttons
    local movementXML =
    {
      id = "Btn_MovementState",
      onIcon = "Btn_Blue_Active",
      onIcon_Hover = "Btn_Blue_Pressed",
      onIcon_Pressed = "Btn_Blue_Hover",
      onIcon_Disabled = "Btn_NoTactical",
      offIcon = "Btn_Blue",
      offIcon_Hover = "Btn_Blue_Hover",
      offIcon_Pressed = "Btn_Blue_Pressed",
      offIcon_Disabled = "Btn_NoTactical",
      attributes = { interactable = false},

      onClick = onButtonClicked_TacState,
    }
    local spaceCombatXML = {
      id = "Btn_SpaceCombatState",
      onIcon = "Btn_Red_Active",
      onIcon_Hover = "Btn_Red_Pressed",
      onIcon_Pressed = "Btn_Red_Hover",
      onIcon_Disabled = "Btn_NoTactical",
      offIcon = "Btn_Red",
      offIcon_Hover = "Btn_Red_Hover",
      offIcon_Pressed = "Btn_Red_Pressed",
      offIcon_Disabled = "Btn_NoTactical",
      attributes = { interactable = false},

      onClick = onButtonClicked_TacState,
    }
    local invasionXML = {
      id = "Btn_InvasionState",
      onIcon = "Btn_Green_Active",
      onIcon_Hover = "Btn_Green_Pressed",
      onIcon_Pressed = "Btn_Green_Hover",
      onIcon_Disabled = "Btn_NoTactical",
      offIcon = "Btn_Green",
      offIcon_Hover = "Btn_Green_Hover",
      offIcon_Pressed = "Btn_Green_Pressed",
      offIcon_Disabled = "Btn_NoTactical",
      attributes = { interactable = false},

      onClick = onButtonClicked_TacState,
    }
    local movementToggle = ToggleButton.newAsXmlTable(movementXML)
    local spaceCombatToggle = ToggleButton.newAsXmlTable(spaceCombatXML)
    local invasionToggle = ToggleButton.newAsXmlTable(invasionXML)
    ui.insertXml(movementToggle, "BtnBounds_MovementState", 1)
    ui.insertXml(spaceCombatToggle, "BtnBounds_SpaceCombatState", 1)
    ui.insertXml(invasionToggle, "BtnBounds_InvasionState", 1)
    ToggleButton.newGroup({name = "TacStep", members = {movementXML.id, spaceCombatXML.id, invasionXML.id}, activeLimit = 1})
  end
  stepBtns()

  local function rollBtns()
    --normalColor|highlightedColor|pressedColor|disabledColor
    local elements = {
      {id = "Btn_ConfirmMovement", width = "978", txt = "CONFIRM MOVEMENT", yOff = 170, parent = "Img_MovementBackground", target = "confirmMovement"},
      {id = "Btn_Roll_SpaceCannonOff", width = "705", txt = "SPACE CANNON", yOff = -160, parent = "Img_MovementBackground", target = "spaceCannonOff", smart = true},
      {id = "Btn_Roll_AFB", width = "288", txt = "AFB", yOff = 170, parent = "Img_SpaceCombatBackground", target = "antifighterBarrage", smart = true},
      {id = "Btn_Roll_SpaceCombat", width = "705", txt = "SPACE COMBAT", yOff = -160, parent = "Img_SpaceCombatBackground", target = "spaceCombat", smart = true},
      {id = "Btn_Roll_InvasionContext", width = "800", txt = "CONTEXT", yOff = -578, parent = "Pnl_InvasionHex_Interactables", target = "invasionContext", smart = true},
    }
    local smartSett = {
      width = 116, offset = 116 + 10,
      icon = {
        ["attacker"] = {icon = "Icon_Attacker", offsetXY = "0 0", width = 128.0, height = 64.0},
        ["defender"] = {icon = "Icon_Defender", offsetXY = "0 0", width = 64.0, height = 77.0}
      },
      image = {
        ["attacker"] = {main = "Btn_SmartAttack", hover = "Btn_SmartAttack_Hover", press = "Btn_SmartAttack_Pressed"},
        ["defender"] = {main = "Btn_SmartDefend", hover = "Btn_SmartDefend_Hover", press = "Btn_SmartDefend_Pressed"}
      },
    }

    local smartBtns = {
      {id = "SmartBtn_SpaceCombat_Att", parent = "Btn_Roll_SpaceCombat", target = "spaceCombat", attacker = true},
      {id = "SmartBtn_SpaceCombat_Def", parent = "Btn_Roll_SpaceCombat", target = "spaceCombat"},
      {id = "SmartBtn_AFB_Att",parent = "Btn_Roll_AFB", target = "antifighterBarrage", attacker = true},
      {id = "SmartBtn_AFB_Def", parent = "Btn_Roll_AFB", target = "antifighterBarrage"},
      {id = "SmartBtn_SpaceCannonOff_Att", parent = "Btn_Roll_SpaceCannonOff", target = "spaceCannonOff", attacker = true},
      {id = "SmartBtn_SpaceCannonOff_Def", parent = "Btn_Roll_SpaceCannonOff", target = "spaceCannonOff"},
      {id = "SmartBtn_InvasionContext_Att", parent = "Btn_Roll_InvasionContext", target = "invasionContext", attacker = true},
      {id = "SmartBtn_InvasionContext_Def", parent = "Btn_Roll_InvasionContext", target = "invasionContext"}
    }
    local sBtns = {}
    for _,each in ipairs(smartBtns) do
      local role = each.attacker and "attacker" or "defender"
      local  smarty = {
        tag = "Button",
        attributes = {
          active = false,
          id = each.id,
          transition = "SpriteSwap",
          image = smartSett.image[role].main,
          highlightedSprite = smartSett.image[role].hover,
          pressedSprite = smartSett.image[role].press,
          --icon = smartSett.icon[role].icon,
          rectAlignment = each.attacker and "MiddleLeft" or "MiddleRight",
          width = smartSett.width,
          offsetXY = ""..(smartSett.offset * (each.attacker and -1 or 1)) .. " 0",
          color = each.attacker and "White" or "Grey",

          onClick = self.getGUID() .."/onSmartButtonClicked"
        },
        children = { --Token/shield icon
          {
            tag = "Image",
            attributes = {
              image = smartSett.icon[role].icon,
              width = smartSett.icon[role].width,
              height = smartSett.icon[role].height,
              offsetXY = smartSett.icon[role].offsetXY,
              raycastTarget = false
              --preserveAspect = true,
            }
          }
        }
      }
      sBtns[each.parent] = sBtns[each.parent] or {}
      table.insert(sBtns[each.parent], smarty)
      ui.btnLookup[each.id] = {smart = each.attacker and "attacker" or "defender", rollTarget = each.target}
    end

    for _,each in ipairs(elements) do
      local new = {--ButtonOutline
        tag = "Button",
        attributes = {
          id = each.id .. "_Outline",
          width = each.width + 24,
          height = 242,--"218" + 24(outline),
          offsetXY = "0 " .. each.yOff,
          colors = "#b0b0b0|#d1d0d0|White|White",
          active = false
        },
        children = {
          {--Button
            tag = "Button",
            attributes = {
              id = each.id,
              width = each.width,
              height = 218,
              colors = "#24242a|#26262a|#323235|#17171a",
              onClick = self.getGUID() .. "/onButtonClicked_MulitRoller()",
              active = false
            },
          },
          {--Label Txt
            tag = "Text",
            attributes = {
              id = each.id .. "_Txt",
              font = "TI4_Fonts/Handel_Gothic_D_Medium",
              text = each.txt,
              color = "White",
              fontStyle = "Bold",
              fontSize = 86,
              resizeTextMaxSize = 102,
              alignment = "MiddleCenter",
            }
          }
        }--
      }
      if sBtns[each.id] then --Attach smart buttons
        for _, each in ipairs(sBtns[each.id]) do
          table.insert(new.children, each)
        end
      end

      ui.btnLookup[each.id] = {rollTarget = each.target}
      ui.insertXml(new, each.parent)
    end
  end
  rollBtns()

  local function invBtns()
    local smartBombard = {
      tag = "Button",
      attributes = {
        id = "SmartBtn_Bombardment",
        image = "Btn_SmartSubstep",
        highlightedSprite = "Btn_SmartSubstep_Hover",
        pressedSprite = "Btn_SmartSubstep_Pressed",
        transition = "SpriteSwap",
        color = "Grey", --dynamic
        rectAlignment = "LowerCenter",
        width = 331,
        height = 102,
        active = false,
        interactable = false,

        onClick = self.getGUID() .. "/onSmartButtonClicked"
      },
      children = {
        {--Icon
          tag = "Image",
          attributes = {
            width = 128.0,
            height = 64.0,
            image = "Icon_Attacker"
          }
        }
      }
    }
    local smartPDS = {
      tag = "Button",
      attributes = {
        id = "SmartBtn_SpaceCannonDef",
        image = "Btn_SmartSubstep",
        highlightedSprite = "Btn_SmartSubstep_Hover",
        pressedSprite = "Btn_SmartSubstep_Pressed",
        transition = "SpriteSwap",
        color = "Grey", --dynamic
        rectAlignment = "LowerCenter",
        width = 331,
        height = 102,
        active = false,
        interactable = false,

        onClick = self.getGUID() .. "/onSmartButtonClicked"
      },
      children = {
        {--Icon
          tag = "Image",
          attributes = {
            width = 64.0 *0.9,
            height = 77.0 *0.9,
            image = "Icon_Defender"
          }
        }
      }
    }
    ui.btnLookup["SmartBtn_Bombardment"] = {smart = "attacker", rollTarget = "bombardment"}
    ui.btnLookup["SmartBtn_SpaceCannonDef"] = {smart = "defender", rollTarget = "spaceCannonDef"}
    ui.insertXml(smartBombard, "Pnl_BombardmentMode", 1)
    ui.insertXml(smartPDS, "Pnl_SpaceCannonDefMode", 1)

    local bombMode_Toggle = {
      id = "Btn_BombardmentMode",
      onIcon = "Btn_BombardMode_Active",
      onIcon_Hover = "Btn_BombardMode_Pressed",
      onIcon_Pressed = "Btn_BombardMode_Hover",
      onIcon_Disabled = "Btn_BombardMode",
      offIcon = "Btn_BombardMode",
      offIcon_Hover = "Btn_BombardMode_Hover",
      offIcon_Pressed = "Btn_BombardMode_Pressed",
      offIcon_Disabled = "Btn_BombardMode",
      attributes = { active = false, interactable = false, rectAlignment = "UpperCenter", width = 420, height = 194},

      onClick = onButtonClicked_InvasionStep,
    }
    local spcDefMode_Toggle = {
      id = "Btn_SpaceCannonDefMode",
      onIcon = "Btn_SpaceCannonDefMode_Active",
      onIcon_Hover = "Btn_SpaceCannonDefMode_Pressed",
      onIcon_Pressed = "Btn_SpaceCannonDefMode_Hover",
      onIcon_Disabled = "Btn_SpaceCannonDefMode",
      offIcon = "Btn_SpaceCannonDefMode",
      offIcon_Hover = "Btn_SpaceCannonDefMode_Hover",
      offIcon_Pressed = "Btn_SpaceCannonDefMode_Pressed",
      offIcon_Disabled = "Btn_SpaceCannonDefMode",
      attributes = { active = false, interactable = false, rectAlignment = "UpperCenter", width = 420, height = 194},

      onClick = onButtonClicked_InvasionStep,
    }
    local bombModeBtn = ToggleButton.newAsXmlTable(bombMode_Toggle)
    local spcDefMode = ToggleButton.newAsXmlTable(spcDefMode_Toggle)
    ui.insertXml(bombModeBtn, "Pnl_BombardmentMode", 1)
    ui.insertXml(spcDefMode, "Pnl_SpaceCannonDefMode", 1)
    ToggleButton.newGroup({name = "InvSteps", members = {bombMode_Toggle.id, spcDefMode_Toggle.id}, activeLimit = 1})
  end
  invBtns()

  local function planets()
    for i = 1, 5, 1 do
      local _id = "p"..i
      local planet = {
        tag = "Panel",
        attributes = {
          id = _id,
          width = 452.0,
          height = 452.0,
          scale = "1 1 1",
          active = false
        },
        children = {
          {--PButton/OwnerIndicator
            tag = "Button",
            attributes = {
              id = _id .. "_ColorRing",
              image = "Wired_Color",
              color = "White", --dynamic
              transition = "SpriteSwap",
              highlightedSprite = "Wired_Color_Hover",
              pressedSprite = "Wired_Color_Pressed",
              interactable = false,
              active = false,

              onClick = self.getGUID().."/onPlanetButtonClicked("..i..")"
            }
          },
          {--Planet
            tag = "Image",
            attributes = {
              id = _id .."_Planet",
              image = "Wired_Planet", --dynamic
            }
          },
          {--HS highlight
            tag = "Image",
            attributes = {
              id = _id.."_HS",
              image = "Wired_Highlight",
              color = "White", --dynamic
              active = false
            }
          },
          { --Planetary Shield
            tag = "panel",
            attributes = {
              id = _id.."shieldRoot",
              offsetXY = "180 120"--"357 265",
            },
            children = {
              {--Shield image parent
                tag = "panel",
                attributes = {
                  id = _id .. "_shieldShowSkip",
                  offsetXY = "0 -8",
                  rotation = "0 0 12",
                  active = false,
                  raycastTarget = false,
                },
                children = {
                  { --Active Shield
                    tag = "image",
                    attributes = {
                      id = _id.."_ShieldEnabled",
                      image = "PlanetaryShield_Enabled",
                      showAnimation = "Grow",
                      hideAnimation = "FadeOut",
                      animationDuration = 0.6,
                      raycastTarget = false,
                      active = false
                    }
                  },
                  { --Disabled Shield
                    tag = "image",
                    attributes = {
                      id = _id.."_ShieldDisabled",
                      image = "PlanetaryShield_Disabled",
                      showAnimation = "FadeIn",
                      hideAnimation = "FadeOut",
                      animationDuration = 0.4,
                      raycastTarget = false,
                      active = false
                    }
                  }
                }
              },
              { --Override button
                tag = "button",
                attributes = {
                  id = _id.."_Btn_shieldOverride",
                  width = 128.0 * 0.7,
                  height = 128.0 * 0.7,

                  transition = "SpriteSwap",
                  sprite = "Btn_PShield_NoOverride",
                  highlightedSprite = "Btn_PShield_Disable_Dark",
                  pressedSprite = "Btn_PShield_Disable",
                  disabledSprite = "Btn_PShield_NoOverride",
                  onClick = self.getGUID() .. "/onButtonClicked_PShieldOverride",

                  active = false,
                  interactable = false,
                }
              }
            }
          },
          {--Nameplate
            tag = "Image",
            attributes = {
              id = _id .. "_Nameplate",
              image = "Wired_Nameplate",
              offsetXY = "0 " .. -128,
              width = 456,
              preserveAspect = true
            },
            children = {--Txt
              {
                tag = "Text",
                attributes = {
                  id = _id.."_Txt",
                  font = "TI4_Fonts/Handel_Gothic_D_Medium",
                  text = "NAME",
                  color = "White",
                  fontStyle = "Bold",
                  fontSize = 44,
                  resizeTextMaxSize = 54,
                  alignment = "MiddleCenter",
                  offsetXY = "0 " .. 6
                }
              }
            }
          },
          {--QuickBomb
            tag = "Button",
            attributes = {
              id = _id .."_QuickBombard",
              image = "QuickBtn_Bombardment",
              highlightedSprite = "QuickBtn_Bombardment_Hover",
              pressedSprite = "QuickBtn_Bombardment_Pressed",
              transition = "SpriteSwap",
              width = 128.0 * 0.85,
              height = 106.0 * 0.85,--112
              onClick = self.getGUID().. "/onQuickRollBombardment("..i..")",
              offsetXY = "".. -221 .." ".. (-62 * 0.8),
              interactable = false,
              active = false,
            }
          },
          {--QuickPDS
            tag = "Button",
            attributes = {
              id = _id .."_QuickPDS",
              image = "QuickBtn_PDS",
              highlightedSprite = "QuickBtn_PDS_Hover",
              pressedSprite = "QuickBtn_PDS_Pressed",
              transition = "SpriteSwap",
              width = 128.0 * 0.85,
              height = 106.0 * 0.85,
              onClick = self.getGUID().. "/onQuickRollSpaceCannonDef("..i..")",
              offsetXY = "".. 221 .." "..(-62 * 0.8),
              interactable = false,
              active = false,
            }
          },
          {--PlasmaScoring
            tag = "button",
            attributes = {
              id = _id.."_Btn_PlasmaScoring",
              width = 128.0 * 0.6,
              height = 128.0 * 0.6,
              --height = 106.0 * 0.6,--112
              offsetXY = "".. -143 .." ".. (-62 * 0.1),

              transition = "SpriteSwap",
              sprite = "Icon_PlasmaScoring",
              --highlightedSprite = "Icon_PlasmaScoring_Hover",
              pressedSprite = "Icon_PlasmaScoring_Active",
              disabledSprite = "Icon_PlasmaScoring",

              isOn = false,
              active = false,
              interactable = false,
              onClick = self.getGUID().. "/onPlasmaTargetSelected()",
            },
          },
          {--traitIcon
            tag = "Image",
            attributes = {
              id = _id.."_Trait",
              image = "Icon_Cultural",
              offsetXY = "0 " .. Planets.traits.data.offset,
              width = "152",
              preserveAspect = true,
              active = false,
            }
          }
        }
      }
      ui.insertXml(planet, "Pnl_InvasionHex_Lower")
      Planets.shieldUI[i] = {active = false, enabled = 0, override = 0}
      Planets.shieldStatus[i] = {enabled = 0, override = 0}
      --Generate shield UI
    end
  end
  planets()
end

ui.hideOnInit = function()
  for i = 1, 5, 1 do
    local _id = "p"..i
    self.UI.hide(_id.."_ShieldEnabled")
    self.UI.hide(_id.."_ShieldDisabled")
  end
end

ui._inserts = {}--{ [parent] = {{xml = element, i = insertIndex}}}
ui._waitingInsert = false
ui.onXmlInjected = false
ui.insertXml = function(xml, parentID, index)
  local function resolve()
    ui._waitingInsert = false

    local function insert(tbl, pID)
      for _, each in ipairs(ui._inserts[pID]) do
        if each.i then
          table.insert(tbl, each.i, each.xml)
        else
          table.insert(tbl, each.xml)
        end
      end
      ui._inserts[pID] = nil
    end

    local function recursiveSearch(table)
      if not table.children then return end --assume I put an empty children {} table in the xml

      for _, each in ipairs(table.children) do
        if ui._inserts[each.attributes.id] then
          insert(each.children, each.attributes.id)
          if not next(ui._inserts) then return end
        end
        if each.children then recursiveSearch(each) end
      end
    end

    recursiveSearch(ui.xmlTable[1])
    if ui.onXmlInjected then
      ui.onXmlInjected()
      ui.onXmlInjected = false
    end
  end

  --Wait to gather all insert requests then resolve in 1 pass
  if not ui._waitingInsert then ui._waitingInsert = Wait.frames(resolve, 1) end
  ui._inserts[parentID] = ui._inserts[parentID] or {}
  table.insert(ui._inserts[parentID], {xml = xml, i = index})
end

ui.setTurnUI = function(enabled)
  if not enabled then
    ui.batchSet("Pnl_Turns", {["active"] = false})
    return
  end

  local zoneColors = _zoneHelper.zones()
  if not zoneColors then return end
  local playerData = {} --contains: color, faction, passed, stratCards, seat, trunOrder
  for seat,color in ipairs(zoneColors) do
    local factionTable = _factionHelper.fromColor(color)
    playerData[color] = {
      faction = factionTable and factionTable.tokenName or false,
      passed = data.isPlayerPassed(color),
      stratCards = data.getPlayerStrats(color),
      seat = seat,
      color = color
    }
  end

  local turnOrder = Turns.order
  local nextTurn = 1
  for i,eachCol in ipairs(turnOrder) do --turnOrder may hold unseated/unplayable colors
    if playerData[eachCol] then
      playerData[eachCol].turnOrder = nextTurn
      playerData[nextTurn] = eachCol
      nextTurn = nextTurn + 1
    end
  end
  --printTable(playerData)

  --Turn off all elements first, then turn on only the needed ones
  for _,eachCol in ipairs(data.playableColors) do
    ui.batchSet("Turns_".. eachCol .."_inactive", {["active"] = false})
    ui.batchSet("Turns_PassedPlayer_".. eachCol, {["active"] = false})
  end
  for name,each in pairs(data.stratCards)do
    ui.batchSet("Icon_StratCard_" .. name, {["active"] = false})
    ui.stratAssignments[name] = "Grey"
  end
  ui.batchSet("Icon_StratCardActive",{["active"] = false})
  ui.batchSet("Pnl_ActivePlayer", {active = false})

  local pCount = #turnOrder
  local runningOffset = 0
  for i = pCount, 1, -1 do
    local p = playerData[playerData[i]]--dataFromTurnPosition
    local off = 0
    if not p then goto continue end

    off = p.passed and ui.settings.turns.yPadding_Passed or ui.settings.turns.yPadding
    runningOffset = runningOffset + off

    ui.batchSet("Turns_".. p.color .."_inactive", {["active"] = Turns.turn_color ~= p.color and not p.passed, ["offsetXY"] = "0 ".. runningOffset})
    ui.batchSet("Turns_PassedPlayer_".. p.color, {["active"] = p.passed, ["offsetXY"] = "0 ".. runningOffset + (15 * 7)})
    ui.batchSet("Turns_" .. p.color .. "_Name", {text = " " .. (p.faction or p.color)}) --["offsetXY"] = "0 ".. (runningOffset*4),
    if Turns.turn_color == p.color and not p.passed then
      ui.batchSet("Pnl_ActivePlayer", {active = true, offsetXY = "0 ".. (runningOffset)})
      ui.batchSet("Turns_activePlayer", {color = p.color})
      local displayName = p.faction or p.color
      ui.batchSet("Turns_activePlayerName", {text = " "..displayName, fontSize = #displayName < 20 and ui.settings.turns.fontSize or (ui.settings.turns.fontSize - 8)})
    end

    if p.stratCards then
      for _,strat in ipairs(p.stratCards) do
        ui.stratAssignments[strat] = p.color
      end
      if not p.passed then
        --Order strategy cards by initative
        local initList = {}
        for _,eachStrat in ipairs(p.stratCards) do
          for i,each in ipairs(initList) do
            if data.stratCards[eachStrat].i < data.stratCards[eachStrat].i then
              table.insert(initList, i, eachStrat)
              break
            end
          end
          table.insert(initList, eachStrat)
        end

        --iterate through cards -> highest init to lowest which sets them right to left (Lowest leading)
        local sCount = #initList
        for i = sCount, 1, -1 do
          ui.batchSet("Icon_StratCard_" .. initList[i],
            {
              active = true,
              offsetXY = "" .. ui.settings.turns.stratStackOff * (sCount - i) .. " " .. runningOffset,
              color = data.stratObjs[initList[i]].is_face_down and "Grey" or data.stratCards[initList[i]].color
            })
        end
        if Turns.turn_color == p.color then
          ui.batchSet("Icon_StratCardActive",{
            ["active"] = true,
            ["color"] = data.stratCards[initList[1]].color,
            ["offsetXY"] = "" .. ui.settings.turns.stratStackOff * (sCount - 1) .. " ".. runningOffset})
        end
      end
    end

    ::continue::
  end


  ui.batchSet("Pnl_TurnsTransform", {["offsetXY"] = "0 " .. ((8*ui.settings.turns.yPadding) - runningOffset)/2.0})--Move up to keep centered
  ui.batchSet("Pnl_Turns", {["active"] = true})
  self.UI.hide("icon_agenda")
end

ui.onStratDrop = function(obj)
  if Tac.State ~= Tac.eStates.Turns() then return end
  local name = obj.getName()
  if not data.stratCards[name] then return end

  local landingZone = data.stratCards[name].holder()
  if ui.stratAssignments[name] ~= landingZone then
    ui.setTurnUI(true)
  end
end

ui.batchSet = function(uid, deltaTable)
  ui._batchChanges[uid] = ui._batchChanges[uid] or {}
  for k,v in pairs(deltaTable) do
    ui._batchChanges[uid][k] = v
  end

  local co = coroutine.create(function()
    while(next(ui._batchChanges)) do
      while(self.UI.loading) do coroutine.yield(0) end
      for uid,eachChange in pairs(ui._batchChanges) do
        --while(self.UI.loading) do coroutine.yield(0) end
        self.UI.setAttributes(uid, eachChange)
      end
      ui._batchChanges = {}
      coroutine.yield()
    end
    ui._batchCo = false
  end)

  if not ui._batchCo then
    ui._batchCo = co
    Coru.run(co)
  end
end

ui.animateHeaderColor = function(toColor, callback)
  local co = coroutine.create(function()
    --self.UI.setAttributes("Header_ProgressMask", {active = true, width = 5})
    ui.batchSet("Header_ProgressMask", {active = true, width = 6, color = toColor})
    self.UI.show("Header_ProgressMask")
    ui.batchSet("Header_GradientTransition", {color = toColor})
    ui.batchSet("Header_DecoTransition", {color = toColor})
    self.UI.show("Header_GradientTransition")
    self.UI.show("Header_DecoTransition")
    self.UI.hide("Header_Deco")
    self.UI.hide("Header_Gradient")
    local p = 0
    local t1 = Time.time

    while(p < 1) do
      p = (Time.time - t1)/3
      p = p <= 1 and p or 1 --was going over 1 for some reason?
      local val = Tween.easeIn(p) * 2030--296
      ui.batchSet("Header_ProgressMask",{width = val})
      coroutine.yield(p)
    end
    ui.setHeaderColor(toColor)
  end)

  Tac.color = toColor
  Coru.run(co, {callback = callback})
end

ui.setHeaderColor = function(color)
  local toColor = color or ActivePlayer.color
  Tac.color = toColor

  self.UI.hide("Header_ProgressMask")
  ui.batchSet("Header_ColorProgress", {color = toColor})

  ui.batchSet("Header_Gradient", {color = toColor, active = true})
  ui.batchSet("Header_Deco", {color = toColor, active = true})
  self.UI.hide("Header_GradientTransition")
  self.UI.hide("Header_DecoTransition")
  self.UI.show("Header_Gradient")
  self.UI.show("Header_Deco")
end

ui._activeTacStep = false
ui._TacStepAnimation = false
--params: all optional- stepName defaults to the currently open step
--params = {disable = false, skipAnimation = false, callback = nil}
ui.setTacStep = function(stepName, params)
  params = params or {}
  params.skipAnimation = Tac.disableAnimations or params.skipAnimation
  local function tryCallback() if params.callback then params.callback() end end

  stepName = stepName or ui._activeTacStep
  if not stepName then return tryCallback() end
  local open = params.disable ~= true
  if (open and ui._activeTacStep == stepName) or (not open and ui._activeTacStep ~= stepName)then return tryCallback() end
  local switch = {--step name to ui id
    ["Movement"] = {
      stateBtn = "Btn_MovementState",
      cover = "Img_MovementCover",
      panel = "Pnl_MovementStep_Active",
      lower = {"SpaceCombat", "Invasion"},
      labels = {"BtnBounds_SpaceCombatState", "BtnBounds_InvasionState"},
      footer = "Img_MovementFooterCover",
      --These buttons seem to be clickable while their perent is not active, even tho they are invisible, so manually setting intereactable = false
      childButtons = {"Btn_ConfirmMovement_Outline", "Btn_ConfirmMovement", "Btn_Roll_SpaceCannonOff", "Btn_Roll_SpaceCannonOff_Outline", "SmartBtn_SpaceCannonOff_Att", "SmartBtn_SpaceCannonOff_Def"}
    },
    ["SpaceCombat"] = {
      stateBtn = "Btn_SpaceCombatState",
      cover = "Img_SpaceCombatCover",
      panel = "Pnl_SpaceCombatStep_Active",
      lower = {"Invasion"},
      labels = {"BtnBounds_InvasionState"},
      footer = "Img_SpaceCombatFooterCover",
      childButtons = {"Btn_Roll_AFB", "Btn_Roll_AFB_Outline","Btn_Roll_SpaceCombat_Outline", "Btn_Roll_SpaceCombat", "SmartBtn_SpaceCombat_Att", "SmartBtn_SpaceCombat_Def", "SmartBtn_AFB_Att", "SmartBtn_AFB_Def"}
    },
    ["Invasion"] = {
      stateBtn = "Btn_InvasionState",
      cover = "Img_InvasionCover",
      panel = "Pnl_InvasionStep_Active",
      lower = {},
      labels = {},
      --footer = "",
      childButtons = {"Btn_BombardmentMode", "Btn_SpaceCannonDefMode", "SmartBtn_SpaceCannonDef", "SmartBtn_Bombardment",
                      "Btn_Roll_InvasionContext", "Btn_Roll_InvasionContext_Outline", "SmartBtn_InvasionContext_Att","SmartBtn_InvasionContext_Def"}
    }
  }
  if ui._TacStepAnimation then Coru.stop(ui._TacStepAnimation) ui._TacStepAnimation = false end
  ui._activeTacStep = open and stepName or false
  if stepName == "Invasion" then --Stripping this out into its own func since the animation is so different
    ui.setInvasionStep(params) return
  end
  local data = assert(switch[stepName])

  --Pre animation
  -----------------------------------------------------------
  ui.batchSet(data.panel, {active = true})
  ToggleButton.setState(ToggleButton.btns[data.stateBtn], open)
  --turn lowers off
  for _, each in ipairs(data.lower) do
    ui.batchSet(switch[each].panel, {active = false})
  end
  if open then
    --enable child buttons
    for _, each in ipairs(data.childButtons) do
      ui.batchSet(each, {interactable = true, active = true})
    end
  end

  local pos = open and -1120 or 0
  local coverOffset = 20
  local labelGap = 280 - 60 --dist + coverOffset
  local labelOffset = open and labelGap or 0

  --Post animation
  -----------------------------------------------------------
  local function onAnimComplete(completeCode)
    ui._TacStepAnimation = false
    if completeCode == -1 then return end

    ui.batchSet(data.cover, {offsetXY = "0 " .. (pos + coverOffset), active = true})
    for _,each in ipairs(data.labels) do
      ui.batchSet(each, {offsetXY = "0 " .. (pos + labelOffset)})
    end
    --Set childrenButtons interactable/active
    for eachStep, tbl in pairs(switch) do
      for _, eachBtn in ipairs(tbl.childButtons) do
        local bool = open and eachStep == stepName or false
        ui.batchSet(eachBtn, {interactable = bool, active = bool})
      end
    end
    --Set footer
    ui.batchSet(data.footer, {active = not open})

    --keep all masks on if no step is open
    if not open then
      for eachStep,data in pairs(switch) do
        ui.batchSet(data.panel, {active = true})
      end
    end

    tryCallback()
  end

  if params.skipAnimation then
    onAnimComplete()
  else
    --Animate
    -----------------------------------------------------------
    local duration = open and 0.75 or 0.5
    local t1 = Time.time
    local delta = 1120
    local footerSet = false
    local labelSet = false
    ui._TacStepAnimation = coroutine.create(function()
      while Time.time - t1 <= duration do
        local percent = (Time.time - t1)/duration
        local next = Tween.lerp(0, delta, Tween.easeOut(percent))
        next = open and -next or -(delta - next)
        ui.batchSet(data.cover, {offsetXY ="0 " .. (coverOffset + next)})

        --Move labels with gap/delay
        if next + labelGap <= 0 then
          for _,each in ipairs(data.labels) do
            ui.batchSet(each, {offsetXY = "0 " .. (next + labelGap)})
          end
        elseif not labelSet then
          --When the labels reach their approximate final position, set it to the real final pos
          --Fixes image jumping when 'next' changes alot between frames. (frame1_next + gap) = -1 ...--> (frame2_next + gap) = 5 (pixel jump of 6)
          labelSet = true
          for _,each in ipairs(data.labels) do
            ui.batchSet(each, {offsetXY = "0 0"})
          end
        end

        if not footerSet and ((open and percent >= 0.7) or (not open and percent >= 0.1)) then
          footerSet = true
          ui.batchSet(data.footer, {active = not open})
        end

        coroutine.yield(percent)
      end
      return 1
    end)
    Coru.run(ui._TacStepAnimation, {callback = onAnimComplete})
  end
end

--dont call directly, child func on setTacStep
ui.setInvasionStep = function(params)
  params = params or {}
  local open = params.disable ~= true
  ui._activeTacStep = open and "Invasion" or false

  --Pre animation
  ui.batchSet("Pnl_InvasionStep_Active", {active = true})
  ui.batchSet("Hex_ActivePlayer", {color = ActivePlayer.color})
  ToggleButton.setState(ToggleButton.btns["Btn_InvasionState"], open)
  local delta = 1945
  local headerOff = 20
  local headerMax = 1815
  local rectMin = 5

  ui.batchSet("Img_FooterFade", {active = true})
  if open then
    self.UI.hide("Img_FooterFade")
    Invasion.setActive(true)
  else
    self.UI.show("Img_FooterFade")
  end

  --Post animation
  local function onAnimComplete()
    ui._TacStepAnimation = false
    ui.batchSet("Img_InvasionCoverRect", {height = rectMin+ (open and 0 or delta)})
    ui.batchSet("Img_InvasionCover", {active = true, offsetXY = "0 " .. headerOff + (open and -headerMax or 0)})
    Invasion.setActive(open)

    if params.callback then params.callback() end
  end

 if params.skipAnimation then
   onAnimComplete()
 else
   --Animate
   -------------------------------------------
   local duration = open and 0.9 or 0.75
   local t1 = Time.time

   ui._TacStepAnimation = coroutine.create(function()
     while Time.time - t1 <= duration do
       local percent = (Time.time - t1)/duration
       local pos = Tween.lerp(0, delta, Tween.easeOut(percent))
       --pos = open and -pos or -(delta - next)
       ui.batchSet("Img_InvasionCoverRect", { height = rectMin + (open and delta - pos or pos)})
       --Constrain how far the header can open
       pos = (open and pos > headerMax) and headerMax or pos
       ui.batchSet("Img_InvasionCover", {offsetXY = "0 " .. headerOff + (open and -pos or (pos - delta))})

       coroutine.yield(percent)
     end
     return 1
   end)
   Coru.run(ui._TacStepAnimation, {callback = onAnimComplete})
 end
end

ui.enableTacStepButtons = function(enabled)
  local bool = enabled and true or false
  ui.batchSet("Btn_SpaceCombatState", {interactable = bool})
  ui.batchSet("Btn_MovementState", {interactable = bool})
  ui.batchSet("Btn_InvasionState", {interactable = bool})
end

ui.setSmartButtonColors = function(setDefenders, setBoth)
  if setDefenders then
    local defenderBtns = {"SmartBtn_SpaceCombat_Def", "SmartBtn_AFB_Def"}
    for _,each in ipairs(defenderBtns) do
      ui.batchSet(each, {color = MultiRoller.getDefender("Space")})
    end

    ui.batchSet("SmartBtn_InvasionContext_Def", {color = MultiRoller.getDefender(Invasion.focus) or "Grey"})
    if not setBoth then return end
  end

  local attackerBtns = {"SmartBtn_SpaceCannonOff_Att", "SmartBtn_SpaceCombat_Att", "SmartBtn_AFB_Att", "SmartBtn_Bombardment"}
  for _,each in ipairs(attackerBtns) do
    ui.batchSet(each, {color = ActivePlayer.color})
  end
end

--Main--------------------------------------------------------------------------
--optional params: color (defaults to ActivePlayer.color), skipAnimation = bool, callback
Tac.setColor = function(params)
  params = params or {}
  params.skipAnimation = params.skipAnimation or Tac.disableAnimations

  local toColor = params.color or ActivePlayer.color
  if ActivePlayer.color ~= toColor then ActivePlayer.update(toColor) end
  local function tryCallback()
    if params.callback then params.callback() end
  end
  if toColor == Tac.color then tryCallback() return end
  Tac.color = toColor

  if params.skipAnimation then
    ui.setHeaderColor(toColor)
    _cmdToken.setDisplayToken(toColor, true, params.callback)
  else
    ui.animateHeaderColor(toColor, params.callback)
    _cmdToken.setDisplayToken(toColor, false)
  end
  ui.setSmartButtonColors()
end

Tac._resolveTurnReset = false
Tac.onGameEvent = function(event, params)
  params = params or {}

  --expects params: {active = bool, tacStep = Tac.eStates}
  local function resolveTacStepBtnClicked()
    local state = assert(params.tacStep)
    local activate = params.activate or false

    if not activate then
      Tac.setState(Tac.eStates.Turns(), {fastOpen = true})
    elseif ActivePlayer.system then
      if Tac.highlightAdjSystems[ActivePlayer.color] then _systemHelper.getAdjacentSystems({color = ActivePlayer.color, highlight = true}) end
      Tac.setState(state, params)
    end
  end

  --params = {color, system, (optional)token = objRef to TacToken}
  local function resolveSystemActivated()
    assert(params.color and params.system)
    ActivePlayer.update(params.color or Turns.turn_color)
    ActivePlayer.prevSystem = ActivePlayer.system
    ActivePlayer.system = params.system

    Tac.isActionPhase = true
    Tac.setColor({skipAnimation = true})
    ui.enableTacStepButtons(true)
    ui.setSubheaderTxt(ui.eSubTxt.FactionName())
    ui.setSmartButtonColors()
    MultiRoller.buildTacData(params.system)
    _cmdToken.animateActivation(function()
      --after animation, maybe set state to movement
      if not Tac.inStateTransition then
        if Tac.State == Tac.eStates.Invasion() or  Tac.State == Tac.eStates.SpaceCombat() then
          Tac.updateActiveState()
        else
          Tac.setState(Tac.eStates.Movement())
        end
      end
    end)
  end

  local function resolvePlayerPassed()
    if not Tac.isActionPhase then return end

    --Have all players passed?
    local players = _zoneHelper.zones()
    local allPassed = true
    for _,eachCol in ipairs(players) do
      if not data.isPlayerPassed(eachCol) then allPassed = false break end
    end

    if allPassed then
      Tac.onGameEvent(Tac.eGameEvents.EndActionPhase())
    elseif Tac.State == Tac.eStates.Turns() then --update to remove player name from active players
      ui.setTurnUI(true)
    end
  end

  --Triggered on onPlaceTradeGoodsAndSetTurns, or if a system is activated outside of the action phase
  local function resolveStartActionPhase()
    Tac.isActionPhase = true
    Wait.frames(function()
      Tac.onGameEvent(Tac.eGameEvents.NewActivePlayer())
    end, 1)
  end

  --triggered when the last active/passed token has been flipped
  local function resolveEndActionPhase()
    Tac.isActionPhase = false
    Tac.setState(Tac.eStates.Main(), params)
  end

  --expects params: {color, prev, skipAnimation = bool}
  local function resolveNewActivePlayer()
    local newColor = params.color or (Turns.enable and Turns.turn_color or "Grey")
    if not _zoneHelper.zoneAttributes(newColor) then Tac.setState(Tac.eStates.Main(), params) return end

    ActivePlayer.update(newColor)
    if ActivePlayer.color == Tac.color then
      _cmdToken.animateActivation()
      return
    end

    Tac.setColor({color = newColor, skipAnimation = params.skipAnimation or Tac.disableAnimations})
    Tac.setState(Tac.eStates.Turns(), params)
  end

  --params: {color, prev, turnsDisabled = bool}
  local function resolvePlayerTurnStart()
    if not Tac.isActionPhase or Tac.color == params.color then return end
    local turnsDisabled = params.color == "Grey"

    if turnsDisabled then
      if Tac._resolveTurnReset then return end --dont stack waits
      Tac._resolveTurnReset = true
      Wait.frames(function()
        if not Tac._resolveTurnReset then return end --cancel wait if turn was re-enabled
        Tac._resolveTurnReset = false
        Tac.setState(Tac.eStates.Main())
      end, 1)
      return
    end
    --else:
    Tac._resolveTurnReset = false --override and cancel any turn reset that may have been called earlier this frame
    Tac.onGameEvent(Tac.eGameEvents.NewActivePlayer(), params)
  end

  local function resolveUnitMapUpdated()
    ui.setSmartButtonColors(true)
    Planets.updateShields()
  end

  local switch = { --Each key coresponds to an entry in: Tac.eGameEvents
    ["StartActionPhase"] = resolveStartActionPhase,
    ["EndActionPhase"] = resolveEndActionPhase,
    ["NewActivePlayer"] = resolveNewActivePlayer,
    ["PlayerTurnStart"] = resolvePlayerTurnStart,
    ["SystemActivated"] = resolveSystemActivated,
    ["PlayerPassed"] = resolvePlayerPassed,
    ["TacStepBtnClicked"] = resolveTacStepBtnClicked,
    ["UnitMapUpdated"] = resolveUnitMapUpdated,
  }
  switch[event]()
end

--params{skipAnimation = bool, fastOpen/fastClose = bool} callback = func
    --skipAnimation skips both the open and closing animation of states, fastOpen/Close skips only the respective opening/closing
Tac.setState = function(toState, params, callback)
  --print("\nTry setState to >", toState, "<\nState|Prev|Transit")
  --print(Tac.State, "|", Tac.previousState, "|", Tac.inStateTransition)
  if Tac.inStateTransition then Tac.inStateTransition = toState Tac._onStateOpen = callback return end
  if toState == Tac.State  then Tac.updateActiveState(callback, params) return end
  if callback then Tac._onStateOpen = callback end
  params = params or {}

  --print("\nSetting state to ", toState, " from ", Tac.State)
  local function onOpenComplete()
    if Tac.State == Tac.inStateTransition then
      Tac.inStateTransition = false
      Tac.onStateOpen()
    else --A request to change state may have been made while opening this state
      local quedState = Tac.inStateTransition
      Tac.inStateTransition = false
      Tac.setState(quedState, params)
    end
    --print("State set to ", Tac.State)
  end

  local function onCloseComplete()
    --print("Openeing >", Tac.inStateTransition, "<")
    Tac.State = Tac.inStateTransition
    Tac.openState(Tac.State, onOpenComplete, params)
  end

  Tac.inStateTransition = toState
  Tac.previousState = Tac.State
  --print("Closing >", Tac.previousState, "<")
  Tac.closePreviousState(onCloseComplete, params)
end

--params{ skipAnimation = bool, fastOpen = bool}
Tac.openState = function(state, callback, params)
  params = params or {}
  params.skipAnimation = params.skipAnimation or Tac.disableAnimations
  local function tryCallback()
    if callback then callback() end
  end
  if not Tac.inStateTransition and state == Tac.State then tryCallback() return end

  local function openMain()
    ActivePlayer.update("Grey")
    self.UI.show("icon_agenda")
    ui.setSubheaderTxt(ui.eSubTxt.NonActive())
    Tac.setColor({color = "Grey", skipAnimation = params.skipAnimation or params.fastOpen, callback = callback})
  end

  local function openTurns()
    ui.setTurnUI(true)
    ui.setSubheaderTxt(ActivePlayer.system and ui.eSubTxt.FactionName() or ui.eSubTxt.Activate())
    ui.enableTacStepButtons(ActivePlayer.system)
    tryCallback()
  end

  local function openInvasion()
    ui.setTacStep(state, {callback = callback, skipAnimation = params.skipAnimation or params.fastOpen})
  end

  local function openSpaceCombat()
    ui.setTacStep(state, {callback = callback, skipAnimation = params.skipAnimation or params.fastOpen})
  end

  local function openMovement()
    ui.setTacStep(state, {callback = callback, skipAnimation = params.skipAnimation or params.fastOpen})
    if Tac.highlightAdjSystems[ActivePlayer.color] then
      print("TODO: Set adj system highlight btn")
      --highlight will be applied during buildTacData
    end
  end

  local switch = {
    ["Main"] = openMain,
    ["Turns"] = openTurns,
    ["Invasion"] = openInvasion,
    ["SpaceCombat"] = openSpaceCombat,
    ["Movement"] = openMovement,
    ["catch"] = function() print("Attempting to open unknown state: ", state) tryCallback() end
  }
  --print("Opening state >", state, "<")
  local try = switch[state] and state or "catch"
  switch[try]()
end

Tac.onStateOpen = function()
  if Tac._onStateOpen then Tac._onStateOpen() end
  Tac._onStateOpen = false
end

--params {skipAnimation = bool, fastClose = bool}
Tac.closePreviousState = function(callback, params)
  params = params or {}
  params.skipAnimation = params.skipAnimation or Tac.disableAnimations
  local function tryCallback()
    if callback then callback() end
  end

  local function closeMain()
    local closeCo = coroutine.create(function()
      self.UI.hide("icon_agenda")
      local t1 = Time.time
      while Time.time -t1 <= 1.25 do
        coroutine.yield(0)
      end
      return 1
    end)
    if params.skipAnimation or params.fastClose then
      self.UI.hide("icon_agenda")
      tryCallback()
    else
      Coru.run(closeCo, {callback = callback})
    end
  end

  local function closeTurns()
    ui.setTurnUI()
    tryCallback()
  end

  local function closeInvasion()
    ui.setTacStep(Tac.eStates.Invasion(),{callback = callback, skipAnimation = params.skipAnimation or params.fastClose, disable = true})
  end

  local function closeSpaceCombat()
    ui.setTacStep(Tac.eStates.SpaceCombat(),{callback = callback, skipAnimation = params.skipAnimation or params.fastClose, disable = true})
  end

  local function closeMovement()
    ui.setTacStep(Tac.eStates.Movement(), {callback = callback, skipAnimation = params.skipAnimation or params.fastClose, disable = true})
    _systemHelper.removeSystemHighlights()
  end

  local switch = {
    ["Main"] = closeMain,
    ["Turns"] = closeTurns,
    ["Initializing"] = tryCallback,
    ["Uninitialized"] = tryCallback,
    ["Invasion"] = closeInvasion,
    ["SpaceCombat"] = closeSpaceCombat,
    ["Movement"] = closeMovement,
    ["catch"] = function() print("Attempting to close unrecognized state: ", Tac.previousState) tryCallback() end
  }
  --print("Closing state >", Tac.previousState, "<")
  local try = switch[Tac.previousState] and Tac.previousState or "catch"
  switch[try]()
  --switch[Tac.previousState]()
end

--params {skipAnimation = bool, callback}
Tac.updateState = function(state, callback, params)
  if Tac.inStateTransition then return end
  params = params or {}
  params.skipAnimation = params.skipAnimation or Tac.disableAnimations

  local function updateTurns()
    ui.setTurnUI(true)
    ui.setSubheaderTxt(ui.eSubTxt.Activate())
    ui.enableTacStepButtons(ActivePlayer.system)
  end

  local switch = {
    ["Main"] = function() end,
    ["Turns"] = updateTurns,
    ["Initializing"] = function() end,
    ["Uninitialized"] = function() end,
    ["Invasion"] = function() end,
    ["SpaceCombat"] = function() end,
    ["Movement"] = function() end,
    ["catch"] = function() print("Trying to update unknown state: ", state) if callback then callback() end end
  }
  --print("Updating state >", state, "<")
  local try = switch[state] and state or "catch"
  switch[try]()
end

Tac.updateActiveState = function(callback, params)
  Tac.updateState(Tac.State, callback, params)
end

--Invasion UI handler-----------------------------------------------------------
Invasion.active = false
Invasion.State = "Overview"
Invasion.eStates = {
  Overview = function() return "Overview" end,
  Bombardment = function() return "Bombardment" end,
  SpaceCannonDef = function() return "SpaceCannonDef" end,--SpC defense
  GroundCombat = function() return "GroundCombat" end,
}

-------State machine
Invasion.reset = function()
  Invasion.setContext()
  Invasion.setFocus()
  --update active system data
  Invasion.setState(Invasion.eStates.Overview())
  Invasion.setActive(Tac.State == Tac.eStates.Invasion())
end

Invasion.setActive = function(activate, skipAnimation)
  activate = activate and true or false
  if Invasion.active == activate then return end
  Invasion.active = activate

  --When the panel is closed, buttons need to be explicitly de-activated or the mouse pointer will have the button effect while hovering over the invisible elements
  local _childButtons = {"Btn_BombardmentMode", "Btn_SpaceCannonDefMode", "SmartBtn_SpaceCannonDef", "SmartBtn_Bombardment"}
  local _contextButtons = {"Btn_Roll_InvasionContext", "Btn_Roll_InvasionContext_Outline", "SmartBtn_InvasionContext_Att","SmartBtn_InvasionContext_Def"}

  for _,each in ipairs(_childButtons) do
    ui.batchSet(each, {active = activate, interactable = activate})
  end

  local pCount = ActivePlayer.system and ActivePlayer.system.planets and #ActivePlayer.system.planets or 0
  for i = 1, 5, 1 do --Only reactivate buttons on visible planets
    ui.batchSet("p"..i.."_ColorRing", {active = activate and i <= pCount or false, interactable = activate and i <= pCount or false})
    ui.batchSet("p"..i.."_QuickBombard", {active = activate and i <= pCount or false, interactable = activate and i <= pCount or false})
    ui.batchSet("p"..i.."_QuickPDS", {active = activate and i <= pCount or false, interactable = activate and i <= pCount or false})
    local hasShield = Planets.shieldStatus[i] and Planets.shieldStatus[i].enabled ~= 0 or false
    ui.batchSet("p"..i.."_Btn_shieldOverride", {active = hasShield, interactable = hasShield})
  end

  if activate then
    --first time opening for this system? Build the system
    if not Planets._displayedSystem or (Planets._displayedSystem and Planets._displayedSystem ~= ActivePlayer.system) then
      Invasion.setState(Invasion.eStates.Overview())
      Invasion.setFocus()
      Planets.buildActiveSystem(nil, skipAnimation)
    else --Keep current focus and context
      Invasion.setState(Invasion.eStates.Overview())
      Invasion.showContextButtons()
      Invasion.showFocusButtons()
      Planets.buildActiveSystem(nil, skipAnimation)
    end
  end
end

Invasion.setState = function(state, params)
  if state ~= Invasion.State then Invasion.closeActiveState(params) end
  Invasion.State = state
  Invasion.openState(state, params) --open/refresh
end

Invasion.openState = function(state, params)
  params = params or {}

  local function openSpaceCannon()
    --sync ToggleButton
    ToggleButton.setState(ToggleButton.btns["Btn_SpaceCannonDefMode"], true)

    Invasion.setContext(state)
    ui.batchSet("SmartBtn_SpaceCannonDef", {color = MultiRoller.getDefender(Invasion.focus) or "Grey"})
  end

  local function openBombardment()
    ToggleButton.setState(ToggleButton.btns["Btn_BombardmentMode"], true)

    Invasion.setContext(state)
    ui.batchSet("SmartBtn_Bombardment", {color = ActivePlayer.color or "Grey"})

    Invasion.updatePlasmaUI(true)
  end

  local function openCombat()
    Invasion.setContext(state)
  end

  local function openOverview()
    Invasion.setContext()
  end

  local switch = {
    ["Overview"] = openOverview,
    ["GroundCombat"] = openCombat,
    ["Bombardment"] = openBombardment,
    ["SpaceCannonDef"] = openSpaceCannon,
    ["catch"] = function() print("Caught unregisted case >", state, "< in Invasion.OpenState") return end
  }
  local try = switch[state] and state or "catch"
  switch[try]()
end

Invasion.closeActiveState = function(params)
  params = params or {}

  local function closeSpaceCannon()
    --sync ToggleButton
    ToggleButton.setState(ToggleButton.btns["Btn_SpaceCannonDefMode"], false)
  end

  local function closeBombardment()
    ToggleButton.setState(ToggleButton.btns["Btn_BombardmentMode"], false)
    Invasion.updatePlasmaUI(false)
    --Handle bombardment helper
  end

  local function closeOverview()
  end
  local function closeCombat()
  end

  local switch = {
    ["Overview"] = closeOverview,
    ["GroundCombat"] = closeCombat,
    ["Bombardment"] = closeBombardment,
    ["SpaceCannonDef"] = closeSpaceCannon,
    ["catch"] = function() print("Caught unregisted case >", Invasion.State, "< in Invasion.closeActiveState") return end
  }
  local try = switch[Invasion.State] and Invasion.State or "catch"
  switch[try]()
end

Invasion.onSystemActivated = function()
  if not Invasion.active then return end

  --first time opening for this system? Build the system
  if not Planets._displayedSystem or (Planets._displayedSystem and Planets._displayedSystem ~= ActivePlayer.system) then
    Invasion.setState(Invasion.eStates.Overview())
    Invasion.setFocus()
    Planets.buildActiveSystem()
  else --Keep current focus and context
    Invasion.setState(Invasion.eStates.Overview())
    Invasion.showContextButtons()
    Invasion.showFocusButtons()
    Planets.buildActiveSystem()
  end
end

-------Context and Focus
Invasion.focus = false --or planetName
Invasion.iFocus = 1 --index of the focus planet in its system's planet table
Invasion._waitingFocus = {i = false, name = false}
Invasion.setFocus = function(pIndex, skipAnimation) --index of the planet in its system's "planets" table
  local target = pIndex and Planets.getName(pIndex) or false

  --Repeated setting a target removes that target from focus like a toggle
  local _currentNextState = Invasion._waitingFocus.name or Invasion.focus
  target = target ~= _currentNextState and target

  if target == _currentNextState then return end --?removing focus, but have none

  --prevent focus setting while animating
  if not Invasion.active or Planets._nextSystem or Planets.AnimState == Planets.eAnim.clearing() or Planets.AnimState == Planets.eAnim.building() then return end
  if target then --validate the target planet
    --Check active system has a planet to focus
    if not ActivePlayer.system or not ActivePlayer.system.planets or not next(ActivePlayer.system.planets) then return end
    --Check target is in active system
    local inSystem = false
    for _,each in ipairs(ActivePlayer.system.planets) do
      if each.name == target then inSystem = true break end
    end
    if not inSystem then return end
  end

  Invasion.focus = target
  Invasion.iFocus = target and pIndex
  Invasion._waitingFocus = {i = target and pIndex, name = target}

  local function onFocusChangeComplete()
    if Invasion._waitingFocus.name ~= Invasion.focus then
      local nextFocus = Invasion._waitingFocus.i
      Invasion._waitingFocus = {i = false, name = false}
      Invasion.setFocus(nextFocus, skipAnimation)
      return
    end
    Invasion._waitingFocus = {i = false, name = false}

    local fBool = Invasion.focus and true or false
    if fBool then
      ui.batchSet("SmartBtn_InvasionContext_Def", {color = Planets.getOwnerColor(target)})
      ui.batchSet("Txt_HexFocusLabel", {text = string.upper(target)})
      --enter ground combat context when planet is clicked
      if not Invasion.context then Invasion.setState(Invasion.eStates.GroundCombat()) end
    else
      --Ground combat state is only available while a planet is in focus
      if Invasion.State == Invasion.eStates.GroundCombat() then Invasion.setState(Invasion.eStates.Overview()) end

      --maybe remove smart button color
      local soloPlanet = ActivePlayer.system and ActivePlayer.system.planets and #ActivePlayer.system.planets == 1 and ActivePlayer.system.planets[1].name or false
      ui.batchSet("SmartBtn_InvasionContext_Def", {color = soloPlanet and Planets.getOwnerColor(soloPlanet) or "Grey"})
    end
    ui.batchSet("Hex_FocusNameplate", {active = fBool})
  end

  Planets.setFocus({callback = onFocusChangeComplete, skipAnimation = skipAnimation}, not target)
end

Invasion.showFocusButtons = function(hide)
  hide = hide and true or false
  local show = not hide
  if show and not Invasion.foucs then return end

  --ui.batchSet("", {active = show, interactable = show})
end

--Context refers to the "Context Button" that appears at the base of the hex
--It determines what is rolled for when it is pressed
Invasion.context = false
Invasion.setContext = function(state)
  local contextSettings = {
    ["GroundCombat"] = {context = "groundCombat", label = "GROUND COMBAT", defender = Invasion.focus},
    ["Bombardment"] = {context = "bombardment", label = "BOMBARDMENT", defender = false},
    ["SpaceCannonDef"] = {context = "spaceCannonDef", label = "SPACE CANNON", defender = Invasion.focus}
  }
  Invasion.context = contextSettings[state] and contextSettings[state].context or false
  local setActive = Invasion.context and true or false
  ui.batchSet("Btn_Roll_InvasionContext_Outline", {active = setActive, interactable = setActive})
  ui.batchSet("Btn_Roll_InvasionContext", {active = setActive, interactable = setActive})
  ui.batchSet("Btn_Roll_InvasionContext_Txt", {text = setActive and contextSettings[state].label or ""})
  --Set smart context colors
  ui.batchSet("SmartBtn_InvasionContext_Att", {active = setActive, interactable = setActive, color = setActive and ActivePlayer.color or "Grey"})
  ui.batchSet("SmartBtn_InvasionContext_Def", {active = setActive, interactable = setActive,
    color = setActive and contextSettings[state].defender and MultiRoller.getDefender(contextSettings[state].defender) or "Grey"})
end

--Setting context also shows
Invasion.showContextButtons = function(hide)
  hide = hide and true or false
  local show = not hide
  if show and not Invasion.context then return end

  ui.batchSet("SmartBtn_InvasionContext_Att", {active = show, interactable = show})
  ui.batchSet("SmartBtn_InvasionContext_Def", {active = show, interactable = show})
  ui.batchSet("Btn_Roll_InvasionContext_Outline", {active = show, interactable = show})
  ui.batchSet("Btn_Roll_InvasionContext", {active = show, interactable = show})
end

------Orbitals/Planets
Invasion.orbitals = {}
Invasion.orbitIds = {}

Invasion.getOrbitals = function(system_guid)
  system_guid = system_guid or (ActivePlayer.system and ActivePlayer.system.guid)
  if not system_guid then return end
  if Invasion.orbitals[system_guid] then return Invasion.orbitals[system_guid] end

  --generate orbital layout
  local systemOrbit = {
    unused = {},
  }
  Invasion.orbitals[system_guid] = systemOrbit
  return systemOrbit
end

Invasion.animator = false
Invasion.animateOrbitals = function(orbit, reverse)
end

Invasion.updatePlasmaUI = function(setActive)
  local function disablePS()
    for i = 1, 5, 1 do
      ui.batchSet("p"..i.."_Btn_PlasmaScoring", { active = false, interactable = false, isOn = false})
    end
    Planets.plasmaTarget = false
    return
  end
  if not setActive then disablePS() return end
  --else

  if not Invasion.active or Invasion.State ~= Invasion.eStates.Bombardment() then return end
  local modifiers = _getColorToUnitModifiers() or {}
  local hasPlasmaScoring = false
  for _, modifier in ipairs(modifiers[ActivePlayer.color] or {}) do
      if modifier == 'Plasma Scoring' then
          hasPlasmaScoring = true
          break
      end
  end
  if not hasPlasmaScoring then disablePS() return end

  local _firstOtherPlanet = Planets.plasmaTarget == false --only asign default if we dont have an existing target
  for i,eachPlanet in ipairs(ActivePlayer.system.planets or {}) do
    local _isOn = _firstOtherPlanet and Planets.getOwnerColor(eachPlanet.name, eachPlanet) ~= ActivePlayer.color
    if _isOn then
      _firstOtherPlanet = false
      Planets.plasmaTarget = i
    end

    ui.batchSet("p"..i.."_Btn_PlasmaScoring", { active = true, interactable = true, isOn = _isOn})
  end

  Invasion.setPlasmaTarget(Planets.plasmaTarget)
end

--set planetIndex = nil to remove any target
Invasion.setPlasmaTarget = function(planetIndex)
  local target = (not planetIndex or planetIndex == Planets.plasmaTarget) and -1 or planetIndex
  target = target <= 5 and target or -1

  Planets.plasmaTarget = target > 0 and target
  if not Invasion.active or Invasion.State ~= Invasion.eStates.Bombardment() then return end
  for i = 1, 5, 1 do
    ui.batchSet("p"..i.."_Btn_PlasmaScoring", {
      isOn = i == target,
      sprite = i == target and "Icon_PlasmaScoring_Active" or "Icon_PlasmaScoring",
      --highlightedSprite = "Icon_PlasmaScoring_Hover",
      pressedSprite = i == target and "Icon_PlasmaScoring" or "Icon_PlasmaScoring_Active",
    })
  end
end

--target = #index or string name of xml planet id {p1, p2,... p5}
--fromSystem defaults to the active system
Planets.getName = function(target, fromSystem)
  fromSystem = fromSystem or ActivePlayer.system
  if not fromSystem or not fromSystem.planets or not next(fromSystem.planets) then return nil end
  local switch = {
    ["p1"] = 1, ["p2"] = 2, ["p3"] = 3, ["p4"] = 4, ["p5"] = 5,
  }
  local i = type(target) == "string" and switch[target] or tonumber(target)
  return i <= #fromSystem.planets and fromSystem.planets[i].name or nil
end

Planets.getIndex = function(pName, fromSystem)
  fromSystem = fromSystem or ActivePlayer.system
  if not fromSystem or not fromSystem.planets or not next(fromSystem.planets) then return nil end
  for i,each in ipairs(fromSystem.planets) do
    if pName == each.name then return i end
  end
  return nil
end

--pTable = table of all planets in this system *optional, defaults to active system
--index = i of the planet in the pTable
Planets.getScale = function(index, pTable)
  pTable = pTable or (ActivePlayer.system and ActivePlayer.system.planets)
  if not pTable or not next(pTable) then return end

  local scale = Planets.focusLayouts[1][1].scale
  if Invasion.focus and Invasion.iFocus == index then
    return "" .. scale .. " " .. scale .. " 1"
  end

  local pCount = #pTable
  if Invasion.focus then index = Invasion.iFocus >= index and index or index -1 end

  scale = Invasion.focus and Planets.focusLayouts[pCount][index].scale or Planets.layouts[pCount][index].scale
  if pCount == 1 then--apply additional scale bassed on the planet's radius
    --ratio of change from default radius (a planet with the default radius will not be get additional scale)
    local radScale = (pTable[index].radius/0.8) * 0.7 --Reduce the change
    radScale = radScale >= 1 and radScale or 1 --Dont shrink small planets
    scale = scale * radScale
  end

  return "" .. scale .. " " .. scale .. " 1"
end

Planets.getOffset = function(index, pTable)
  pTable = pTable or (ActivePlayer.system and ActivePlayer.system.planets)
  if not pTable or not next(pTable) then return end

  if Invasion.focus and Invasion.iFocus == index then --== pTable[index].name or
    return Planets.focusLayouts[1][1].x .. " " .. Planets.focusLayouts[1][1].y
  end

  if Invasion.focus then index = Invasion.iFocus >= index and index or index -1 end
  local pCount = #pTable
  local offX = Invasion.focus and Planets.focusLayouts[pCount][index].x or Planets.layouts[pCount][index].x
  local offY = Invasion.focus and Planets.focusLayouts[pCount][index].y or Planets.layouts[pCount][index].y
  return offX .. " " .. offY
end

--indexOrName of planet
--pTable = table of all planets in this system *optional, defaults to active system
Planets.getOwnerColor = function(indexOrName, pTable)
  local function nameFromIndex()
    pTable = pTable or (ActivePlayer.system and ActivePlayer.system.planets)
    if not pTable or not next(pTable) or indexOrName <= 0 or indexOrName > #pTable then return "Grey" end

    return pTable[indexOrName] and pTable[indexOrName].name or "Grey"
  end

  --convert indexOrName to a name
  local pName = type(indexOrName) == "number" and nameFromIndex() or indexOrName or false
  if not pName then return "Grey" end --given name was not in given planet table or active system

  local pCard = Planets.getCard(pName)
  return pCard ~= nil and _zoneHelper.zoneFromPosition(pCard.getPosition()) or "Grey"
end

--params = {isHS = bool, scale, offset} (only set scale and offset to overrid the default settings)
Planets.setPlanet = function(index, planetData, pCount, params)
  params = params or {}
  local id = "p" .. index

  if not planetData then
    ui.batchSet(id, {active = false})
    ui.batchSet(id.. "_HS", {active = false})
    ui.batchSet(id.."_ColorRing", {active = false, interactable = false})
    ui.batchSet(id.."_QuickBombard", {active = false, interactable = false})
    ui.batchSet(id.."_QuickPDS", {active = false, interactable = false})
    ui.batchSet(id.."_Btn_shieldOverride", {active = false, interactable = false})
    return
  end

  local function getPlanetImage()
    if planetData.legendary then return "Wired_legendary" end
    if planetData.trait then return "Wired_" .. planetData.trait end
    if planetData.name == "Mecatol Rex" then return "Wired_Rex" end
    return "Wired_Planet" --HS or no trait
  end

  local function getFactionColor(getSecondary)
    --If not a faction planet, return owner color
    return Planets.getOwnerColor(index)
  end

  --else
  ui.batchSet(id, {active = true, offsetXY = params.offset or Planets.getOffset(index), scale = params.scale or Planets.getScale(index)})
  ui.batchSet(id.."_ColorRing", {active = true, interactable = true, color = Planets.getOwnerColor(index)})
  ui.batchSet(id.."_Planet", {image = getPlanetImage(), color = (planetData.trait or planetData.name == "Mecatol Rex") and "White" or getFactionColor()})
  ui.batchSet(id.."_HS", {active = params.isHS and true or false, color = "Orange"}) --getFactionColor("secondary")})
  ui.batchSet(id.."_Txt", {text = string.upper(planetData.name)})
  ui.batchSet(id.."_Trait", {active = planetData.trait and true or false})
  if planetData.trait and Planets.traits[planetData.trait] then ui.batchSet(id.."_Trait", {image = Planets.traits[planetData.trait]}) end
  --enable buttons
  ui.batchSet(id.."_QuickBombard", {active = true, interactable = true})
  ui.batchSet(id.."_QuickPDS", {active = true, interactable = true})
end

Planets.Animator = false
Planets.AnimState = false --Building, clearing, focusUp, focusDown
Planets.eAnim = {
  ["clearing"]  = function() return "clearing"  end,
  ["building"]  = function() return "building"  end,
  ["focusUp"]   = function() return "focusUp"   end,
  ["focusDown"] = function() return "focusDown" end,
  --["idle"] = function() return "idle" end
}

Planets._iFocus = 1 -- the index of the currently focused planet in its system table
Planets._displayedFocus = false
--params = {callback, skipAnimation, fast = bool}
Planets.setFocus = function(params, disable)
  params = params or {}
  local skipAnim = params.skipAnimation or Tac.disableAnimations
  local function tryCallback() if params.callback then params.callback() end end

  --Are we already displaying the current focus target?
  if (disable and not Planets._displayedFocus) or (not disable and Invasion.focus == Planets._displayedFocus) then tryCallback() return end

  --Resolve focusUp or Down
  if skipAnim then
    Planets._displayedFocus = Invasion.focus
    Planets.buildActiveSystem(tryCallback, skipAnim)
    return
  end
  --else

  --Already have a different focus planet?--Quickly remove old focus
  if Planets._displayedFocus and not disable then
    --Planets.setFocus({callback = function() Planets.setFocus(params) end, skipAnimation = skipAnim, fast = true},"disable")
  end
  --[[
  Planets.AnimState = disable and Planets.eAnim.focusDown() or Planets.eAnim.focusUp()
  local _focusTarget = Invasion.focus
  local function onAnimComplete()
    Planets._displayedFocus = _focusTarget
    Planets.AnimState = false

    if Planets._displayedFocus ~= Invasion.focus and not params.ignoreMismatch then --A new focus was set during animation
      Planets.setFocus({skipAnimation = true, callback = params.callback})
      return
    end
    tryCallback()
  end

  Planets.Animator = Animate.newController()
  Planets.Animator.onComplete = onAnimComplete
  local co = coroutine.create(function()
    local iTime = Time.time
    local duration = fast and 0.3 or 1.2
    local iPos = 0
    local iScale = 0
  end)
  --Only activate buttons if Invasion.active is still true after animating

  --Planets.Animator.addClip()
  --Planets.Animator.run()
  --]]
  --temp
  Planets.buildActiveSystem(tryCallback, skipAnim)
  Planets._displayedFocus = Invasion.focus
  --^Temp
end

Planets._nextSystem = false --or {callback, system, building}
Planets.buildSystem = function(system, callback, skipAnimation)
  skipAnimation = Tac.disableAnimations or skipAnimation or false
  local function tryCallback() if callback then callback() end end

  local function onBuildComplete()
    if Planets._displayedSystem ~= Planets._nextSystem.system then
      print("Build complete error")
      --close and build?
      tryCallback()
      return
    end

    Planets._nextSystem = false
    Planets.updateShieldDisplay(skipAnimation)
    --enable buttons
    tryCallback()
  end

  local function onSystemCleared()
    if not Planets._nextSystem or not Planets._nextSystem.system.planets or #Planets._nextSystem.system.planets <= 0 then
      print("Error clearing system")
      --set/animate orbitals for empty
      tryCallback()
      return
    end
    ---else
    local target = Planets._nextSystem.system
    Planets._displayedSystem = target
    Planets._nextSystem.building = true

    local numPlanets = #target.planets
    for i = 1, numPlanets, 1 do
      Planets.setPlanet(i, target.planets[i], numPlanets, {isHS = target.home})
    end

    --Animate planet entry or skip to complete

    onBuildComplete()
  end

  --building/clearing may take time, prevent call stacking
  if Planets._nextSystem then Planets._nextSystem = {callback = callback, system = system, building = Planets._nextSystem.building} return end
  Planets._nextSystem = {callback = callback, system = system, building = false}
  if Planets._displayedSystem == system then --Quickly update system if we are rebuilding the currently displayed system
    skipAnimation = true
    onSystemCleared()
  else
    Planets._clearBuiltSystem(onSystemCleared, skipAnimation)
  end
end
Planets.buildActiveSystem = function(callback, skipAnimation)
  Planets.buildSystem(ActivePlayer.system, callback, skipAnimation)
end

Planets._clearBuiltSystem = function(callback, skipAnimation)
  if not Planets._displayedSystem then if callback then callback() end return end
  skipAnimation = skipAnimation or Tac.disableAnimations or false
  --maybe stop running build animation
  --Clear focus

  local function onClearComplete()
    for i = 1, 5, 1 do --hide planets
      Planets.setPlanet(i)
    end

    Planets._displayedSystem = false
    if callback then callback() end
  end

  local function resolveAnimation()
    --Planets.AnimState = Planets.eAnim.clearing()
    --clearFocus
    --Planets.animateFocus(callback, close, fast or skip)
    --Planets.animate(close, noSkip, callback)

    --temp
    onClearComplete()
  end

  if skipAnimation then onClearComplete()
  else resolveAnimation()
  end
end

--Sets the currently displayed system to the default empty system
Planets.clearSystem = function(callback, skipAnimation)
  if not Planets._displayedSystem then if callback then callback() end return end
  Planets.buildSystem({tile = -1, planets = {}}, callback, skipAnimation)
end

Planets._cache = {}--[pName] = cardObj
Planets.getCard = function(planetName)
  if Planets._cache[planetName] ~= nil then return Planets._cache[planetName] end

  --The first time the cache is loaded, find as many planets as possible in one go
  if not next(Planets._cache) then
    local allPlanets = _systemHelper.planets() or {}
    for _,eachObj in ipairs(getAllObjects()) do
      if eachObj.type == "Card" then
        local objName = eachObj.getName()
        if allPlanets[string.lower(objName)] then Planets._cache[objName] = eachObj end
      end
    end
    return Planets._cache[planetName]
  else -- just find the target planet
    for _,eachObj in ipairs(getAllObjects()) do
      if eachObj.type == "Card" and eachObj.getName() == planetName then
        Planets._cache[planetName] = eachObj
        return eachObj
      end
    end
  end
end

Planets._trackedCards = {}
--Update the color display to match the planet's owner when its card is dropped
Planets.onPlanetCardDropped = function(dropperColor, dropObj)
  if not Invasion.active then return end

  if not ActivePlayer.system or not ActivePlayer.system.planets or not next(ActivePlayer.system.planets) then return end
  local objName = dropObj.getName()
  local owner = "Grey"
  for i,eachPlanet in ipairs(ActivePlayer.system.planets) do
    if objName == eachPlanet.name then
      owner = _zoneHelper.zoneFromPosition(dropObj.getPosition()) or "Grey"
      ui.batchSet("p"..i.."_ColorRing", {color = owner})
      ui.batchSet("SmartBtn_InvasionContext_Def", {color = owner})
      return
    end
  end
end

Planets.updateShields = function()
  if not ActivePlayer.system or not TacData.unitMap or not TacData.unitMap[ActivePlayer.system.guid] then return end

  local function locationHasShield(location)
    local pOwner = Planets.getOwnerColor(location)
    if not pOwner or pOwner == "Grey" then return false end

    local pUnits =  MultiRoller.getAttributes(pOwner, ActivePlayer.color ~= pOwner and ActivePlayer.color or false, "BOMBARDMENT", location)
    for eachUnit,attrs in pairs(pUnits) do
      if attrs.planetaryShield and attrs.count and attrs.count > 0 then
        return true
      end
    end

    return false
  end

  Planets.shieldStatus = { system = ActivePlayer.system, disabled = false}
  --Does the active player have any "disablePlanetaryShield" units in system?
  local activeFleet = MultiRoller.getAttributes(ActivePlayer.color, nil, "BOMBARDMENT", "Space")
  local _localallyDisabled = {}
  for unitType,eachUnit in pairs(activeFleet or {}) do
    if eachUnit.disablePlanetaryShield and eachUnit.count and eachUnit.count > 0 then
      --added support for disablePlanetaryShield = "onThisPlanet". Disables per planet with this unit rather than entire system
      if type(eachUnit.disablePlanetaryShield) ~= "boolean" and eachUnit.disablePlanetaryShield == "onThisPlanet" then
        --search Tac data for locations(planets) that have 1 or more of this unit
        if TacData.unitMap and TacData.unitMap[TacData.activeSystem.system.guid] then
          local systemSummary = TacData.unitMap[TacData.activeSystem.system.guid].summary or {}
          for eachLocation,colorTables in pairs(systemSummary) do
            if eachLocation ~= "Space" then
              --does this planet have activePlayer units? A unit matching unitType? and check non-zero?
              if colorTables[TacData.activePlayer] and colorTables[TacData.activePlayer][unitType] and  colorTables[TacData.activePlayer][unitType] > 0 then
                _localallyDisabled[eachLocation] = true
              end
            end
          end
        end
      else
        Planets.shieldStatus.disabled = true
        break
      end
    end
  end

  for i,eachPlanet in ipairs(ActivePlayer.system.planets or {}) do
    --Does the planet owner have any units on this planet
    local result = locationHasShield(eachPlanet.name)
    local status = { name = eachPlanet.name, hasShield = result, disabledLocally = _localallyDisabled[eachPlanet.name] or false, override = Planets.shieldUI[i].override}
    --determine the state the ui SHOULD be in after overrides
    status.enabled = not result and 0 or status.override ~= 0 and status.override or (status.disabledLocally or Planets.shieldStatus.disalbed) and -1 or 1
    Planets.shieldStatus[i] = status
  end

  --maybe update ui
  Planets.updateShieldDisplay()
end

--set or remove the shield override for a planet
--toState = -1|0|1 : forceOff|removeOverride|forceOn
Planets.setShieldStatus = function(nameOrIndex, toState)
  if not ActivePlayer.system or not ActivePlayer.system.planets then return end
  local pIndex = nameOrIndex
  if type(nameOrIndex) == "string" then
    pIndex = 0
    for i,each in ipairs(ActivePlayer.system.planets or {}) do
      if each.name == nameOrIndex then pIndex = i break end
    end
  end
  if pIndex < 1 or pIndex > #ActivePlayer.system.planets or pIndex > 5 then return end

  local status = Planets.shieldStatus[pIndex]
  if not status or not status.hasShield then return end
  status.override = toState
  --set shield enabeld to override or natural state
  status.enabled = toState ~= 0 and toState or (status.disabledLocally or Planets.shieldStatus.disabled) and -1 or 1

  --maybe update display
  Planets.updateShieldDisplay(type(nameOrIndex) == "string" and nameOrIndex or Planets.getName(pIndex))
end

--onlyUpdatePlanet* optional or "planetName", updates all planets if nil
local _animatingShields = {} --{[1] = {targetState}}
Planets.updateShieldDisplay = function(skipAnimation, onlyUpdatePlanet)
  --only update if Invasion is open | Shield status has been gathered for the system | The planets are ready to display shields
  if Tac.State ~= Tac.eStates.Invasion() --ui not visible
    or not Planets.shieldStatus.system  --we dont have the unit data yet, abort
    or Planets._nextSystem --the planets are still animating, they will dispaly shields when finished
    or Planets.shieldStatus.system ~= Planets._displayedSystem  --Unit data is from previous system
  then return end
  skipAnimation = skipAnimation or Tac.disableAnimations

  local function updatePlanetShield(i)
    if not Planets.shieldStatus[i] then return end
    if _animatingShields[i] then return end --will self update after animation

    local uiState = Planets.shieldUI[i]
    local dataState = Planets.shieldStatus[i]

    local function onShieldActivated(cancelAnim)
      _animatingShields[i]= nil
      Planets.shieldUI[i].active = true
      ui.batchSet("p"..i.."_Btn_shieldOverride", {active = true, interactable = true, sprite = "Btn_PShield_NoOverride"})

      Planets.updateShieldDisplay(skipAnimation or cancelAnim == -1, Planets.getName(i))
    end

    --does the shield UI need to be deactivted?
    if dataState.enabled == 0 then
      if not uiState.active then return end

      if skipAnimation then ui.batchSet("p"..i.."_shieldShowSkip", {active = false}) end
      self.UI.hide("p"..i.."_ShieldDisabled")
      self.UI.hide("p"..i.."_ShieldEnabled")
      ui.batchSet("p"..i.."_Btn_shieldOverride", {active = false, interactable = false})
      uiState.active = false
      uiState.enabled = 0
      return
    end

    --does the shield UI need to be activted?
    if(data.enabled ~= 0 and not uiState.active) then
      _animatingShields[i] = Coru.wait(0.6, onShieldActivated)
      ui.batchSet("p"..i.."_shieldShowSkip", {active = true})
      --todo: Reset override btn
      self.UI.show("p"..i.."_ShieldEnabled")
      return
    end

    --set the next state for override button to not this state
    if dataState.override == 0 then
      ui.batchSet("p"..i.."_Btn_shieldOverride", {
        sprite = "Btn_PShield_NoOverride",
        highlightedSprite = dataState.enabled == 1 and "Btn_PShield_Disable_Dark" or "Btn_PShield_Enable_Dark",
        pressedSpreite = dataState.enabled == 1 and "Btn_PShield_Disable" or "Btn_PShield_Enable"
      })
    else
      local setActive = dataState.enabled == 1 and true or false
      ui.batchSet("p"..i.."_Btn_shieldOverride", {
        sprite = setActive and "Btn_PShield_Enable" or "Btn_PShield_Disable",
        highlightedSprite = setActive and "Btn_PShield_Enable_Hover" or "Btn_PShield_Disable_Hover",
        pressedSprite = setActive and "Btn_PShield_Enable_Dark" or "Btn_PShield_Disable_Dark",
      })
    end

    if uiState.enabled == dataState.enabled then return end
    if dataState.enabled == -1 then
      self.UI.show("p"..i.."_ShieldDisabled")
    else
      self.UI.hide("p"..i.."_ShieldDisabled")
    end

    uiState.enabled = dataState.enabled
  end

  if onlyUpdatePlanet then
    local i = assert(Planets.getIndex(onlyUpdatePlanet))
    updatePlanetShield(i)
  else
    for i,eachPlanet in ipairs(ActivePlayer.system.planets or {}) do
      updatePlanetShield(i)
    end
  end
end

Planets.clearShields = function()
  for i,each in ipairs(Planets.shieldUI) do
    each.active = false
    each.enabled = 0
    each.override = 0
    Planets.shieldStatus.disabled = false
    Planets.shieldStatus[i] = {
      name = false,
      override = 0,
      enabled = 0,
      hasShield = false,
      disabledLocally = false
    }
    --Hide UI and disable shield buttons
    ui.batchSet("p"..i.."_shieldShowSkip", {active = false})
    --todo: Reset override btn
    ui.batchSet("p"..i.."_Btn_shieldOverride", {active = false, interactable = false, sprite = "Btn_PShield_NoOverride", highlightedSprite = "Btn_PShield_Disable_Dark", pressedSpreite = "Btn_PShield_Disable"})
    self.UI.hide("p"..i.."_ShieldEnabled")
    self.UI.hide("p"..i.."_ShieldDisabled")
  end
end

Planets.shieldUI = { --state of the UI
  --[[[1] = {
    active = false,
    enabled = 0,
    override = 0
  }--]]
}
Planets.shieldStatus = {--[[ state of the data
  disabled = false, --active player has a disablePlanetaryShield in system
  [1] = {
    enabled = 0, --The state that the shield should be in after checking: override - disabled - disabledLocally : -1:disabled, 0: Not visible, 1:enabled
    name = false,
    hasShield = false, --are there units with PShield ability
    disabledLocally = false, --planet contains an active player's unit with disablePlanetaryShield = "onThisPlanet"
    override = 0, -- -1: force disabled, 0: no override, 1 force enabled
  }--]]
}

--Multiroller functionality-----------------------------------------------------

--[[
TacData = {
  activeColor = ""
  activeSystem = {hex = "hex", system = systemTable},
  adjacentSystems = {}
  adjacentSystems
  unitMap
  hexToUnits
  initialized
}--]]

--location = planetName or "Space"
--infers defender in active system locations
MultiRoller.getDefender = function(location)
  if not location then return end
  local result = "Grey"

  local function getSpaceDefender()
    if not TacData.unitMap or not ActivePlayer.system then return "Grey" end
    local systemData = TacData.unitMap[ActivePlayer.system.guid]
    local activeSpace = systemData and systemData.summary.Space or {}
    for eachCol,_ in pairs(activeSpace or {}) do
      if eachCol ~= ActivePlayer.color then return eachCol end
    end
    return "Grey"
  end

  --Planet owner is defender - even if they are also the active player
  local function getPlanetDefender()
    return Planets.getOwnerColor(location) or "Grey"
  end

  return location == "Space" and getSpaceDefender() or getPlanetDefender()
end

MultiRoller._rollerCache = {}--{[color] = mRoller}
MultiRoller.getRoller = function(pColor)
  if MultiRoller._rollerCache[pColor] ~= nil then return MultiRoller._rollerCache[pColor] end

  local multiRollers = {}
  local colorToPosition = {}
  for _, object in ipairs(getAllObjects()) do
      local name = object.getName()
      if string.match(name, '^TI4 MultiRoller') then
          table.insert(multiRollers, object)
      end
      local color = string.match(name, '^Command Sheet %((%a+)%)$')
      if color then
          colorToPosition[color] = object.getPosition()
      end
  end

  MultiRoller._rollerCache = {}
  for color, p0 in pairs(colorToPosition) do
      local best = false
      local bestDistanceSq = false
      for _, multiRoller in ipairs(multiRollers) do
          local p1 = multiRoller.getPosition()
          local dSq = ((p1.x - p0.x) ^ 2) + ((p1.z - p0.z) ^ 2)
          if (not bestDistanceSq) or (dSq < bestDistanceSq) then
              best = multiRoller
              bestDistanceSq = dSq
          end
      end
      MultiRoller._rollerCache[color] = best
  end

  return MultiRoller._rollerCache[pColor]
end

local ENGAGEMENT_TYPE = {
    SPACE_CANNON_OFFENSE = { name = 'Space Cannon Offense', rollType = 'spaceCannon' },
    ANTI_FIGHTER_BARRAGE = { name = 'Anti-Fighter Barrage', rollType = 'antiFighterBarrage' },
    SPACE_COMBAT = { name = 'Space Combat', rollType = 'spaceCombat' },
    BOMBARDMENT = { name = 'Bombardment', perPlanet = true, rollType = 'bombardment' },
    SPACE_CANNON_DEFENSE = { name = 'Space Cannon Defense', perPlanet = true, rollType = 'spaceCannon' },
    GROUND_COMBAT = { name = 'Ground Combat', perPlanet = true, rollType = 'groundCombat' }
}


--depricated
function getHexAndAdjacent(position, playerColor)
    assert(type(position) == 'table' and type(position.x) == 'number')
    assert(type(playerColor) == 'string')

    -- Get this hex, and adjacent hexes.
    local hex = _systemHelper.hexFromPosition(position)
    local adjacentHexes = _systemHelper.hexNeighborsWithHyperlanes(hex)

    -- Include through-wormhole.
    local adjacentWormholeHexes = _systemHelper.hexAdjacentWormholes({
        hex = hex,
        playerColor = playerColor
    })
    for _, wormholeHex in ipairs(adjacentWormholeHexes) do
        table.insert(adjacentHexes, wormholeHex)
    end

    -- Remove any duplicates.
    local uniq = {}
    local seen = {}
    for _, hex in ipairs(adjacentHexes) do
        if not seen[hex] then
            table.insert(uniq, hex)
            seen[hex] = true
        end
    end

    return hex, uniq
end
--depricated
function getHexToUnits(units)
    assert(type(units) == 'table')

    local hexToUnits = {}
    for _, unit in ipairs(units) do
        local entry = hexToUnits[unit.hex]
        if not entry then
            entry = {}
            hexToUnits[unit.hex] = entry
        end
        table.insert(entry, unit)
    end
    return hexToUnits
end
--[[function getOpponentColor(selfColor, unitsInHex)
    assert(type(selfColor) == 'string' and type(unitsInHex) == 'table')

    if selfColor == ActivePlayer.color then
      return getDefender()\

    -- If self is not the activating player, then activating player is enemy.
    -- (This could be a third player firing PDS2 from an adjacent hex).
    if selfColor ~= ActivePlayer.color then
        return ActivePlayer.color
    end

    -- If there are any ships this is a space combat.  Get ship color.
    local genericAttrs = _unitHelper.getUnitAttributes({})
    for _, unit in ipairs(unitsInHex) do
        if unit.color and unit.color ~= selfColor then
            if genericAttrs[unit.unitType].spaceCombat then
                return unit.color
            end
        end
    end

    -- Otherwise ground combat?  Get any unit color (assume already filtered to planet).
    for _, unit in ipairs(unitsInHex) do
        if unit.color and unit.color ~= selfColor then
            return unit.color
        end
    end
end--]]

MultiRoller.rewritePositionAndHexForInArenaUnits = function(hex, units)
    assert(type(hex) == 'string' and type(units) == 'table')

    local arenaName = 'TI4 Auto-fill MultiRoller Arena'

    -- Allow multiple arena objects to coexist.
    local bbToArenaObject = false
    for _, object in ipairs(getAllObjects()) do
        if object.getName() == arenaName then
            local bounds = object.getBounds()
            local bb = {
                min = {
                    x = bounds.center.x - bounds.size.x,
                    z = bounds.center.z - bounds.size.z,
                },
                max = {
                    x = bounds.center.x + bounds.size.x,
                    z = bounds.center.z + bounds.size.z,
                },
            }
            bbToArenaObject = bbToArenaObject or {}
            bbToArenaObject[bb] = object
        end
    end
    if not bbToArenaObject then
        return false
    end

    local activatedSystem = _systemHelper.getActivatedSystem()
    local activatedSystemObject = getObjectFromGUID(activatedSystem.guid)

    for _, unit in ipairs(units) do
        local p = unit.position
        for bb, arenaObject in pairs(bbToArenaObject) do
            if p.x >= bb.min.x and p.x <= bb.max.x and p.z >= bb.min.z and p.z <= bb.max.z then
                -- unit is in arena bounding box.  Get in-system position to
                -- make sure it is actually in the hex.
                p = activatedSystemObject.positionToWorld(arenaObject.positionToLocal(p))
                if hex == _systemHelper.hexFromPosition(p) then
                    -- Overwrite position data to act like in-hex rather than in-arena.
                    unit.hex = hex
                    unit.position = p  -- world position inside activated system
                end
            end
        end
    end

    return true
end

function getOpponentColor(selfColor, location)
  --print("Getting opponent for ", selfColor, " from ", location)
  return selfColor ~= ActivePlayer.color and ActivePlayer.color or MultiRoller.getDefender(location) or "Grey"
end

local _buildingTacData = false
MultiRoller.buildTacData = function(system, callback)
  if _buildingTacData then return end
  _buildingTacData = true

  system = system or ActivePlayer.system
  if not system then return end
  local systemObj = assert(getObjectFromGUID(system.guid))
  local activeHex = _systemHelper.hexFromPosition(systemObj.getPosition())

  TacData = {
    activePlayer = ActivePlayer.color or "Grey",
    activeSystem = {hex = activeHex, system = system},
  --added during coroutine:
    --adjacentSystems
    --unitMap
    --hexToUnits
    --initialized
  }

  local function _getAdjacentSystems()
    local adjacentSystems = {}
    local playableColors = _zoneHelper.zones()
    for _,eachColor in ipairs(playableColors) do
      --return: table of adjacent system guids with hex locations: {["guid1"] = {hex = "hexPosition", system = systemTableRef}, ["g2"] =...}
      adjacentSystems[eachColor] = _systemHelper.getAdjacentSystems({
          color = eachColor,
          system = system.guid,
          highlight = eachColor == ActivePlayer.color and Tac.highlightAdjSystems[ActivePlayer.color]
        })
      coroutine.yield(0)
    end
    TacData.adjacentSystems = adjacentSystems
  end

  local buildTacData = coroutine.create(function()
    coroutine.yield(0)
    coroutine.yield(0)

    _getAdjacentSystems()
    coroutine.yield(0)

    MultiRoller.buildUnitMap(system)
    coroutine.yield(0)

    _buildingTacData = false
    if callback then callback() end
    return 1
  end)

  Coru.run(buildTacData)
end

--[[unitMap_Layout = {
  [systemGUID] = {
    summary = {
      ["Space"] = {[color] = {[Mech] = #,...},},
      ["PlanetName"] = {[color] = {[Mech] = #}}
    },
    details = {
      [color] = {
        [Mech] = {
          total = #, --how many are in system
          count = { --count by location
            ["Space"] = #,
            ["PlanetName"] = #
          },
          units = {
            [guid] = {color = color, location = "Space|PlanetName", hex ="", position = {}}
          }
        }
      }
  }
  },
}--]]
local _hasBuiltUnitMapThisFrame = false
MultiRoller.buildUnitMap = function(system)
  if _hasBuiltUnitMapThisFrame then return end
  _hasBuiltUnitMapThisFrame = Wait.frames(function() _hasBuiltUnitMapThisFrame = false end, 1)

  local unitMap = {}
  local units = _unitHelper.getUnits()
  MultiRoller.rewritePositionAndHexForInArenaUnits(TacData.activeSystem.hex, units)
  local hexToUnits = getHexToUnits(units)
  for unitsHex, eachUnit in pairs(hexToUnits) do
      hexToUnits[unitsHex] = _unitHelper.fillUnitColors(eachUnit)  -- iteration allows overwrites of existing keys
  end

  --location represents a unit's position in game terms: either "Space" or a "Planet Name"
  local function getSystemLocations(system, asTable)
    local result = {["Space"] = asTable and {} or 0}
    for _,eachPlanet in ipairs(system.planets or {}) do
      result[eachPlanet.name] = asTable and {} or 0
    end
    return result
  end

  --transform data into unitMap format
  local _systemIsFormatted = {}
  --pramas: data = {hex, system}
  local function gatherUnits(systemGuid, data)
    --most systems will be referenced in each player's adjacentSystems table. We only need to get its units once.
    if not _systemIsFormatted[systemGuid] then
      _systemIsFormatted[systemGuid] = true

      unitMap[systemGuid] = {summary = getSystemLocations(data.system, true), details = {}}
      local details = unitMap[systemGuid].details
      for eachHex, units in pairs(hexToUnits[data.hex] or {}) do
        if units.color then
          details[units.color] = details[units.color] or {}
          details[units.color][units.unitType] = details[units.color][units.unitType] or {total = 0, count = getSystemLocations(data.system), units = {}}
          local unitDetails = details[units.color][units.unitType]
          unitDetails.units[units.guid] = {hex = units.hex, position = units.position, color = units.color}
          local location = _systemHelper.planetFromPosition({systemGuid = systemGuid,position = units.position, exact = true})
          location = location and location.name or "Space"
          unitDetails.units[units.guid].location = location
          unitDetails.total = details[units.color][units.unitType].total + 1
          unitDetails.count[location] = unitDetails.count[location] + (units.count or 1)
          --printTable(unitMap[systemGuid]
        end
      end
    end
  end

  gatherUnits(system.guid, {hex = TacData.activeSystem.hex, system = system})
  for eachColor, systems in pairs(TacData.adjacentSystems or {}) do
    for systemGuid, data in pairs(systems) do
      gatherUnits(systemGuid, data)
    end
  end
  --add summaries
  for systemGuid,eachSystem in pairs(unitMap) do
    for eachColor,details in pairs(eachSystem.details or {}) do
      for unitType, unitData in pairs(details) do
        for location, count in pairs(unitData.count) do
          if count > 0 then
            eachSystem.summary[location] = eachSystem.summary[location] or {}
            eachSystem.summary[location][eachColor] = eachSystem.summary[location][eachColor] or {}
            eachSystem.summary[location][eachColor][unitType] = count
          end
        end
      end
    end
  end

  TacData.unitMap = unitMap
  TacData.hexToUnits = hexToUnits
  TacData.units = units
  --announce unitMap
  --printTable(unitMap)
  Tac.onGameEvent(Tac.eGameEvents.UnitMapUpdated())
end

local eEngagementTypes = {
  ["groundCombat"] = { name = 'Ground Combat', perPlanet = true, rollType = 'groundCombat' },
  ["spaceCombat"] = { name = 'Space Combat', rollType = 'spaceCombat' },
  ["antifighterBarrage"] = { name = 'Anti-Fighter Barrage', rollType = 'antiFighterBarrage' },
  ["spaceCannonOff"] = { name = 'Space Cannon Offense', rollType = 'spaceCannon' },
  ["spaceCannonDef"] = { name = 'Space Cannon Defense', perPlanet = true, rollType = 'spaceCannon' },
  ["bombardment"] = { name = 'Bombardment', perPlanet = true, rollType = 'bombardment' }
}

local _colorToUnitOverrides_thisFrame = false
function _getColorToUnitOverrides()
  if _colorToUnitOverrides_thisFrame then return _colorToUnitOverrides_thisFrame end
  _colorToUnitOverrides_thisFrame = _unitHelper.getColorToUnitOverrides()
  Wait.frames(function() _colorToUnitOverrides_thisFrame = false end, 1)

  return _colorToUnitOverrides_thisFrame
end

local _colorToUnitModifiers_thisFrame = false
function _getColorToUnitModifiers()
  if _colorToUnitModifiers_thisFrame then return _colorToUnitModifiers_thisFrame end
  _colorToUnitModifiers_thisFrame = _unitHelper.getColorToUnitModifiers()
  Wait.frames(function() _colorToUnitModifiers_thisFrame = false end, 1)

  return _colorToUnitModifiers_thisFrame
end

MultiRoller.getAttributes = function(color, opponentColor, engagementType, location)
  --build unitAttributes
  local colorToUnitOverrides = _getColorToUnitOverrides()
  local colorToUnitModifiers = _getColorToUnitModifiers()

  -- Get per-hex unit attributes.  Per-hex because sometimes flagships modify
  -- peers, opponent non-fighter ships counts matter, etc.
  local useUnits = TacData.hexToUnits[TacData.activeSystem.hex] or {}
  --trim ground units
  if location and location ~= "Space" then
    local function inPlanetZone(unit)
        if unit.unitType == 'Flagship' then
            return true -- always include flagship for modifiers to kick in
        end
        local p = _systemHelper.planetFromPosition({
            systemGuid = ActivePlayer.system.guid,
            position = unit.position,
            exact = false
        })
        return p and p.name == location
    end
    local planetaryUnits = {}
    for _,data in ipairs(useUnits or {}) do
      if inPlanetZone(data) then
        table.insert(planetaryUnits, data)
      end
    end
    useUnits = planetaryUnits
  end

  local colorToUnits = _unitHelper.getColorToUnits(useUnits)
  local unitTypeToCount = _unitHelper.getUnitTypeToCount(colorToUnits[color] or {})
  local opponentUnitTypeToCount = _unitHelper.getUnitTypeToCount(colorToUnits[opponentColor] or {})

  local unitOverrides = colorToUnitOverrides[color] or {}
  local unitAttrs = _unitHelper.getUnitAttributes(unitOverrides)

  local _tacData = copyTable(TacData)
  _tacData.location = location
  _tacData.engagement = engagementType
  --_tacData.combatRound = #

  -- Apply flagships.
  unitAttrs = _unitHelper.applyFlagshipModifiers({
      unitAttrs = assert(unitAttrs),
      myColor = color,
      myUnitTypeToCount = unitTypeToCount,
      opponentColor = opponentColor,
      opponentUnitTypeToCount = opponentUnitTypeToCount,
      TacData = _tacData
  })

  -- Apply unit modifiers.
  unitAttrs = _unitHelper.applyUnitModifiers({
      unitAttrs = assert(unitAttrs),
      myColor = color,
      myUnitModifiers = colorToUnitModifiers[color] or {},
      myUnitTypeToCount = unitTypeToCount,
      opponentColor = opponentColor,
      opponentUnitModifiers = colorToUnitModifiers[opponentColor] or {},
      opponentUnitTypeToCount = opponentUnitTypeToCount,
      TacData = _tacData
  })

  for eachUnit,attributes in pairs(unitAttrs) do
    attributes.count = (attributes.count or 0) + (unitTypeToCount[eachUnit] or 0)
  end
  return unitAttrs
end

MultiRoller.resolveEngagement = function(color, engagementType, location, fillOnly)
  assert(eEngagementTypes[engagementType])
  local _multiRollerObj = MultiRoller.getRoller(color)
  assert(_multiRollerObj, "ROLL ABORTED: Could not find the " .. color .. " player's Multi-Roller")

  --update/rebuild unit tables
  MultiRoller.buildUnitMap(ActivePlayer.system)

  location = not eEngagementTypes[engagementType].perPlanet and "Space" or assert(location)
  local opponent = getOpponentColor(color, location)
  local rollType = eEngagementTypes[engagementType].rollType
  local unitAttributes = MultiRoller.getAttributes(color, opponent, engagementType, location)

  local function countRangedUnits(unitType, unitData)
    if not unitData[rollType].range or unitData[rollType].range < 1 then return 0 end
    if engagementType == "spaceCannonDef" then return 0 end --not emplemented
    local result = 0
    --giving ground units range allows them to roll combat for each planet IN their system
    if engagementType == "groundCombat" then
      activeSystemMap = TacData.unitMap[TacData.activeSystem.system.guid] or false
      if not activeSystemMap or not activeSystemMap.details[color] or not activeSystemMap.details[color][unitType] then return result end
      for eachLocation, localCount in pairs(activeSystemMap.details[color][unitType].count or {}) do
        if eachLoaction == "Space" then
          result = result + (unitData[rollType].requireGround and 0 or localCount)
        elseif eachLocation ~= location then --we're only counting units on other adjacent planets in the system
          result = result + localCount
        end
      end

      return result
    end
    --else, range allows units in adjacent systems to participate
    for eachSystem, mapData in pairs(TacData.unitMap) do
      if eachSystem ~= TacData.activeSystem.system.guid and mapData.details[color] and mapData.details[color][unitType] then
        if unitData[rollType].requireGround then
          result = result + (mapData.details[color][unitType].total - mapData.details[color][unitType].count.Space)
        elseif unitData[rollType].requireSpace then
          result = result + mapData.details[color][unitType].count.Space
        else
          result = result + mapData.details[color][unitType].total
        end
      end
    end

    return result
  end

  --build table of units that will participate in this roll
  local engagedUnitCount = {}
  for unitType,unitData in pairs(unitAttributes) do
    if unitData[rollType] then --only count units that can make this roll
      --count units in and adjacentHex
      unitData.count = (unitData.count or 0) + countRangedUnits(unitType, unitData)
      --apply unit limits (Experimental Battlestation)
      if unitData[rollType].unitLimit then
        unitData.count = unitData.count <= unitData[rollType].unitLimit and unitData.count or unitData[rollType].unitLimit
      end
      engagedUnitCount[unitType] = unitData.count
    end
  end

  --printTable(unitAttributes)
  --printTable(engagedUnitCount)
  local doClick = not fillOnly
  _multiRollerObj.call('inject', {
      clickerColor = color,
      vsColor = opponent,
      unitTypeToCount = engagedUnitCount,
      plasmaScoring = false,--plasmaScoring and true or false,
      rollType = doClick and rollType or false,
      --extraModifiers = extraUnitModifiers or false,
  })
  if fillOnly then
      pcall(printToColor('AutoFill: Units filled; left click to fill and roll.', params.clickerColor, "Yellow"))
  end
end

function autoFillCoroutine()
    local params = assert(table.remove(_autoFillQueue))
    assert(type(params.clickerColor) == 'string', 'clickerColor')
    assert(type(params.altClick) == 'boolean', 'altClick')
    assert(ENGAGEMENT_TYPE[params.autoFillType], 'autoFillType')
    assert(not params.planetIndex or type(params.planetIndex) == 'number', 'planetIndex')

    local autofillTypeAttributes = assert(ENGAGEMENT_TYPE[params.autoFillType])

    --updateColorToMultiRoller()
    coroutine.yield(0)

    local multiRoller = MultiRoller.getRoller(params.rollColor)
    if not multiRoller then
        printToAll(TAG .. ': no MultiRoller for ' .. params.clickerColor, {1,0,0})
        return 1
    end

    local system = _systemHelper.getActivatedSystem()
    local systemObject = system and getObjectFromGUID(system.guid)
    if not systemObject then
        printToAll(TAG .. ': no activated system', {1,0,0})
        return 1
    end

    local activatingColor = Turns.turn_color
    if not activatingColor then
        printToAll(TAG .. ': no activating player', {1,0,0})
        return 1
    end

    -- Get units in hex and adjacent (including wormholes) systems.
    local hex, adjacentHexes = getHexAndAdjacent(systemObject.getPosition(), params.clickerColor)
    coroutine.yield(0)
    local units = _unitHelper.getUnits()
    coroutine.yield(0)
    rewritePositionAndHexForInArenaUnits(hex, units)
    coroutine.yield(0)
    local hexToUnits = getHexToUnits(units)
    for unitsHex, units in pairs(hexToUnits) do
        hexToUnits[unitsHex] = _unitHelper.fillUnitColors(units)  -- iteration allows overwrites of existing keys
    end
    coroutine.yield(0)

    local colorToUnitOverrides = _unitHelper.getColorToUnitOverrides()
    coroutine.yield(0)
    local colorToUnitModifiers = _unitHelper.getColorToUnitModifiers()
    coroutine.yield(0)

    -- Get per-hex unit attributes.  Per-hex because sometimes flagships modify
    -- peers, opponent non-fighter ships counts matter, etc.
    local function getUnitAttrs(units, color, opponentColor)
        local colorToUnits = _unitHelper.getColorToUnits(units)
        local unitTypeToCount = _unitHelper.getUnitTypeToCount(colorToUnits[color] or {})
        local opponentUnitTypeToCount = _unitHelper.getUnitTypeToCount(colorToUnits[opponentColor] or {})

        local unitOverrides = colorToUnitOverrides[color] or {}
        local unitAttrs = _unitHelper.getUnitAttributes(unitOverrides)

        -- Apply flagships.
        unitAttrs = _unitHelper.applyFlagshipModifiers({
            unitAttrs = assert(unitAttrs),
            myColor = color,
            myUnitTypeToCount = unitTypeToCount,
            opponentColor = opponentColor,
            opponentUnitTypeToCount = opponentUnitTypeToCount
        })

        -- Apply unit modifiers.
        unitAttrs = _unitHelper.applyUnitModifiers({
            unitAttrs = assert(unitAttrs),
            myColor = color,
            myUnitModifiers = colorToUnitModifiers[color] or {},
            myUnitTypeToCount = unitTypeToCount,
            opponentColor = opponentColor,
            opponentUnitModifiers = colorToUnitModifiers[opponentColor] or {},
            opponentUnitTypeToCount = opponentUnitTypeToCount
        })

        return unitAttrs
    end

    -- If a planet is given, restrict to ground combat units.  Need to get
    -- attributes in order to apply fighters-on-ground, even through do not yet
    -- know opponent color (attributes may be slightly off, but good enough).
    local planet = false
    if params.planetIndex then
        if system and system.planets and #system.planets >= params.planetIndex then
            planet = system.planets[params.planetIndex].name

            local function inPlanetZone(unit)
                if unit.unitType == 'Flagship' then
                    return true -- always include flagship for modifiers to kick in
                end
                if unit.groundCombat and unit.groundCombat.anyPlanet then
                    return true
                end
                local p = _systemHelper.planetFromPosition({
                    systemGuid = system.guid,
                    position = unit.position,
                    exact = false
                })
                return p and (p.name == planet)
            end

            for unitsHex, units in pairs(hexToUnits) do
                local useUnits = {}
                if unitsHex == hex then
                    local units = hexToUnits[hex]
                    for _, unit in ipairs(units) do
                        if inPlanetZone(unit) then
                            table.insert(useUnits, unit)
                        end
                    end
                end
                hexToUnits[unitsHex] = useUnits
            end
        end
    end
    coroutine.yield(0)

    -- Deduce enemy color as the only non-self in the system.
    local selfColor = params.clickerColor
    local enemyColor = getOpponentColor(selfColor, activatingColor, hexToUnits[hex] or {})

    -- Split into self and enemy units.
    local adjacentHexSet = {}
    for _, adjacentHex in ipairs(adjacentHexes) do
        adjacentHexSet[adjacentHex] = true
    end
    local selfUnitsInHex = {}
    local enemyUnitsInHex = {}
    local selfUnitsAdjacent = {}
    for unitHex, units in pairs(hexToUnits) do
        for _, unit in ipairs(units) do
            if unitHex == hex then
                if unit.color == selfColor then
                    table.insert(selfUnitsInHex, unit)
                elseif unit.color == enemyColor then
                    table.insert(enemyUnitsInHex, unit)
                end
            elseif adjacentHexSet[unit.hex] and unit.color == selfColor then
                table.insert(selfUnitsAdjacent, unit)
            end
        end
    end
    local selfUnitTypeToCount = _unitHelper.getUnitTypeToCount(selfUnitsInHex)
    local enemyUnitTypeToCount = _unitHelper.getUnitTypeToCount(enemyUnitsInHex)
    local selfAdjUnitTypeToCount = _unitHelper.getUnitTypeToCount(selfUnitsAdjacent)
    coroutine.yield(0)

    -- Is bombardment allowed?
    local planetaryShield = false
    if enemyColor then
        local unitTypeToAttrs = assert(getUnitAttrs(hexToUnits[hex] or {}, enemyColor, selfColor))
        for unitType, attrs in pairs(unitTypeToAttrs) do
            if attrs.planetaryShield and (enemyUnitTypeToCount[unitType] or 0) > 0 then
                planetaryShield = true
                break
            end
        end
    end
    local unitTypeToAttrs = assert(getUnitAttrs(hexToUnits[hex] or {}, selfColor, enemyColor))
    for unitType, attrs in pairs(unitTypeToAttrs) do
        if attrs.disablePlanetaryShield and (selfUnitTypeToCount[unitType] or 0) > 0 then
            planetaryShield = false
            break
        end
    end
    coroutine.yield(0)

    -- Apply any require{Ground|Space} attributes.
    if autofillTypeAttributes == ENGAGEMENT_TYPE.SPACE_COMBAT then
        local warnUnitSet = {}
        local keep = {}
        for _, unit in ipairs(selfUnitsInHex) do
            local attrs = unitTypeToAttrs[unit.unitType] or {}
            if attrs.spaceCombat and attrs.spaceCombat.requireSpace then
                if not warnUnitSet[unit.unitType] then
                    warnUnitSet[unit.unitType] = true
                    local name = attrs.name or unitType
                    printToAll('Place ' .. name .. ' in space for space combat.', params.clickerColor)
                end
                local p = _systemHelper.planetFromPosition({
                    systemGuid = system.guid,
                    position = unit.position,
                    exact = true
                })
                if not p then
                    table.insert(keep, unit)  -- not on a planet
                end
            else
                table.insert(keep, unit)
            end
        end
        selfUnitsInHex = keep
        selfUnitTypeToCount = _unitHelper.getUnitTypeToCount(selfUnitsInHex)
    elseif autofillTypeAttributes == ENGAGEMENT_TYPE.GROUND_COMBAT then
        local warnUnitSet = {}
        local keep = {}
        for _, unit in ipairs(selfUnitsInHex) do
            local attrs = unitTypeToAttrs[unit.unitType] or {}
            if attrs.groundCombat and attrs.groundCombat.requireGround then
                if not warnUnitSet[unit.unitType] then
                    warnUnitSet[unit.unitType] = true
                    local name = attrs.name or unitType
                    printToAll('Place ' .. name .. ' on a planet for ground combat.', params.clickerColor)
                end
                local p = _systemHelper.planetFromPosition({
                    systemGuid = system.guid,
                    position = unit.position,
                    exact = true
                })
                if p then
                    table.insert(keep, unit)  -- on the planet
                end
            else
                table.insert(keep, unit)
            end
        end
        selfUnitsInHex = keep
        selfUnitTypeToCount = _unitHelper.getUnitTypeToCount(selfUnitsInHex)
    end

    -- Apply any per-unit limits (Experimental Battlestation).
    local function applyUnitLimit(unitLimit, inHex, adjHex)
        local avail = unitLimit
        inHex = math.min(inHex, avail)
        avail = avail - inHex
        adjHex = math.min(adjHex, avail)
        return inHex, adjHex
    end

    -- Now get just the units that matter for the combat type.
    local fillUnitTypeToCount = {}
    local adjacentUnitTypeToCount = {}
    if autofillTypeAttributes == ENGAGEMENT_TYPE.SPACE_CANNON_OFFENSE then

        for unitType, attrs in pairs(unitTypeToAttrs) do
            if attrs.spaceCannon then
                fillUnitTypeToCount[unitType] = selfUnitTypeToCount[unitType] or 0
                if attrs.spaceCannon.range and attrs.spaceCannon.range > 0 then
                    fillUnitTypeToCount[unitType] = fillUnitTypeToCount[unitType] + (selfAdjUnitTypeToCount[unitType] or 0)
                    adjacentUnitTypeToCount[unitType] = (adjacentUnitTypeToCount[unitType] or 0) + (selfAdjUnitTypeToCount[unitType] or 0)
                end
                if attrs.spaceCannon.unitLimit then
                    local a, b = applyUnitLimit(attrs.spaceCannon.unitLimit, fillUnitTypeToCount[unitType], adjacentUnitTypeToCount[unitType])
                    fillUnitTypeToCount[unitType] = a
                    adjacentUnitTypeToCount[unitType] = b
                end
            end
        end

    elseif autofillTypeAttributes == ENGAGEMENT_TYPE.ANTI_FIGHTER_BARRAGE then

        for unitType, attrs in pairs(unitTypeToAttrs) do
            if attrs.antiFighterBarrage then
                fillUnitTypeToCount[unitType] = selfUnitTypeToCount[unitType] or 0
            end
        end

    elseif autofillTypeAttributes == ENGAGEMENT_TYPE.SPACE_COMBAT then

        for unitType, attrs in pairs(unitTypeToAttrs) do
            if attrs.spaceCombat then
                fillUnitTypeToCount[unitType] = selfUnitTypeToCount[unitType] or 0
            end
        end

    elseif autofillTypeAttributes == ENGAGEMENT_TYPE.BOMBARDMENT then

        if not planetaryShield then
            for unitType, attrs in pairs(unitTypeToAttrs) do
                if attrs.bombardment then
                    fillUnitTypeToCount[unitType] = selfUnitTypeToCount[unitType] or 0
                end
            end

            if not _bombardmentPlasmaScoringOnPlanet then
                _bombardmentPlasmaScoringOnPlanet = planet
            end

        end

    elseif autofillTypeAttributes == ENGAGEMENT_TYPE.SPACE_CANNON_DEFENSE then

        for unitType, attrs in pairs(unitTypeToAttrs) do
            if attrs.spaceCannon then
                fillUnitTypeToCount[unitType] = selfUnitTypeToCount[unitType] or 0
                if unitType == 'Space Dock' then
                    fillUnitTypeToCount[unitType] = 0  -- Experimental Battlestation does not apply
                end
            end
        end

    elseif autofillTypeAttributes == ENGAGEMENT_TYPE.GROUND_COMBAT then

        for unitType, attrs in pairs(unitTypeToAttrs) do
            if attrs.groundCombat or unitType == 'Flagship' then
                fillUnitTypeToCount[unitType] = selfUnitTypeToCount[unitType] or 0
            end
        end

        -- Reset for L1Z1X Harrow (bombardment each ground combat round).
        _bombardmentPlasmaScoringOnPlanet = false

    else
        error(TAG .. ' unknown type "' .. typeAttributes.name .. "'")
    end

    if unitTypeToAttrs['Flagship'].spaceCombat.diceAsCount then
        fillUnitTypeToCount['Flagship'] = unitTypeToAttrs['Flagship'].spaceCombat.dice
    end

    -- Plasma scoring.  Using it, and for which unit?
    local plasmaScoring = false
    for _, modifier in ipairs(colorToUnitModifiers[selfColor] or {}) do
        if modifier == 'Plasma Scoring' then
            plasmaScoring = true
            break
        end
    end

    -- Disable plasma scoring when bombarding a second planet.
    local psAlreadyUsed = false
    if autofillTypeAttributes == ENGAGEMENT_TYPE.BOMBARDMENT and _bombardmentPlasmaScoringOnPlanet and _bombardmentPlasmaScoringOnPlanet ~= planet then
        psAlreadyUsed = plasmaScoring
        plasmaScoring = false
    end

    -- Compute best PS unit based on available candidates.  Assigns extra die
    -- to the best non-zero-count unit.
    local psUnitType = false
    if plasmaScoring then
        local fillUnits = {}
        for unitType, count in pairs(fillUnitTypeToCount) do
            if count > 0 then
                table.insert(fillUnits, { unitType = unitType, color = selfColor, count = 1 })
            end
        end
        local fillUnitTypeToAttrs = getUnitAttrs(fillUnits, selfColor, enemyColor)
        for unitType, attrs in pairs(fillUnitTypeToAttrs) do
            if autofillTypeAttributes == ENGAGEMENT_TYPE.SPACE_CANNON_OFFENSE then
                if attrs.spaceCannon and (attrs.spaceCannon.extraDice or 0) > 0 then
                    psUnitType = unitType
                    break
                end
            elseif autofillTypeAttributes == ENGAGEMENT_TYPE.BOMBARDMENT then
                if attrs.bombardment and (attrs.bombardment.extraDice or 0) > 0 then
                    psUnitType = unitType
                    break
                end
            elseif autofillTypeAttributes == ENGAGEMENT_TYPE.SPACE_CANNON_DEFENSE then
                if attrs.spaceCannon and (attrs.spaceCannon.extraDice or 0) > 0 then
                    psUnitType = unitType
                    break
                end
            end
        end
    end

    -- Nebula Defence?
    local extraUnitModifiers = false
    local function isNebula()
        for _, anomaly in ipairs(system.anomalies or {}) do
            if anomaly == 'nebula' then
                return true
            end
        end
    end
    if isNebula() and selfColor ~= activatingColor then
        extraUnitModifiers = extraUnitModifiers or {}
        table.insert(extraUnitModifiers, 'Nebula Defence')
    end

    local prefix = { 'AutoFill ' .. autofillTypeAttributes.name }
    if planet then
        table.insert(prefix, '(' .. planet .. ')')
    end
    table.insert(prefix, selfColor .. ' vs ' .. (enemyColor or '<unknown>'))
    local message = table.concat(prefix, ' ') .. ': '

    local messages = {}
    for unitType, count in pairs(fillUnitTypeToCount) do
        if count > 0 then
            local name = unitType
            if count > 1 and unitType ~= 'Infantry' and unitType ~= 'PDS' then
                name = name .. 's'
            end
            local message = count .. ' ' .. name
            if adjacentUnitTypeToCount[unitType] and adjacentUnitTypeToCount[unitType] > 0 then
                message = message .. ' (' .. adjacentUnitTypeToCount[unitType] .. ' adjacent)'
            end
            if psUnitType == unitType then
                message = message .. ' (Plasma Scoring)'
            end
            table.insert(messages, message)
        end
    end
    if #messages == 0 then
        if autofillTypeAttributes == ENGAGEMENT_TYPE.BOMBARDMENT and planetaryShield then
            table.insert(messages, 'no units (Planetary Shield)')
        else
            table.insert(messages, 'no units')
        end
    end

    if fillUnitTypeToCount['Flagship'] and fillUnitTypeToCount['Flagship'] > 0 then
        for _, modifier in ipairs(unitTypeToAttrs._flagshipModifiers) do
            if modifier.isCombat and modifier.type == 'mutate' then
                table.insert(messages, '(' .. modifier.name .. ': ' .. modifier.description .. ')')
            end
        end
    end
    for _, modifier in ipairs(unitTypeToAttrs._unitModifiers) do
        if modifier.isCombat and modifier.type == 'mutate' then
            table.insert(messages, '(' .. modifier.name .. ': ' .. modifier.description .. ')')
        end
    end

    if psAlreadyUsed then
        table.insert(messages, '(Plasma Scoring was used on “' .. _bombardmentPlasmaScoringOnPlanet .. '”)')
    end

    if #messages > 0 then
        message = message .. table.concat(messages, ', ') .. '.'
    end
    printToAll(message, params.clickerColor)

    local doClick = not params.altClick
    multiRoller.call('inject', {
        clickerColor = params.clickerColor,
        vsColor = enemyColor,
        unitTypeToCount = fillUnitTypeToCount,
        plasmaScoring = plasmaScoring and true or false,
        rollType = doClick and autofillTypeAttributes.rollType or false,
        extraModifiers = extraUnitModifiers or false,
        rollObjectGuid = _rollOnSelf and self.getGUID(),
    })
    if not doClick then
        printToAll('AutoFill: left click to fill and roll.', params.clickerColor)
    end

    return 1
end

--AutoFill params:
--[[
multiRoller.call('inject', {
    clickerColor = params.clickerColor,
    vsColor = enemyColor,
    unitTypeToCount = fillUnitTypeToCount,
    plasmaScoring = plasmaScoring and true or false,
    rollType = doClick and autofillTypeAttributes.rollType or false,
    extraModifiers = extraUnitModifiers or false,
    rollObjectGuid = _rollOnSelf and self.getGUID(),
})--]]

--UI button events--------------------------------------------------------------
function onButtonClicked_TacState(clickPlayer, btnIsOn, btnID)
  local switch = {
    ["Btn_MovementState"] = Tac.eStates.Movement(),
    ["Btn_SpaceCombatState"] = Tac.eStates.SpaceCombat(),
    ["Btn_InvasionState"] = Tac.eStates.Invasion(),
  }
  assert(switch[btnID])
  Tac.onGameEvent(Tac.eGameEvents.TacStepBtnClicked(), {activate = btnIsOn, tacStep = switch[btnID]})
end

function onButtonClicked_MulitRoller(clickPlayer, mouseBtn, btnID)
  local clickType = mouseBtn == "-1" and "roll" or mouseBtn == "-2" and "fill" or false
  if not clickType then return end

  local rollTarget = assert(ui.btnLookup[btnID].rollTarget)
  local function resolve(engagementType, location)
    engagementType = engagementType or rollTarget
    MultiRoller.resolveEngagement(clickPlayer.color, engagementType, location, clickType == "fill" and true or false)
  end

  local function resolveMovement()
    printToAll(">>Movement finalized>>", "Teal")
    MultiRoller.buildTacData(ActivePlayer.system)
  end

  local function resolveAtFocusPlanet(engagementType)
    if not Invasion.focus then
      engagementType = engagementType or rollTarget
      printToAll("Select a planet before rolling for ".. engagementType..".", "Yellow")
      return
    end
    resolve(engagementType, Invasion.focus)
  end

  local function resolveContext()
    if not Invasion.context then return end
    resolveAtFocusPlanet(Invasion.context)
  end

  local switch = {
    ["spaceCombat"] = resolve,
    ["antifighterBarrage"] = resolve,
    ["spaceCannonOff"] = resolve,
    ["spaceCannonDef"] = resolveAtFocusPlanet,
    ["bombardment"] = resolveAtFocusPlanet,
    ["groundCombat"] = resolveAtFocusPlanet,
    ["confirmMovement"] = resolveMovement,
    ["invasionContext"] = resolveContext,
    ["catch"] = function() print("Caught unregistered case >", rollTarget, "< from >",btnID,"< in onBtnClicked_MultiRoller") end
  }
  local try = switch[rollTarget] and rollTarget or "catch"
  switch[try]()
end

function onSmartButtonClicked(clickPlayer, mouseBtn, btnID)
  local clickType = mouseBtn == "-1" and "roll" or mouseBtn == "-2" and "fill" or false
  if not clickType then return end
  local rollTarget = assert(ui.btnLookup[btnID].rollTarget)
  local smartColor = ui.btnLookup[btnID].smart == "attacker" and {ActivePlayer.color} or {self.UI.getAttribute(btnID, "color")}
  local function colorHasPermission(color)
    if not Tac.rollForMe[color] and clickPlayer.color ~= smartColor then
      printToColor("The ".. color .. " has disabled Roll-For-Me.", clickPlayer.color, "Yellow")
      return false
    end

    return true
  end

  --Some smart buttons may roll for multiple defenders(spaceCannon). Schedule resolution for each of these colors
  if smartColor[1] == "Grey" then
    smartColor = {}
    local _factionCols = _factionHelper.allFactions()
    for eachCol,data in pairs(_factionCols) do
      if eachCol ~= ActivePlayer.color and colorHasPermission(eachCol) then
       table.insert(smartColor, eachCol)
      end
    end
  end

  local function resolve(smartCol, engagementType, location)
    engagementType = engagementType or rollTarget
    if not colorHasPermission(smartCol) then return end
    MultiRoller.resolveEngagement(smartCol, engagementType, location, clickType == "fill" and true or false)
  end

  local function resolveAtFocusPlanet(smartCol, engagementType)
    if not Invasion.focus then
      engagementType = engagementType or rollTarget
      printToAll("Select a planet before rolling for ".. engagementType..".", "Yellow")
      return
    end
    resolve(smartCol, engagementType, Invasion.focus)
  end

  local function resolveContext(smartCol)
    if not Invasion.context then return end
    resolveAtFocusPlanet(smartCol, Invasion.context)
  end

  local switch = {
    ["spaceCombat"] = resolve,
    ["antifighterBarrage"] = resolve,
    ["spaceCannonOff"] = resolve,
    ["spaceCannonDef"] = resolveAtFocusPlanet,
    ["bombardment"] = resolveAtFocusPlanet,
    ["groundCombat"] = resolveAtFocusPlanet,
    ["invasionContext"] = resolveContext,
    ["catch"] = function(sCol) print("Caught unregistered case >", rollTarget, "< from >", btnID, "< in onSmartButtonClicked") end
  }

  local try = switch[rollTarget] and rollTarget or "catch"
  for _,eachCol in ipairs(smartColor) do
    switch[try](eachCol)
  end
end

function onButtonClicked_InvasionStep(clickPlayer, btnIsOn, btnID)
  local idToState = {
    ["Btn_SpaceCannonDefMode"] = "SpaceCannonDef",
    ["Btn_BombardmentMode"] = "Bombardment",
  }

  --if disabling this state, revert to overview unless a planet is in focus; in which case set to ground combat
  Invasion.setState(btnIsOn and idToState[btnID] or Invasion.focus and Invasion.eStates.GroundCombat() or Invasion.eStates.Overview())
end
--planetIndex = i of the planet in its system's planet table
function onQuickRollBombardment(clickPlayer, planetIndex, btnID)
end
function onQuickRollSpaceCannonDef(clickPlayer, planetIndex, btnID)
end

function onPlanetButtonClicked(clickerPlayer, planetIndex, btnID)
  Invasion.setFocus(tonumber(planetIndex))
end

function onButtonClicked_PShieldOverride(clickerPlayer, mouseBtn, btnID)
  local clickType = mouseBtn == "-1" and "toggle" or mouseBtn == "-2" and "revert" or false
  local pIndex = tonumber(string.sub(btnID, 2, 2)) or false
  if not clickType or not pIndex or not Invasion.active then return end

  Planets.setShieldStatus(pIndex, clickType == "revert" and 0 or Planets.shieldStatus[pIndex].enabled ~= 1 and 1 or -1)
end

function onPlasmaTargetSelected(clickerPlayer, mouseBtn, btnID)
  if mouseBtn ~= "-1" or not Invasion.active then return end
  local pIndex = tonumber(string.sub(btnID, 2, 2)) or false

  Invasion.setPlasmaTarget(pIndex)
end

--TI4 Event receivers-----------------------------------------------------------

--from "Strategy Card Mat"
function onPlaceTradeGoodsAndSetTurns()
  Tac.onGameEvent(Tac.eGameEvents.StartActionPhase())
end

--Called from _systemHelper
function onSystemActivation(system)
  Tac.onGameEvent(Tac.eGameEvents.SystemActivated(), {color = ActivePlayer.color or Turns.enable and Turns.turn_color, system = system})
end

--global events-----------------------------------------------------------------

function onPlayerPing(player, position, object)

  local function activateSystem()
    local system = _systemHelper.systemFromPosition(position)
    if system then _systemHelper.activateSystem({system = system.guid, color = ActivePlayer.color}) end
  end

  --setSystemHighlighter({color = "Blue", enabled = true})
  --setSystemHighlighter({color = "White", toggle = true})
  --activateSystem()
  MultiRoller.buildUnitMap(ActivePlayer.system)
  Planets.updateShields()
  Wait.frames(function()
  end, 20)


  --MultiRoller.buildTacData()

  local function debugState()
    print("State|Prev|Transition")
    print(Tac.State, "|", Tac.previousState, "|", Tac.inStateTransition)
  end
  --debugState()
  --ui.setSmartButtonColors()
  --ui.animateHeaderColor(_zoneHelper.zoneFromPosition(position) or "Black")
end

function onPlayerChangeColor(player_color)
  --print("onColorChange >", player_color, "<")
  Wait.frames(function() Tac.updateActiveState(nil, {skipAnimation = player_color == Tac.color}) end, 40)
end

local _turnChangeWait = false
function onPlayerTurnStart(activeColor, previousColor)
  local color = activeColor ~= "" and activeColor or "Grey"
  if not Turns.enable then color = "Grey" end
  --print("Turn start event >", color, "<")

  local function resolveChange()
    _turnChangeWait = false
    Tac.onGameEvent(Tac.eGameEvents.PlayerTurnStart(), {color = activeColor, prev = previousColor})
  end

  local waitTime = _turnChangeWait and 65 or 125
  if _turnChangeWait then
    Wait.stop(_turnChangeWait)
  end

  _turnChangeWait = Wait.frames(resolveChange, waitTime)
end

function onObjectRotate(object, spin, flip, player_color, old_spin, old_flip)
  --Track strategy card and active/pass token flips for turn display
  if Tac.State == Tac.eStates.Turns() and not Tac.inStateTransition and flip ~= old_flip then
    local objName = object.getName()
    --Activate/deactive strategy card icons
    if data.stratCards[objName] then
      ui.batchSet("Icon_StratCard_" .. objName,
                  {["color"] = flip <= 5 and data.stratCards[objName].color or "Grey"})

    --Remove player name from active player turn list
    elseif data.activePassedTokens[object] then
      if Tac.State ~= Tac.eStates.Turns() then return end

      Wait.frames(function()
        if flip >= 5 then
          Tac.onGameEvent(Tac.eGameEvents.PlayerPassed())
        elseif Tac.State == Tac.eStates.Turns() then--Reactivate color
          ui.setTurnUI(true)
        end
      end, 24)
    end
  end
end

function onObjectDrop(playerColor, object)
  devMode_systemActivator(playerColor, object)
  _cmdToken.onObjectDrop(playerColor, object)
  ui.onStratDrop(object)
  Planets.onPlanetCardDropped(playerColor, object)
end

function onObjectPickUp(playerColor, object)
  _cmdToken.onObjectPickup(playerColor, object)
end

function onPlayerAction(player, action, targets)
  local function resolveDelete()
    --prevent the _cmdToken from being deleted
    if action == Player.Action.Delete then
      for _,each in ipairs(targets or {}) do
        if each == _cmdToken.obj then return false end
      end
    end
    return true
  end

  local function resolveFlip()
    for _,each in ipairs(targets) do
      if each == _cmdToken.obj then return false
      elseif _cmdToken.dropTokens[each.getGUID()] then
        _cmdToken.onDropTokenFlipped(each.getGUID())
        return true-- false
      end
    end
    return true
  end

  local switch = {
    [Player.Action.FlipOver] = resolveFlip,
    [Player.Action.Delete] = resolveDelete,
    ["catch"] = function() return true end
  }
  local try = switch[action] and action or "catch"
  return switch[try]()
end

--object self events------------------------------------------------------------
function onLoad(save_state)
  self.setLock(true)--temp

  if save_state then
    local state = JSON.decode(save_state)
    _cmdToken.guid = type(state) == "table" and state.cmdGUID or nil
  end

  data.initStratCards()
  self.UI.setCustomAssets(ui.assets)
  local function delayedLoad()
    local function load()
      _cmdToken.canAnimate = true
      Tac.setState(Tac.eStates.Main())
      self.addContextMenuItem("Set Active Player", context_setActivePlayer)
      self.addContextMenuItem("Set State", context_setState)
      self.addContextMenuItem("Toggle Animations", context_toggleAnimations)
      self.addContextMenuItem('Toggle "Roll For Me"', context_toggleRollForMe)
      ui.hideOnInit()
    end

    local function uploadUI()
      self.UI.setXmlTable(ui.xmlTable, ui.assets)
      Wait.condition(load, function() return self.UI.loading == false end, 15, load)
    end
    ui.generateXML(uploadUI)
  end
  Wait.condition(delayedLoad, function() return self.UI.loading == false end, 15, delayedLoad)
  --self.UI.setXmlTable(ui.xmlTable, ui.assets)

  _cmdToken.setDisplayToken()
  _cmdToken.orient()
end

function onSave()
  if _cmdToken.guid then
    return JSON.encode({cmdGUID = _cmdToken.guid})
  end
end

function onDrop(player_color)
  local function release()
    _cmdToken.canAnimate = true
    _cmdToken.setTracking()
  end

  Wait.condition(release, function() return self.resting end , 2.5, release)
end

function onPickUp(player_color)
  _cmdToken.canAnimate = false
  _cmdToken.setTracking(true)
end

function onRotate(spin, flip, player_color, old_spin, old_flip)
  if _cmdToken.tracking then return end
  --print("Called rotate")
  local function release()
    _cmdToken.canAnimate = true
    _cmdToken.setTracking()
  end

  _cmdToken.setTracking(true)
  Wait.condition(release, function() return self.resting end , 2.5, release)
end

function onDestroy()
  --Destroy the Tactician's command token
  if _cmdToken.obj ~= nil then
    ignoreDeletedItem(_cmdToken.guid)
    _cmdToken.obj.destruct()
  end
  --destroy any "drop tokens"
  for each,data in pairs(_cmdToken.dropTokens or {}) do
    getObjectFromGUID(each).destruct()
  end
end

--Context Menu items------------------------------------------------------------
--remeber to clear selection after exiting the context menue: Player[clickerColor].clearSelectedObjects()

function context_setActivePlayer(clickerColor, objPos, obj)
  local function onConfirm(selected, selected_index, player_color)
    selected = selected == "None" and "Grey" or selected
    Tac.onGameEvent(Tac.eGameEvents.NewActivePlayer(), {color = selected})
  end

  local options = _zoneHelper.zones()
  table.insert(options, "None")
  Player[clickerColor].showOptionsDialog("Select a player color", options, "Grey", onConfirm)
  Player[clickerColor].clearSelectedObjects()
end

function context_setState(clickerColor, objPos, obj)
  local options = {}
  for name,each in pairs(Tac.eStates) do
    if each() ~= "Initializing" then
      table.insert(options, name)
    end
  end
  local function onConfirm(selected, selected_index, player_color)
     Tac.setState(selected, {skipAnimation = true})
  end

  Player[clickerColor].showOptionsDialog("Select State", options, "Main", onConfirm)
  Player[clickerColor].clearSelectedObjects()
end

function context_toggleAnimations(clickerColor, objPos, obj)
  Tac.disableAnimations = not Tac.disableAnimations
  local txt = Tac.disableAnimations and "disabled" or "enabled"
  local col = Tac.disableAnimations and "Red" or "Blue"
  printToAll("Tactician animations " .. txt, col)
  Player[clickerColor].clearSelectedObjects()
end

function context_toggleRollForMe(clickerColor, objPos, obj)
  Tac.rollForMe[clickerColor] = not Tac.rollForMe[clickerColor]
  local abled = Tac.rollForMe[clickerColor] and "enabled" or "disabled"
  printToAll("The "..clickerColor.." player has "..abled.." the ability for other players to roll for them on the TI4 Tactician.", clickerColor)
  Player[clickerColor].clearSelectedObjects()
end

--Misc functions----------------------------------------------------------------

--activate system without turns
function devMode_systemActivator(playerColor, object)
  local tokenName = string.match(object.getName(), '^(.*) Command Token')
  if not tokenName then return end

  local faction = _factionHelper.fromTokenName(tokenName)
  if not faction then return end

  --_system helper will catch the expected case
  if Turns.enable and (Turns.turn_color == playerColor and faction.color == playerColor) then return end

  local system = _systemHelper.systemFromPosition(object.getPosition())
  if not system then
      return
  end

  print("WARNING: devMode_systemActivator has not been disabled")

  Tac.setColor({color =faction.color, skipAnimation = true})
  _systemHelper.activateSystem({color = faction.color, system = system.guid})
end

--Floating command token--------------------------------------------------------
_cmdToken.setDisplayToken = function(_toColor, skipAnimation, tokenLoadedCallback)
 assert(_toColor == nil or type(_toColor) == "string")
 local toColor = _toColor or "Black"

 local function getFactionToken(faction)
   if not faction or type(faction) ~= "table" then return false end

   local factionTokens = {}
   factionTokens[faction.tokenName .. " Command Token"] = true
   local tokenInstance = false
   for _,eachObj in ipairs(getAllObjects()) do
     if factionTokens[eachObj.getName()] then
       return eachObj
     end
   end

   return false
 end

 local function getOrSpawnToken(tCol)
   if _cmdToken.obj ~= nil then return _cmdToken.obj end

   local fromGUID = _cmdToken.guid and getObjectFromGUID(_cmdToken.guid) or false
   if fromGUID then _cmdToken.obj = fromGUID return fromGUID end

   --Search the table for an unpacked faction's command token --Copy that token, and alter it
   local copyData = false
   local factions = _factionHelper.allFactions()
   local factionTokens = {}
   for _,eachFaction in pairs(factions) do
     factionTokens[eachFaction.tokenName .. " Command Token"] = true
   end

   for _, eachObj in ipairs(getAllObjects()) do
     if factionTokens[eachObj.getName()] then
        copyData = eachObj.getData()
       break
     end
   end
   if not copyData then return end --No command tokens on the table

   for k,v in pairs(_cmdToken.data) do
     copyData[k] = v
   end
   copyData.CustomMesh.DiffuseURL = _cmdToken.diffuse
   local atPos = self.positionToLocal(self.getPosition())
   local withRotate = self.getRotation()
   atPos.y = atPos.y + _cmdToken.posOffset.y
   atPos.x = atPos.x + _cmdToken.posOffset.x
   atPos.z = atPos.z + _cmdToken.posOffset.z
   atPos = self.positionToWorld(atPos)
   _cmdToken.obj = spawnObjectData({data = copyData, position = atPos, rotation = withRotate})
   _cmdToken.guid = _cmdToken.obj.getGUID()
   Wait.frames(function()
     _cmdToken.obj.use_gravity = false
     local audio = _cmdToken.obj.getComponent("AudioSource")
     audio.set("mute", true)
   end, 1)

   return _cmdToken.obj
 end

 local tokenObj = getOrSpawnToken(toColor)
 if not tokenObj then return end

 --maybe set the diffuse to look like active faction
 local factionToken = getFactionToken(_factionHelper.fromColor(toColor))
 local targetDiffuse = factionToken and factionToken.getCustomObject().diffuse or _cmdToken.diffuse
 if not toColor then toColor = "Black" end
 _cmdToken.activeColor = toColor

 local activeDiff = _cmdToken.obj.getCustomObject().diffuse
 if activeDiff == targetDiffuse then if tokenLoadedCallback then tokenLoadedCallback() end return end

 if skipAnimation then
   Coru.run(_cmdToken.updateTokenCoroutine(targetDiffuse, toColor), {callback = tokenLoadedCallback})
 else
   _cmdToken.animateColorChange(toColor, targetDiffuse, tokenLoadedCallback)
 end
end

_cmdToken.updateTokenCoroutine = function(diffuse, color)
  local co = coroutine.create(function()
    if _cmdToken.obj == nil then return end
    _cmdToken.obj.setColorTint(color)
    _cmdToken.obj.setCustomObject({diffuse = diffuse})
    _cmdToken.obj.interactable = false
    ignoreDeletedItem(_cmdToken.guid)
    coroutine.yield(0)
    _cmdToken.obj = _cmdToken.obj.reload()

    while(_cmdToken.obj.loading_custom or _cmdToken.obj.spawning) do coroutine.yield(0) end
    _cmdToken.guid = _cmdToken.obj.getGUID()
    _cmdToken.obj.use_gravity = false
    _cmdToken.obj.interactable = true
    local audio = _cmdToken.obj.getComponent("AudioSource")
    audio.set("mute", true)
  end)

  return co
end

_cmdToken.orient = function()
  if _cmdToken.obj == nil then return end

  local pos = self.positionToLocal(self.getPosition())
  local vec = self.getTransformForward()
  pos.x = pos.x + _cmdToken.posOffset.x
  pos.z = pos.z + _cmdToken.posOffset.z
  pos = self.positionToWorld(pos)
  pos.y = pos.y + _cmdToken.posOffset.y

  _cmdToken.obj.use_gravity = false
  _cmdToken.obj.setPosition(pos)
  _cmdToken.obj.setRotation(self.getRotation())

  local tacScale = self.getScale()
  _cmdToken.obj.setScale({x = _cmdToken.scaleRatio * tacScale.x, y = 1, z = _cmdToken.scaleRatio * tacScale.z})
  _cmdToken.obj.interactable = true
end

_cmdToken.setTracking = function(toState)
  --Comparing (false or coroutine) to (boolean or nil)
  if (_cmdToken.tracking and toState) or (not _cmdToken.tracking and not toState) then return end

  local co = coroutine.create(function()
    while _cmdToken.tracking do
      _cmdToken.orient()
      _cmdToken.obj.interactable = false
      coroutine.yield(0)
    end
  end)
  if toState then
    _cmdToken.tracking = co
    _cmdToken.stopAnimation()
    Coru.run(co)
  else
    Coru.stop(_cmdToken.tracking)
    _cmdToken.tracking = false
    _cmdToken.orient()
  end
end

_cmdToken.onObjectPickup = function(playerColor, object)
  --is this the tac's command token?
  if _cmdToken.obj == nil or object ~= _cmdToken.obj then return end
  --is the token available for pickUp?
  if not _cmdToken.canAnimate or _cmdToken.tracking then return end

  local function onTokenSpawned(obj)
    _cmdToken.canAnimate = true
    _cmdToken.obj = obj
    _cmdToken.guid = obj.getGUID()
    _cmdToken.orient()
  end

  local spawnParams = {
    data = _cmdToken.obj.getData(),
    position = _cmdToken.obj.getPosition(),
    rotation = _cmdToken.obj.getRotation(),
    scale = _cmdToken.obj.getScale(),
    callback_function = onTokenSpawned
  }

  _cmdToken.canAnimate = false
  _cmdToken.dropTokens[_cmdToken.guid] = {obj = _cmdToken.obj, tokenColor = ActivePlayer.color, holder = playerColor, activateColor = ActivePlayer.color, dropping = false}
  _cmdToken.obj.use_grid = true
  _cmdToken.obj.use_gravity = true
  ignoreDeletedItem(_cmdToken.guid)
  local newToken = spawnObjectData(spawnParams)
end

_cmdToken.onObjectDrop = function(playerColor, object)
  local dropToken = _cmdToken.dropTokens[object.getGUID()] or false
  if not dropToken then return end

  local function onDropLanded()
    if dropToken.obj == nil then dropToken = nil return end
    local system = _systemHelper.systemFromPosition(object.getPosition())
    if dropToken.activateColor ~= ActivePlayer.color then Tac.setColor({color = dropToken.activateColor}) end
    if system then _systemHelper.activateSystem({system = system.guid, color = dropToken.activateColor}) end
    coroutine.yield(0)
    dropToken.obj.destruct()
    dropToken = nil
  end

  if not dropToken.dropping then
    dropToken.dropping = true
    --dropToken.dropping = Wait.condition(onDropLanded, function() return dropToken.obj == nil or dropToken.obj.resting end, 1.6, onDropLanded)
    local dropCoru = coroutine.create(function()
      while dropToken.obj ~= nil and not dropToken.obj.resting do
        coroutine.yield(0)
        coroutine.yield(0)
        coroutine.yield(0)
      end

      onDropLanded()
      return 1
    end)

    Coru.run(dropCoru)
  end
  dropToken.obj.interactable = false
end

--When the "drop token" is flipped, it toggle between the color of the active player and the color of the player holding it
--once dropped, it activates the system for the current color
_cmdToken.onDropTokenFlipped = function(tokenGUID)
  local dropToken = _cmdToken.dropTokens[tokenGUID]
  if not dropToken or not _factionHelper.fromColor(dropToken.holder) then return end

  dropToken.activateColor = dropToken.activateColor == dropToken.holder and dropToken.tokenColor or dropToken.holder
  dropToken.obj.setColorTint(dropToken.activateColor)
end

_cmdToken.stopAnimation = function()
  if not _cmdToken.animator or _cmdToken.animator.status ~= "running" then return end

  _cmdToken.animator.stop()
  _cmdToken.orient()
end

_cmdToken.animateColorChange = function(toColor, factionToken, callback)
  if not _cmdToken.canAnimate or _cmdToken.tracking then return end
  --Stop any existing animation
  if _cmdToken.animator and _cmdToken.animator.status == "running" then
    _cmdToken.stopAnimation()
  end

  local lockState = self.getLock()
  self.setLock(true)
  _cmdToken.obj.interactable = false

  local function onComplete()
    self.setLock(lockState)
    _cmdToken.orient()
    if callback then callback() end
  end

  local anim = Animate.newController()
  anim.onComplete = onComplete
  local token = _cmdToken.guid

  anim.addClip("bump_1",
    {co = AnimClip.bump(token, {distance = 0.6, axis = "y", duration = 1.8, lerp = Tween.easeOut}),
    root = true, next = {next = {"bump_1_drop"}}})
  anim.addClip("bump_1_drop", {co = AnimClip.bump(token, {distance = -0.2, axis = "y", duration = 0.2, lerp = Tween.easeOut})})

  anim.addClip("rotateWait", {co = AnimClip.wait(0.1), root = true, next = {next = {"rotationStart"}}})
  anim.addClip("rotationStart", {co = AnimClip.rotate(token, {degrees = (360 *4), axis = "y", duration = 2, lerp = Tween.smooth}),
    next = {next = {"updateToken"}}})
  anim.addClip("Unwind", {co = AnimClip.rotate(token, {degrees = -360 , axis = "y", duration = 0.75, lerp = Tween.easeOut}), endClip = true})
  anim.addClip("bump_2", {co = AnimClip.bump(token, {distance = 0.4, axis = "y", duration = 0.3, lerp = Tween.linear}), next = {next = {"drop"}}})
  anim.addClip("drop", {co = AnimClip.bump(token, {distance = -0.8, axis = "y", duration = 0.4, lerp = Tween.easeOut})})

  if factionToken then anim.addClip("updateToken", {co = _cmdToken.updateTokenCoroutine(factionToken, toColor),
      next = {next = {"flip", "bump_2"}}})
    anim.addClip("flip", {co = AnimClip.rotate(token, {degrees = 360, axis = "z", duration = 0.5, lerp = Tween.easeOut}),
      next = { percent = {["Unwind"] = 0.55}}--{next = {"Unwind", "bump_2"}}
      })
  else
    anim.addClip("updateToken", {co = coroutine.create(function() _cmdToken.obj.setColorTint(toColor) end), next = {next = {"Unwind", "bump_2"}}})
  end

  _cmdToken.animator = anim
  anim.play()
end

_cmdToken.animateActivation = function(callback)
  if not _cmdToken.canAnimate or _cmdToken.tracking then return end
  --Stop any existing animation
  if _cmdToken.animator and _cmdToken.animator.status == "running" then
    _cmdToken.stopAnimation()
  end

  local lockState = self.getLock()
  self.setLock(true)
  _cmdToken.obj.interactable = false

  local function onComplete()
    self.setLock(lockState)
    _cmdToken.orient()
    if callback then callback() end
  end

  local anim = Animate.newController()
  anim.onComplete = onComplete
  local token = _cmdToken.guid

  --Build animation
  local _delta = 0.6
  local _dist = 0.6
  local t1 = 0.5
  local t2 = 0.2
  anim.addClip("Lift", {co = AnimClip.bump(token, {distance = _dist, axis = "y", duration = t1, lerp = Tween.easeOut}),
    root = true, next = {next = {"Dip"}}})
  anim.addClip("Dip", {co = AnimClip.bump(token, {distance = -_dist, axis = "y", duration = t2, lerp = Tween.easeOut}) })
  anim.addClip("Upscale", {co = AnimClip.scale(token, {duration = t1, delta = _delta, lerp = Tween.easeOut}), root = true, next = {next = {"Downscale"}}})
  anim.addClip("Downscale", {co = AnimClip.scale(token, {duration = t2, delta = -_delta, lerp = Tween.easeOut}), endClip = true})

  _cmdToken.animator = anim
  local function play()
    anim.play()
  end

  _cmdToken.setDisplayToken(ActivePlayer.color, true, play)
end

--Object animation clips--------------------------------------------------------

--degrees, axis, duration(time), lerp
AnimClip.rotate = function(objGUID, params)
  local co = coroutine.create(function()
    local obj = getObjectFromGUID(objGUID)
    local t_start = Time.time
    local initialRotation = obj.getRotation()[params.axis]

    while Time.time - t_start <= params.duration do
      if obj == nil then return -1 end
      local percent = (Time.time - t_start)/params.duration

      local rotation = obj.getRotation()
      rotation[params.axis] = Tween.lerp(initialRotation, initialRotation + params.degrees, params.lerp(percent))

      obj.setRotation(rotation)
      coroutine.yield(percent)
    end
  end)

  return co
end

--duration(time), lerp, delta = { x = ^, y = ^, z = ^}(each defaults to 0 -> no change in scale)
AnimClip.scale = function(objGUID, params)
  local co = coroutine.create(function()
    local t_start = Time.time
    local obj = getObjectFromGUID(objGUID)
    local baseScale = obj.getScale()
    if type(params.delta) == "number" then params.delta = {x = params.delta, y = params.delta, z = params.delta} end
    local target = {
      x = (params.delta.x or 0) + baseScale.x,
      y = (params.delta.y or 0) + baseScale.y,
      z = (params.delta.z or 0) + baseScale.z}

    while(Time.time - t_start <= params.duration) do
      if obj == nil then return -1 end
      local percent = (Time.time - t_start)/params.duration

      local pMod = params.lerp(percent)
      obj.setScale({
        x = Tween.lerp(baseScale.x, target.x, pMod),
        y = Tween.lerp(baseScale.y, target.y, pMod),
        z = Tween.lerp(baseScale.z, target.z, pMod)
        })
      coroutine.yield(percent)
    end
    return 1
  end)

  return co
end

--distance, axis, duration, lerp
AnimClip.bump = function(objGUID, params)
  local axis = params.axis or "y"
  local co = coroutine.create(function()
    local obj = getObjectFromGUID(objGUID)
    local t_start = Time.time
    local initPos = obj.getPosition()

    while Time.time - t_start <= params.duration do
      if obj == nil then return -1 end
      local percent = (Time.time - t_start)/params.duration

      local pos = obj.getPosition()
      pos[axis] = Tween.lerp(initPos[axis], initPos[axis] + params.distance, params.lerp(percent))
      obj.setPosition(pos)
      coroutine.yield(percent)
    end
    return 1
  end)

  return co
end

AnimClip.wait = function(delay)
  local co = coroutine.create(function()
    local ti = Time.time
    while Time.time - ti <= delay do
      coroutine.yield((Time.time - ti)/delay)
    end
  end)

  return co
end

Animate.newController = function()
  local animation = {
    name = "",
    status = "waiting", --running, waiting, terminated, complete
    runningCos = {},
    _nextWait = 0.0001,

    clips = {}, -- {[c_id] = clipData}
    --clipData = {co = clipCoroutine, tDelay, pDelay, onComplete, onYield}
    root = {},
    endClip = {},
    sequence = {},
    percentSequence = {},--[c_id] = { [%] = {c_id,...list}}
    waitingPercents = {},

    listeners = {},
  }

  animation.play = function()
    animation.status = "running"
    animation.waitingPercents = animation.percentSequence
    for _,eachID in ipairs(animation.root) do
      animation.startClip(eachID)
    end
  end

  animation.stop = function()
    animation.status = "terminated"
    for _,eachCo in pairs(animation.runningCos) do
      Coru.stop(animation.clips[eachCo].co)
    end
  end

  animation._onComplete = function()
    animation.status = "complete"
    animation.onComplete()

    --print("Animation complete")
    for _,each in ipairs(animation.listeners or {}) do
      each.obj.call(each.callback, {animation.name})
    end
  end

  animation.onComplete = function() end--override me

  animation.addListener = function(callback, callObj)
    table.insert(animation.listeners, {callback = callback, obj = callObj ~= nil and callObj or self})
  end

  animation.onClipComplete = function(c_id, result)
    animation.runningCos[c_id] = nil
    if animation.status == "terminated" then return end
    --Maybe start next

    if animation.sequence[c_id] then
      for _,eachID in pairs(animation.sequence[c_id]) do
        animation.startClip(eachID)
      end
    end

    --If last Then
    if c_id == animation.endClip then
      animation._onComplete()
    end
  end

  animation.onClipYield = function(c_id, result)
    --run yields
    if animation.clips[c_id].onYield then animation.clips[c_id].onYield(result) end

    --start pDelayed clips
    if animation.waitingPercents[c_id] then --and animation.percentSequence[c_id][]
      local pctRemove = {}
      for pct,list in pairs(animation.waitingPercents[c_id]) do
        if result >= pct then
          table.insert(pctRemove, pct)
          for _,eachID in ipairs(list) do
            animation.startClip(eachID)
          end
        end
      end

      for _,each in ipairs(pctRemove) do
        animation.waitingPercents[c_id][each] = nil
      end
      if not next(animation.waitingPercents[c_id]) then animation.waitingPercents[c_id] = nil end
    end
  end

  animation.startClip = function(c_id)
    if animation.status == "terminated" then return end
    local function _clipComplete(result)
      animation.onClipComplete(c_id, result)
    end

    local function _clipYield(result)
      animation.onClipYield(c_id, result)
    end
    local trackYield = animation.clips[c_id].onYield or animation.clips[c_id].next and animation.clips[c_id].next.percent
    --print("Starting ", c_id)
    table.insert(animation.runningCos, c_id)
    Coru.run(animation.clips[c_id].co, {callback = _clipComplete, yieldback = trackYield and _clipYield or nil})
  end

  --clipData = {co = clipCoroutine, onComplete = func, onYield = func, next, root = bool, endClip = bool}
  animation.addClip = function(c_id, clipData)
    clipData.c_id = c_id
    animation.clips[c_id] = clipData

    if clipData.root then table.insert(animation.root, c_id) end
    if clipData.endClip then animation.endClip = c_id end
    if clipData.next then animation.createSequence(c_id, clipData.next) end
  end

  --lists of clip ids that will be played after the given c_id
  --sequenceData = { next = {list of c_ids}, time = {[c_id] = delay}, percent = {[c_id] = %}} p: percentDelay| t: timeDelay(after completion)| c: onComplete(NoDelay)
    --After the main clip ends, time elay will play the clip next clip after the given amount of time passes
    --percentDelay will play the clip after the main clip reaches the given percentage of completion
  animation.createSequence = function(c_id, sequenceData)
    if sequenceData.next then
      animation.sequence[c_id] = animation.sequence[c_id] or {}
      for _, eachID in ipairs(sequenceData.next) do
        table.insert(animation.sequence[c_id], eachID)
      end
    end

    if sequenceData.percent then
      animation.percentSequence[c_id] = animation.percentSequence[c_id] or {}
      for eachID, percent in pairs(sequenceData.percent) do
        animation.percentSequence[c_id][percent] = animation.percentSequence[c_id][percent] or {}
        table.insert(animation.percentSequence[c_id][percent], eachID)
      end
    end

    local function newWait(t, nextClip)
      local wait = AnimClip.wait(t)
      animation._nextWait = animation._nextWait + 1
      animation.addClip(animation._nextWait, {co = wait, next = nextClip})
      return wait
    end

    if sequenceData.time then
      animation.sequence[c_id] = animation.sequence[c_id] or {}
      for cid, t in pairs(sequenceData.time) do
        local waitClip = newWait(t, cid)
        table.insert(animation.sequence[c_id], waitClip)
      end
    end
  end

  return animation
end

--------------------------------------------------------------------------------
Tween.easeIn = function(t)
  return t * t
end

Tween.easeOut = function(t)
  return Tween.flip(Tween.square(Tween.flip(t)))
end

Tween.smooth = function(t)
  return Tween.lerp(Tween.easeIn(t), Tween.easeOut(t), t)
end

Tween.square = function(t)
  return t ^2--Tween.flip(Tween.easeIn(t))
end

Tween.linear = function(t)
  return t
end

Tween.spike = function(t)
  if t <= 0.55 then
    return (Tween.easeIn(t))
  end
  return Tween.flip(Tween.square(t))
end

Tween.flip = function(t)
  return 1 - t
end

Tween.lerp = function(a,b,t)
  return a + (b - a) * t
end

--Coroutine Runner---------------------------------------------------------------
function CoroutineRunner()
  while next(Coru._coroutines) do
    local deadList = {}
    --Progress each coroutine
    for eachCo,callbackData in pairs(Coru._coroutines) do
      local status = coroutine.status(eachCo)
      status = Coru.step[status] and status or "catch"
      local isDead = Coru.step[status](eachCo, callbackData) == -1 or status == "dead"
      if isDead then table.insert(deadList, eachCo) end
    end

    --Empty killQueue
    for _,each in ipairs(Coru._coKillQueue) do
      table.insert(deadList, each)
    end
    Coru._coKillQueue = {}

    --Remove dead coroutines
    for _,each in ipairs(deadList) do
      Coru._coroutines[each] = nil
    end

    coroutine.yield(0)
    --Add any waiting coroutines here
    for _,each in ipairs(Coru._coQueue) do
      Coru._coroutines[each.co] = {callback = each.callback, yieldback = each.yieldback}
    end
    Coru._coQueue = {}
  end

  Coru._coRunner = false
  return 1
end

--callbackData = { yieldback = func (called each time co yeilds), callback = func (called when co ends)}
Coru.run = function(newCo, callbackData)
  if Coru._coRunner then
    table.insert(Coru._coQueue, {co = newCo, callback = callbackData and callbackData.callback, yieldback = callbackData and callbackData.yieldback})
  else
    Coru._coroutines[newCo] = {callback = callbackData and callbackData.callback, yieldback = callbackData and callbackData.yieldback}
    Coru._coRunner = startLuaCoroutine(self, "CoroutineRunner")
  end
end

Coru.stop = function(co)
  for _,each in ipairs(Coru._coQueue) do
    if each.co == co then
      if each.callback then each.callback(-1) end
      each = nil
      break
    end
  end
  if not Coru._coroutines[co] then return end

  if Coru._coRunner then
    if Coru._coroutines[co].callback then Coru._coroutines[co].callback(-1) end
    table.insert(Coru._coKillQueue, co)
  else
    if Coru._coroutines[co].callback then Coru._coroutines[co].callback(-1) end
    Coru._coroutines[co] = nil
  end
end

Coru.wait = function(t, callback)
  local newWait = coroutine.create(function()
    local t1 = Time.time
    while Time.time - t1 < t do
      coroutine.yield(0)
    end
    return 1
  end)

  Coru.run(newWait, {callback = callback})
  return newWait
end

-------------------------------------------------------------------------------
function copyTable(t)
    if t and type(t) == 'table' then
        local copy = {}
        for k, v in pairs(t) do
            copy[k] = type(v) == 'table' and copyTable(v) or v
        end
        t = copy
    end
    return t
end

function printTable(table)
  if not table or type(table) ~= 'table' then print("Error: printTable() requires a table param.") return end
  if not next(table) then print("Empty") end

  local function typeToPrintable(input)
   if input == nil then return "nil" end
   if type(input) == "string" and input == "" then return '""' end
   if type(input) == 'boolean' then return input and "true" or "false" end
   if type(input) == 'userdata' then return "userData" end
   if type(input) == "function" then return "function" end
   return input
  end

  local function pt(_table, depth)
    local string = ""
    for i = 1, depth, 1 do
      string = string .. "-"
    end

    for k,v in pairs(_table) do
      local keyString = typeToPrintable(k)
      if type(v) == "table" then
        local tableString = string .. keyString .. " = {"
        if not next(v) then tableString = tableString .. "}" end
        print(tableString)
        pt(v, depth + 1)
        print(string .. "}")
      else
        print(string .. keyString .. ": " .. typeToPrintable(v))
      end
    end
  end

  print("______________")
  pt(table, 0)
end

local _deletedItemsGuid = false
function ignoreDeletedItem(guid)
    local deletedItems = _deletedItemsGuid and getObjectFromGUID(_deletedItemsGuid)
    if not deletedItems then
        for _, object in ipairs(getAllObjects()) do
            if object.getName() == 'TI4 Deleted Items' then
                _deletedItemsGuid = object.getGUID()
                deletedItems = object
                break
            end
        end
    end
    if deletedItems then
        deletedItems.call('ignoreGuid', guid)
    end
end

--Embeded toggle button functionality-------------------------------------------
--------------------------------------------------------------------------------
ToggleButton.groups = {}
ToggleButton.btns = {}
ToggleButton.uiTarget = {obj = self, guid = self.getGUID()}
--param is obj ref or obj guid
ToggleButton.setUiTarget = function(param)
  assert(param ~= nil)
  if type(param) == 'string' then
    assert(param ~= "")
    ToggleButton.uiTarget.guid = param
    ToggleButton.uiTarget.obj = getObjectFromGUID(param)
  else
    ToggleButton.uiTarget.obj = param
    ToggleButton.uiTarget.guid = param.getGUID()
  end
end

--params = {name = "groupName/id", members = {stringTable of ui IDs}, activeLimit = #of members able to be active at one time}
ToggleButton.newGroup = function(params)
  assert(params and type(params) == 'table')
  assert(params.name and type(params.name) == 'string' and ToggleButton.groups[params.name] == nil)
  assert(params.activeLimit == nil or type(params.activeLimit) == 'number')

  ToggleButton.groups[params.name] = {name = params.name, members = {}, activeLimit = params.activeLimit or 1, activeQueue = {}, restricting = true}
  if params.members ~= nil then
    if type(params.members) == 'string' then
      assert(ToggleButton.btns[params.members])
      ToggleButton.groups[params.name].members[params.members] = params.members
      ToggleButton.btns[params.members].group = params.name
    else
      assert(type(params.members) == 'table')
      for _,eachID in pairs(params.members) do
        assert(ToggleButton.btns[eachID])
        ToggleButton.groups[params.name].members[eachID] = eachID
        ToggleButton.btns[eachID].group = params.name
      end
    end
  end
end

ToggleButton.setGroupRestricting = function(groupName, toState)
  assert(ToggleButton.groups[groupName])
  assert(toState == nil or type(toState) == 'boolean')

  local group = ToggleButton.groups[groupName]
  if group.restricting == toState then return end

  group.restricting = toState or false
  if toState and #group.activeQueue > group.activeLimit then
    for i = #group.activeQueue, group.activeLimit, -1 do
      ToggleButton.setState(ToggleButton.btns[group.activeQueue[i]], false)
      group.activeQueue[i] = nil
    end
  end
end

ToggleButton.toggleGroupRestricting = function(groupName, toState)
  assert(ToggleButton.groups[groupName])
  ToggleButton.setGroupRestricting(groupName, ToggleButton.groups[groupName].restricting)
end

--Limit is the number of active toggleButtons allowed on at the same time
--max == nil means no limit, a limit of 0 is not supported
ToggleButton.setGroupLimit = function(groupName, max)
  assert(ToggleButton.groups[groupName])
  assert(max == nil or type(max) == 'number' and max ~= 0)
  local newMax = max ~= nil and max or 1000
  local group = ToggleButton.groups[groupName]
  local queueCount = #group.activeQueue
  if group.restricting and queueCount > newMax then
    --deactiveate excess active buttons
    for i = queueCount, group.activeLimit, -1 do
      ToggleButton.setState(ToggleButton.btns[group.activeQueue[i]], false)
      group.activeQueue[i] = nil
    end
  end

  group.activeLimit = newMax
end

ToggleButton.deselectGroupMembers = function(groupName)
  assert(ToggleButton.groups[groupName])

  local group = ToggleButton.groups[groupName]
  local actives = copyTable(group.activeQueue)
  local count = #actives
  for i = count, 0, -1 do
    ToggleButton.setState(ToggleButton.btns[group.activeQueue[i]], false)
  end
end

ToggleButton.group_AddToQueue = function(groupName, buttonID)
  assert(ToggleButton.groups[groupName])
  assert(ToggleButton.btns[buttonID])
  local group = ToggleButton.groups[groupName]
  local button = ToggleButton.btns[buttonID]
  if not group.members[buttonID] or not button.isOn then return end

  table.insert(group.activeQueue, 1, buttonID)
  local count = #group.activeQueue
  if group.restricting and count > group.activeLimit then
    local id = group.activeQueue[count]
    group.activeQueue[count] = nil
    ToggleButton.setState(ToggleButton.btns[id], false)
  end
end

ToggleButton.onGroupMemberStateChange = function(groupName, member, toState)
  assert(groupName and ToggleButton.groups[groupName])
  assert(member and ToggleButton.btns[member])
  assert(toState == nil or type(toState) == 'boolean')

  local _isOn = toState ~= nil and toState or ToggleButton.btns[member].isOn
  if _isOn then
    ToggleButton.group_AddToQueue(groupName, member)
  else
    local group = ToggleButton.groups[groupName]
    if not group.members[member] then return end
    for i = #group.activeQueue, 0, -1 do
      if group.activeQueue[i] == member then
        group.activeQueue[i] = nil
        return
      end
    end
  end
end

ToggleButton.removeFromGroup = function(memberIDs)
  assert(memberIDs ~= nil)

  local group = ""
  local button = ""
  if type(memberIDs) == 'string' then
    assert(ToggleButton.btns[memberIDs])
    button = ToggleButton.btns[memberIDs]
    group = ToggleButton.groups[button.group]
    if group then
      group.members[memberIDs] = nil
      if button.isOn then
        for i = #group.activeQueue, 0, -1 do
          if group.activeQueue[i] == memberIDs then
            group.activeQueue[i] = nil
            i = 0
          end
        end
      end
    end
    button.group = nil
  else
    assert(type(memberIDs) == 'table')
    for _,eachID in pairs(memberIDs) do
      button = ToggleButton.btns[eachID]
      assert(button)
      group = ToggleButton.groups[button.group]
      if group then
        group.members[eachID] = nil
        if button.isOn then
          for i = #group.activeQueue, 0, -1 do
            if group.activeQueue[i] == memberIDs then
              group.activeQueue[i] = nil
              i = 0
            end
          end
        end
      end
      button.group = nil
    end
  end
end

ToggleButton.addToGroup = function(groupName, memberIDs)
  assert(ToggleButton.groups[groupName])
  assert(memberIDs ~= nil)

  local group = ToggleButton.groups[groupName]
  if type(memberIDs) == 'string' then
    assert(ToggleButton.btns[memberIDs])
    if ToggleButton.btns[memberIDs].group ~= nil then  ToggleButton.removeFromGroup(groupName, memberIDs) end
    ToggleButton.btns[memberIDs].group = groupName
    group.members[memberIDs] = memberIDs
    if ToggleButton.btns[memberIDs].isOn then ToggleButton.group_AddToQueue(groupName, eachID) end
  else
    assert(type(memberIDs) == 'table')
    local button = ""
    for _,eachID in pairs(memberIDs) do
      button = ToggleButton.btns[eachID]
      assert(button)
      if button.group ~= groupName then
        if button.group ~= nil then ToggleButton.removeFromGroup(groupName, eachID) end
        button.group = groupName
        group.members[eachID] = eachID
        if button.isOn then ToggleButton.group_AddToQueue(groupName, eachID) end
      end
    end
  end
end

ToggleButton.new = function(params)
  assert(params and type(params) == 'table')
  local toggleBtn =
  {
    id = params.id, --should match the xml id attribute
    onIcon = params.onIcon,
    onIcon_Hover = params.onIcon_Hover,
    onIcon_Pressed = params.onIcon_Pressed,
    onIcon_Disabled = params.onIcon_Disabled,
    offIcon = params.offIcon,
    offIcon_Hover = params.offIcon_Hover,
    offIcon_Pressed = params.offIcon_Pressed,
    offIcon_Disabled = params.offIcon_Disabled,

    onClick = params.onClick,
    onValueChanged = params.onValueChanged,--onValueChanged('id', bool)
    isOn = false,
    isToggleButton = true, --type check, don't change
  }
  self.UI.setAttributes(toggleBtn.id, {
    transition = "SpriteSwap",
    isOn = false,
    onClick = "onToggleClicked"
  })
  ToggleButton.btns[toggleBtn.id] = toggleBtn
  ToggleButton.setSprite(toggleBtn, false)
  return toggleBtn
end

ToggleButton.newAsXmlTable = function(params)
  assert(params and type(params) == 'table')
  local toggleBtn =
  {
    id = params.id,
    onIcon = params.onIcon,
    onIcon_Hover = params.onIcon_Hover,
    onIcon_Pressed = params.onIcon_Pressed or params.onIcon,
    onIcon_Disabled = params.onIcon_Disabled or params.onIcon,
    offIcon = params.offIcon,
    offIcon_Hover = params.offIcon_Hover,
    offIcon_Pressed = params.offIcon_Pressed or params.offIcon,
    offIcon_Disabled = params.offIcon_Disabled or params.offIcon,

    onClick = params.onClick, --callback, not the same as the xml onClick
    onValueChanged = params.onValueChanged,--onValueChanged('id', bool)
    isOn = false,
    isToggleButton = true, --type check, don't change
  }
  local appendGUID = params.appendGUID and params.appendGUID .. "/" or ""
  --ToggleButton.uiTarget.obj ~= self and ToggleButton.uiTarget.guid .."/" or ""
  local btnXML = {
    tag = "Button",
    attributes = {
      isOn = false,
      id = params.id,
      transition = "SpriteSwap",
      sprite = toggleBtn.offIcon,
      highlightedSprite = toggleBtn.offIcon_Hover,
      pressedSprite =  toggleBtn.offIcon_Pressed,
      disabledSprite =  toggleBtn.offIcon_Disabled,
      onClick = appendGUID .. "onToggleClicked"
    },
    children = {}
  }
  --copy attributes to xml
  if params.attributes and type(params.attributes) == 'table' then
    for key,val in pairs(params.attributes) do
      btnXML.attributes[key] = val
    end
  end
  --copy children to xml
  if params.children and type(params.children) == 'table' then
    btnXML.children = {}
    for key,val in pairs(params.children) do
      btnXML.children[key] = val
    end
  end
  ToggleButton.btns[toggleBtn.id] = toggleBtn
  return btnXML
end

ToggleButton.setState = function(button, bool, targetUI)
  assert(button ~= nil and button.isToggleButton)
  local uiObj = targetUI ~= nil and targetUI or ToggleButton.uiTarget.obj
  local toState = bool and true or false
  --if bool ~= nil and type(bool) == 'boolean' then toState = bool end
  if uiObj == ToggleButton.uiTarget.obj then
    if button.isOn == toState then return end
  elseif uiObj.UI.getAttribute(button.id, "isOn") == toState then return end --if the button has been copied to multiple objct ui's

  button.isOn = toState
  uiObj.UI.setAttributes(button.id,
    {
      sprite = toState and button.onIcon or button.offIcon,
      highlightedSprite = toState and button.onIcon_Hover or button.offIcon_Hover,
      pressedSprite = toState and button.onIcon_Pressed or button.offIcon_Pressed,
      disabledSprite = toState and button.onIcon_Disabled or button.offIcon_Disabled,
      isOn = toState,
    }
  )
  if button.group then ToggleButton.onGroupMemberStateChange(button.group, button.id, button.isOn) end
  if type(button.onValueChanged) == 'function' then
    button.onValueChanged(button.id, toState)
  end
end

ToggleButton.toggle = function(button)
  assert(button ~= nil and button.isToggleButton)
  ToggleButton.setState(button, not button.isOn)
end

ToggleButton.setSprite = function(button, toState, targetUI)
  assert(button ~= nil and button.isToggleButton)
  local uiObj = targetUI ~= nil and targetUI or ToggleButton.uiTarget.obj
  local _toState = false
  if toState ~= nil and type(toState) == 'boolean' then _toState = toState end

  uiObj.UI.setAttributes(button.id,
    {
      sprite = _toState and button.onIcon or button.offIcon,
      highlightedSprite = _toState and button.onIcon_Hover or button.offIcon_Hover,
      pressedSprite = _toState and button.onIcon_Pressed or button.offIcon_Pressed,
      disabledSprite = _toState and button.onIcon_Disabled or button.offIcon_Disabled,
    }
  )
end

-- UI onClick cannot call ToggleButton.someFunc or ToggleButton (using __call metaTable)
function onToggleClicked(player, value, id)
  assert(ToggleButton.btns[id])
  local button = ToggleButton.btns[id]

  ToggleButton.toggle(button)
  if type(button.onClick) ~= 'function' then return end
  button.onClick(player, button.isOn, id)
end

--------------------------------------------------------------------------------

-- Index is only called when the key does not already exist.
local _lockGlobalsMetaTable = {}
function _lockGlobalsMetaTable.__index(table, key)
    error('Accessing missing global "' .. tostring(key or '<nil>') .. '", typo?', 2)
end
function _lockGlobalsMetaTable.__newindex(table, key, value)
    error('Globals are locked, cannot create global variable "' .. tostring(key or '<nil>') .. '"', 2)
end
setmetatable(_G, _lockGlobalsMetaTable)